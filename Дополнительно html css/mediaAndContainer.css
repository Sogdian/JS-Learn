/* Медиазапросы
    Необязательная часть:
        модификатор:
            only - говорит старым браузерам игнорировать медиазапрос. В настоящее время можно не указывать,
            not - инвертирует условие
        медиатип:
            all - тип по умолчанию,
            screen - есть экран,
            print - для печатающих устройств и документов в режиме «Предварительный просмотр» (print) (кроме печатных устройств и предпросмотра документов).
        логический оператор:
            and,
                or (или запятая) - для выполнения одного из условий
    Обязательная часть:
        характеристики устройства:
         resolution — разрешение устройства
            min-resolution — минимальное разрешение устройства.
            max-resolution — максимальное разрешение устройства.
         orientation:
             landscape — альбомная (когда ширина окна просмотра больше его высоты).
             portrait — портретная (когда высота больше ширины).

Порядок написания запросов:
  для десктопа - от большего размера экрана к меньшему сверху вниз
    max-width: 1400px, далее max-width: 1200px, ...
  для мобильных - от меньшего размера экрана к большему сверху вниз
    min-width: 576px, далее min-width: 768px, ...

Переменные в медиазапросах не работают
  @media (min-width: var(--sm)) {}

em или rem в медиазапросах
  Чтобы посчитать нужное значение в относительных единицах, разделите значение брейкпоинта в пикселях на 16px.
  Например, если по макету изменение внешнего вида происходит при 1440px, брейкпоинт будет 1440 / 16 = 90em.
*/

@media only screen
and (min-device-width: 320px) /* для телефонов с таким мин размером экрана. Для примера взят iPhone5 */
and (max-device-width: 568px) /* для телефонов с таким макс размером экрана. У iPhone5 это высота, но видимо имеется ввиду альбомная ориентация */ {
  .header {
    /* тут можно задать стили для тегов только для экранов с размерами выше */
  }
}
@media (min-width: 720px) and (max-width: 730px) { /* = (width >= 720px) and (width <= 730px) = (720px <= width <= 730px) */
  /* пока ширина окна просмотра превышает 720 пикселей включительно - будет работать правило */
  /* пока ширина окна просмотра не превышает 730 пикселей включительно - будет работать правило  */
  body { background-color: #000; }
}

/*prefers-* медиафичи
    prefers-color-scheme - пользователи могут указать желаемую цветовую схему, контрастность или количество анимации в настройках своей операционной системы (ОС) или браузера
        prefers-color-scheme берется из настроек ОС: Параметры → Персонализация → Цвета → Выберите режим приложения по умолчанию,
        dark темная тема, light светлая или не выразил предпочтения
    prefers-reduced-motion помогает определить, хочет пользователь уменьшить количество анимации или нет.
        no-preference указывает, что пользователь не выразил предпочтений относительно количества анимации.
        reduce указывает, что пользователь предпочитает интерфейс с минимальной анимацией, вплоть до полного отключения.
    prefers-contrast - Помогает менять стилизацию в зависимости от желаемого уровня контрастности.
        no-preference — настройка по умолчанию, пользователь не выразил никаких предпочтений.
        more — предпочтение высокого уровня контрастности.
        less — предпочтение низкого уровня контрастности.
        custom — режим принудительных цветов.

    hover - проверяет, позволяет ли основное устройство наводить указатель на элементы
        none — не поддерживает наведение на элемент, например: стилус и сенсорный экран.
        hover — поддерживает наведение на элемент, например: мышь, тачпад и контроллер игровой консоли.
    pointer - проверяет наличие и точность основного указывающего устройства.
        none — не является указывающим устройством.
          course — грубая точность, например: сенсорный экран, контроллер игровой консоли и её периферийные устройства.
        fine —хорошая точность, например: компьютерная мышь, стилус.
    */
@media (prefers-color-scheme: dark) {
  body {
    --main-text-color: #ffffff;
    --main-background-color: #152028;
  }
}
@media (prefers-color-scheme: light) {
  body {
    --main-text-color: #152028;
    --main-background-color: #ffffff;
  }
}

/*----------------------------------------------------------*/
/* Переключение тем */
.theme_auto /* будет */
  /*variables.css*/
:root {
  --rec-non-visibility: none; /* дефолтное значение display: none */ /* основные стили сделаны для светлой темы, темная вторична */
}
  /*light.css*/
.page.theme_light { /* так же как и в variables.css */
  --rec-non-visibility: none;
}
.page.theme_light .header__record { /* элемент, который видно только в темной теме*/
  display: var(--rec-non-visibility);
}
@media (prefers-color-scheme: light) { /* Настройка для темы (светлая) которую выберет пользователь у себя на компе (или в одноименных настройках в девтулс)*/
  body {
    --rec-non-visibility: none; /* так же как и в .theme_light */
  }
}
  /*dark.css*/
.page.theme_dark {
  --rec-non-visibility: initial;
}
.page.theme_dark .header__record {...}
.page.theme_dark .header__record::after {...}
.page.theme_auto .header__record {
  display: var(--rec-non-visibility); /* возьмет настройки из @media (prefers-color-scheme: dark) */
}
.page.theme_auto .header__record::after {
  display: var(--rec-non-visibility);
}
@media (prefers-color-scheme: dark) { /* Настройка для темы (темная) которую выберет пользователь у себя на компе (или в одноименных настройках в девтулс)*/
  body {
    --rec-non-visibility: initial; /* в данной авто темной теме должны быть такие же настройки как в темной темы (при переключении по кнопке, т.е. через .page.theme_dark) */
  }
}

/* Также надо указать color-scheme в теге <meta>
  <meta name="color-scheme" content="light dark" />

С помощью prefers-color-scheme задаётся собственный внешний вид страницы,
  в то время как color-scheme автоматически подбирает значения для браузерных стилей, которые не были переопределены. */

/*----------------------------------------------------------*/


/* Выражения от контейнера */
.parent {
  container-type: size; /*
    normal — значение по умолчанию. Создаёт контейнер, который не позволяет запрашивать размеры, но разрешает запрос стилей. Как запрашивать стили, подробнее расскажем в следующем уроке.
    inline-size — создаёт контейнер, который позволяет запрашивать размер по строчному направлению оси.
    size — создаёт контейнер, который позволяет запрашивать размер по любой оси: и строчной, и блочной. Обратите внимание, сейчас не существует способа создать контейнер, позволяющий запрашивать исключительно размер по блочной оси, вместо этого придется указывать значение size:
  */
}
@container (inline-size <= 280px) {
  .parent__child {
    display: none;
  }
}

/* у контейнера можно запрашивать любые вычисленные стили. Для этого используется функция style().
  Вычисленное значение — процесс преобразования относительного значения в абсолютное. Например, если у элемента font-size: 18px, а padding: 2em, то вычисленное значение padding будет 36px. */
.sidebar {
  container-type: inline-size;
  --bg-color: #ffc802;
  background-color: var(--bg-color);
}
@container style(--bg-color: #ffc802) { /* карточка sidebar__content меняет цвет в зависимости от фона контейнера sidebar
  если у родителя sidebar --bg-color = #ffc802, то sidebar__content надо сменит цвет на #ffffff */
  .sidebar__content {
    background-color: #ffffff;
  }
}

/*контейнеры друг в друге
  Как вы уже могли заметить, container-name — необязательное свойство.
  При запросе к конкретному контейнеру — стили применятся, если компонент находится именно в нём.
  Если не указывать имя контейнера, возьмётся ближайший, а если такового нет, выражение от контейнера не будет работать.

  Новые единицы измерения от контейнера:
    cqw — 1% от ширины контейнера.
    cqh — 1% от высоты контейнера.
    cqi — 1% от inline-size контейнера.
    cqb — 1% от block-size контейнера.
    cqmin — меньшее из cqi и cqb.
    cqmax — большее из cqi и cqb.*/
.cards__item {
  container-type: inline-size; /* Сокращения. container: container-name / container-type = container: cards-item / inline-size; */
  container-name: cards-item;
}
.card {
  container-type: inline-size;
  container-name: card;
}
.button {
  /* стили компонента */
}
@container cards-item (inline-size >= 300px) {
  .button {
    /* изменение стилей */
  }
}
