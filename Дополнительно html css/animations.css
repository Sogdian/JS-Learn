div {
  transform: rotate(15deg) scale(1.1) translateY(20%); /* сразу 3 трансформации. Все трансформации применятся к элементу по порядку.  */
  transform: rotate(-10deg); /* Функции CSS-трансформации https://doka.guide/css/transform-function/ */
  transform: rotate(10deg); /* повернуть по  часовой стрелки, если отрицательное — против часовой */
  transform: scale(1.04);
  /* изменение масштаба элемента. изменения не влияют на соседей. Они не сдвигаются и не страдают, страница не дёргается и не ломается
         Если значение указано одно, оно применится к обеим осям. Элемент увеличится и в ширину, и в высоту. Если значения два, первое повлияет на размер по строчной оси, а второе — на размер по блочной оси.
         Изначальный масштаб элемента равен 1. Если указать значения от 0 до 1, элемент будет уменьшаться, а если от 1 до бесконечности — увеличиваться.
         Существуют отдельные функции scaleX() и scaleY() */
  transform: translate(-50%, -50%, -50%);
  /* смещение элемента по горизонтали, вертикали, z оси
         Если значение в скобках только одно, то элемент сместится по горизонтали. По вертикали при этом браузер подставит 0 */
  transform: translateX(100%); /* сдвинуть вправо на ширину контейнера */
  transform: translate(0); /* вернуть назад */
  transform-origin: 100% 0; /* перемещать точку, вокруг которой происходит трансформация. По умолчанию точка трансформации находится в центре элемента. */
  transform-origin: top;
  /* = transform-origin: center top. Ключевые слова для разных осей разные: вертикаль — top и bottom; горизонталь — left и right, так что браузер разберётся.
         Если же вы используете числовое значение, при одном значении браузер думает, что оно применимо только к оси X. А ось Y остаётся по центру элемента. Можно также указать два или три значения: первое для оси X, второе для оси Y, третье для оси Z. Третье значение может быть только числовым, для него нет ключевых слов*/
  transform: skew(-10deg);
  /* элемент становится косым
         Первое или единственное значение смещает верхнюю часть элемента относительно нижней. Второе смещает левый край относительно правого. Можно использовать отдельные функции skewX() и skewY(). */
  transform: matrix(a, b, c, d, tx, ty);
  /* шорткат для вообще всех возможных трансформаций
       rotate(90deg) → matrix(0, 1, -1, 0, 0, 0);
       scale(1.1) → matrix(1.1, 0, 0, 1.1, 0, 0);
       translate(0, 100px) → matrix(1, 0, 0, 1, 0, 100);
       rotate(90deg) scale(1.1) translate(0, 100px) → matrix(0, 1.1, -1.1, 0, -110, 0). */
  /*или испольщовать сразу функции translate(); scale(); rotate(). */
  rotate: 15deg;
  scale: 1.1;
  translate: 0 20%;
}

.header__theme-menu-button {
  transition: outline 0.1s; /* плавный hover элемента через outline (см. .header__theme-menu-button:hover { outline: 1px solid currentColor; }) */
  transition: color 0.5s; /* или через color элемента родителя*/
  transition-timing-function: ease;  /* функция времени. Это свойство отвечает за то, как будет развиваться переход с течением времени
     ease — значение по умолчанию, ускоряется к середине анимации, замедляется в конце;
     ease-in — начинается медленно, заканчивается быстро;
     ease-out — начинается быстро, заканчивается медленно;
     ease-in-out — медленно начинается и заканчивается, а в середине ускоряется;
     linear — меняется с одинаковой скоростью. */
}
.header__theme-menu-button:hover {
  outline: 1px solid currentColor; /* transition изменяет свойство, которое есть в hover, пример outline, этот outline и надо прописать в transition */
}

/* анимация лоадера */
.loader {
  /* шорткат animation: animation-name animation-duration animation-timing-function animation-iteration-count animation-direction animation-delay animation-fill-mode animation-play-state */
  animation: loading 1.5s infinite linear reverse; /* шорткат для свойсвт ниже */
  animation-name: loading; /* присвоение элементу имени анимации (название набора кадров) */
  animation-duration: 1.5s; /* время анимации, за которое должны проиграться все кадры */
  animation-iteration-count: infinite; /* анимация повторялась раз за разом и не останавливалась */
  animation-timing-function: linear;
  /* временная функция
       linear - анимация проигрывается равномерно, без колебаний скорости
       steps-start - анимация в самом начале прыгает в финальное состояние и там остаётся до конца
       steps-end - элемент не меняется всё время анимации, а потом резко прыгает в финальное состояние
       steps() - принимает два параметра: количество шагов и направление шага. Обязательный параметр — количество шагов. Второй можно опустить.
       cubic-bezier(0.25, 0.1, 0.25, 1.0) - кривая безье
       linear() */
  animation-direction: reverse; /* направление анимации */
  animation-delay: 1s; /* задержка анимации */
  animation-fill-mode: forwards; /* останется ли элемент со стилями, которые были в последнем кадре анимации, или вернётся в исходное состояние */
  animation-play-state: running;
  /* рычаг, чтобы ставить анимацию на паузу или запускать её снова по какому-то действию
     running — значение по умолчанию, анимация проигрывается.
     paused — анимация ставится на паузу. При повторном запуске анимации она продолжается с того места, где была остановлена.*/
}
@keyframes loading { /* keyframes - кадры анимации (0%, 100%) */
  0% {
    rotate: 0deg;
  }
  100% {
    rotate: 360deg;
  }
}

/* вынести в отдельный слой */
.link {
  will-change: transform;
  /* в will-change указывается свойство, которое будет анимировать и его надо вынести в отдельный слой для отрисовки браузером
     will-change: auto В этом случае браузеру приходится самому догадываться, нужно ли выносить этот элемент на отдельный слой */
}
.link:hover {
  transform: translateX(10px);
}

svg {
  stroke: white; /* задаёт цвет обводки SVG-элемента */
  stroke-dasharray: 3; /* позволяет разделить линию обводки на отрезки. Длина этих отрезков будет равняться числу, указанному в этом свойстве */
  stroke-dashoffset: 4; /* позволяет двигать пунктир вдоль направления, определённого в path */
}



/* пример анимации с fill*/
svg {
  fill: #5f0dee;
  animation: fill-animation 5s infinite forwards;
}
@keyframes fill-animation {
  25% {
    fill: #6dc1fd;
  }
  to {
    fill: #5f0dee;
  }
}
