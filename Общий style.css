/*
В инструментах разработчика браузерные стили называются «Таблица стилей агента пользователя» или «User agent styles».

Наследование: наследование / не наследование свойств родителя
    Перекрёстное наследование: выносится общее отдельное правило CSS, и создаются доп. правила где меняется одно свойство, например, цвет фона для правил: .button-send, .button-clear, .button-navigation.
Каскадность: Этот механизм комбинирования стилей из разных источников в итоговый набор свойств и значений для каждого HTML-элемента.
    Каскадность обозначает, что к одному и тому же элементу может применяться несколько CSS-правил (наборов CSS-свойств).
    Среди этих свойств могут быть и конфликтующие между собой. Поэтому существуют инструкции, которые определяют, каким будет финальный набор свойств элемента.
    Каскадирование как раз и определяет, какие именно свойства из разных источников (CSS правил) применятся к данному элементу на странице.
    Конфликт стилей. Конфликт разрешается максимум за три шага:
        важность. Сравниваются приоритеты стилевых файлов. Например, авторские (то есть наши) стили приоритетнее браузерных. CSS-правила, которые прописаны в style (в теге в разметке) обладают наивысшим приоритетом (но так делать плохо)
            Однако существует способ переопределить из подключаемых CSS-файлов даже стили, заданные в атрибуте style. Для этого нужно использовать в CSS ключевое слово !important. Оно задаёт CSS-свойству усиленный приоритет. div { color: blue !important; }
        специфичность. Чем меньшее количество элементов потенциально может выбрать селектор, тем он специфичнее. Например, селектор по классу более специфичен, чем селектор по тегу. Самый специфичный тег это #, т.е. атрибут id
            Расчет специфичности см. ниже
        порядок исходного кода. Побеждает то свойство, которое находится ниже в коде.
    Каскад работает и внутри CSS-правил, поэтому в конфликт вступили «обычный» margin-bottom и аналогичный компонент составного свойства (margin). «Обычное» свойство (margin-bottom) победило, так как находится ниже в коде:
    div { margin: 0; margin-bottom: 10px; }

Наследуемые свойства: font-size, font-family, font-style, font-weight, color, text-align, text-transform, text-indent, line-height, letter-spacing, word-spacing, white-space, direction и другие. Также  list-style, cursor, visibility, border-collapse и некоторые другие. https://www.w3.org/TR/CSS22/propidx.html (если есть Inherited?=yes)
    Но это не работает, если у браузеров есть стили по умолчанию. Пример, font-size (color для ссылок, font-weight для h1) от body не будет наследоваться заголовками? Это происходит из-за того, что размер шрифта заголовков явно задан внутри браузерных стилей по умолчанию (и наследуемое от body значение им не нужно).
Ненаследуемые свойства: background, border, padding, margin, width, height, position и другие. https://www.w3.org/TR/CSS22/propidx.html (если есть Inherited?=no). Не наследуются они из соображений здравого смысла. Например, если для какого-либо блока установлен внутренний отступ, автоматически выставлять такой же отступ каждому вложенному элементу нет никакой надобности. Эти параметры чаще всего уникальны для каждого отдельного блока.

Составные свойства - где перечисляются сразу много значений (font: 16px/26px "Arial", sans-serif;)

Относительные и абсолютные размеры:
width: 100%; % - относительный размер (em, rem, vh, vw, %), https://www.w3.org/TR/css3-values/#relative-lengths
padding: 8px; - абсолютный размер, https://www.w3.org/TR/css3-values/#absolute-lengths

Браузерные стили по умолчанию - дефолтные стили, которые не задаются, но они есть (в списках, по дефолту есть маркеты)

Контекстные селекторы используются для вложенных друг в друга элементов. Селектор может состоять из нескольких частей, разделённых пробелом, пример,
    p strong { ... }
Соседние селекторы используются для расположенных рядом элементов через "+", пример,
    .fourth + li { background-color: red; }
Стиль к дочерним элементам через >
    .places > li > span { font-weight: bold; }

Псевдоклассы
    li:first-child (Подробнее https://htmlacademy.ru/demos/2#3)
    li:last-child
    li:nth-child(2) (выберет второй элемент списка). Подробнее https://htmlacademy.ru/demos/2#1
        li:nth-child(2n) = li:nth-child(even) (выберет каждый второй элемент. Выражение :nth-child(2n) соответствует всем чётным элементам. Начинается n c 0)
    li:nth-child(odd) (для нечетных элементов)
    li:nth-child(3n-1) (для элементов: 2, 5. Начинается n c 0)

    a:link выбирает ещё не посещённые ссылки (только для ссылок). Обратите внимание на порядок правил. Если их расположить по-другому, то некоторые могут не сработать.
        a:visited выбирает посещённые ссылки (только для ссылок)
        a:hover позволяет выбрать элемент, когда на него наведён курсор мыши и кнопка мыши не нажата
        a:active выбирает активные ссылки (кнопка мыши зажата на ссылке) (только для ссылок)
    input:focus позволяет выбрать элемент, который в данный момент в фокусе. В фокусе могут быть не только текстовые поля. Если вы переключаетесь между элементами веб-страницы с помощью клавиши tab, то в фокус будут попадать ссылки.

Как отцентровать элемент?
    Задать элементу ширину, которая меньше ширины родительского контейнера.
    Задать для внешних отступов справа и слева значение auto. (margin: 0 auto;)

Хороший код. ПРописывать свойства по максимум в родителях, используя принцип наследования.
В CSS работу селектора обнаружить проще: добавьте в правило цвет фона.
градиент https://webgradients.com/

./ — выйдем в родительскую (ближайшую подпапку)
../ — выйдем из свой подпапки, где мы находимся на уровень выше
/ — сразу начинаем указывать путь от корневого (главного) каталога проекта
ничего не прописывать — если нужен файл в этой же папке
*/

@import url(main.css); /* import - название директивы, main.css - правила. Директивы - инструкции для CSS, которые меняют отображение или поведение элементов на странице.
Ими можно подключать CSS-код и шрифты, создавать анимации. */

p {
    background: inherit; /* наследование свойств родителя */
}
/**/
p {
    font-size: 14px;
}
.beloved-color {
    color: green;
}
    /* ИТОГО
    font-size: 14px;  из правила для p в наших стилях
    color: green;     из правила для .beloved-color в наших стилях
    margin: 1em 0;    из правила для p в браузерных стилях
    Это пример реализации каскадности */

* {
    box-sizing: content-box; /* По умолчанию. Границы и внутренний отступ расширяют элемент. Статья http://simonenko.su/32197993404/use-css3-box-sizing
    По умолчанию в боксовой модели ширина, которую вы задаёте элементу, применяется только для контента. Если у элемента есть внутренний отступ, то он добавится к ширине */
        box-sizing: border-box; /* границы и внутренние отступы отрисуются внутрь - ТАК ЛУЧШЕ   */
}

body, h1, p, img { /* "*" - для всех элементов на странице*/
    margin: 0
}

@font-face { /* Файл css/style.css */ /* «at-rules» ещё называют CSS-директивами */
    font-family: "Some Font Name";
    font-style: normal;
    font-weight: 400;
    src: url("../fonts/some-font.woff2") format("woff2");
    font-display: swap;
}

input[type="text"], /* при вводе букв - буквы видно */
input[type="password"], /* при вводе букв - буквы вводятся звездочками */
input[type="search"] { /* стиль для всех инпутов перечисленных типов type */
    padding: 8px;
}

.header {
    min-width: 850px;  /* фиксированная верстка, не адаптивная*/
    width: 210px; /* CSS-свойство width задаёт не общую ширину блока, а только ширину содержания. Общая ширина блока затем складывается из трёх компонентов: ширины содержания, внутренних отступов и ширины рамок слева и справа. */
        width: 100%; /* блок занимает всю ширину родительского блока. Если блоку добавить внутренние отступы и рамки, то его общая ширина становится больше ширины родителя. 100% ширины тега равно 100% ширины окна просмотра (без отступов и рамок). */
        width: auto; /* Вернуть значения по умолчанию, т.е. ширину (высоту) как у родительского элемента. Если у блока есть внутренние отступы или рамки, то его ширина содержания автоматически уменьшается, а общая ширина остаётся равной ширине родителя. */
        width: 50vw; /* доли, в сравнении с окном просмотра*/ /* Вы можете встретить сайты, на которых секции точь-в-точь соответствуют размерам браузера. Точнее, окна браузера, в котором вы просматриваете сайт */
        /* 50vw = высота станет равна половине высоты окна просмотра */
        width: unset; /* ширина не задана */
    height: 50vh; /* доли, в сравнении с окном просмотра */

    margin: 0 auto 20px; /* margin: auto - поместит тег по центру по горизонтали, но размер тега должен быть не равный всей ширине экрана (нужны размеры меньше) */
    margin-left: auto; /* отступ автоматически высчитывается браузером */
    margin: 100px auto 50px;
        margin-top: 50px; /* Вертикальный отступ между двумя соседними элементами равен максимальному отступу между ними. Этот эффект называется эффектом «схлопывания» внешних отступов.
        «Выпадание» — это ещё один эффект, связанный с вертикальными внешними отступами.
        Если внутри родительского блока расположить блок и задать ему отступ сверху, то внутренний блок прижмётся к верхнему краю родительского, а у родительского элемента появится отступ сверху. То есть верхний отступ внутреннего элемента «выпадает» из родительского элемента
        Если у родительского элемента тоже был задан внешний отступ, то выберется максимальный отступ между собственным и «выпавшим». Чтобы избавиться от эффекта выпадания, можно задать родительскому элементу внутренний отступ (паддинг) сверху или добавить рамку сверху */
        margin-right: 10px; /* Горизонтальные отступы между элементами просто складываются. Например, горизонтальный отступ между двумя элементами с отступами 30px будет равен 60px. */
    padding-top: 45px;
    padding: 5%;
    /* направление расстановки — по часовой стрелке, начиная сверху */
    /* 4 значения */
    /* для каждой стороны – своё значение */
    /*padding: 20px 15px 30px 15px;
    /* 3 значения */
    /* верх — 10px, по бокам — 20px, низ — 30px */
    /*padding: 10px 20px 30px;
    /* 2 значения */
    /* верх и низ — 10px, по бокам — 20px */
    /*padding: 10px 20px;
    /* 1 значение */
    /* 10px со всех сторон */
    /*padding: 10px; */
    /* между паддингами заголовков h1 и h2 есть дефолтный паддинг больше чем 4px */

    border: 3px solid #000; /* свойства границы */
        border-color: #000; /* цвет границы */
        border-width: 1px; /* толщина границы в px */
        border-style: solid; /* начертание границы */ /* https://practicum.yandex.ru/trainer/frontend-developer/lesson/c81e6879-f57a-4ce4-8d4c-fc980703825e/#:~:text=%D0%BE%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D1%8F%D1%8E%D1%82%20%D1%81%D0%B2%D0%BE%D0%B9%D1%81%D1%82%D0%B2%D0%B0%D0%BC%D0%B8%20%D0%B3%D1%80%D1%83%D0%BF%D0%BF%D1%8B-,border,-%3A */
    border-radius: 5px; /* скруглить углы у border*/
    border-top-left-radius: 5px; /* угол верхний левый */
    border-top: dashed; /* стороны границы
        border-bottom: dotted;
        border-left: solid;
        border-right: solid; */
    border-spacing: 5px; /* толщина границы */

    outline: none; /* свойства границы, которые не влияет на ширину элемента */
        /* none - убирает подсветку границы инпута если поставить курсов в инпут */

    position: static; /* обычное позиционирование. Значение по умолчанию */
        /* top bottom left right - не влияют на сдвиг элемента*/
    position: relative; /* относительное позиционирование. Относительно спозиционированный элемент на самом деле никуда не смещается. Он остаётся в потоке ровно там же, где и был. А смещается иллюзорная копия блока. */
            top: -10px; /* позволяет сместить относительно спозиционированный элемент вверх или вниз относительно его исходного положения */ /* "-" смещает вверх, "+" вниз */
                bottom: -10px; /* "-" смещает вниз, "+" вверх */
                left: 10px; /* "-" смещает влево, "+" вправо */
                right: 10px; /* "-" смещает вправо, "+" влево */
            margin-bottom: 40px; /* если position: relative;, то маргины будут смещать от себя изначальное положение элемента */
    position: absolute; /* абсолютное позиционирование. Выпадают из потока документа. Место, которое они занимали, становится как бы пустым и его занимают соседние элементы. Можно спозиционировать относительно любого первого родителя, который тоже спозиционирован (все кроме static)
            Ширина по умолчанию зависит от содержимого (а не растягивается на всю доступную ширину).
            Остаются на том же месте, где были, если не заданы значения свойств top, left, right, bottom.
            Cтрочному элементу можно задавать размеры с помощью width и height. */
        left: 10px; /* "-" смещает за левый  край браузера влево, "+" от левого края браузера вправо. Задает отступ от левого края окна браузера до левого края абсолютно спозиционированного элемента */
        top: 10px; /* "-" смещает от верхнего края браузера вверх, "+" от верхнего края браузера вниз. */ /* Задает отступ от верхнего края окна браузера до верхнего края абсолютно спозиционированного элемента. */
        right: 10px; /* "-" смещает от правого края браузера вправо , "+" от правого края браузера влево. */ /* задает отступ от правого края окна браузера до правого края «абсолютного» элемента. */
        bottom: -10px; /* "-" смещает от нижнего края браузера вниз , "+" от нижнего края браузера вверх. */ /* значение bottom затолкнет элемент за нижний край окна браузера и при этом появится полоса прокрутки. задает отступ от нижнего края окна браузера до нижнего края «абсолютного» элемента.*/
            /* когда значение для left/top/right/bottom не задано, оно равно auto */
            left: auto; /* С помощью значения auto можно возвращать «абсолютные» элементы на исходное положение. */
        margin-left: 15px; /* Двигает элемент от левого края того места где раньше был элемент (до позиционирования) вправо. Неявная точка отсчета — это то место, где находился элемент до того, как ему задали абсолютное позиционирование. Можно сместить из неявной точки отсчета */
            /* Такой элемент можно сместить из неявной точки отсчета с помощью свойства margin. Оно будет работать примерно так же, как и свойства left … bottom для «относительного» элемента. */
    position: fixed; /* задаёт элементу фиксированное позиционирование, т.е. неизменное положение */
        z-index: 100; /* чем больше z-index, тем выше располагается спозиционированный блок, т.е. перекрывая другие блок сверху */

    /* display по-английски «отображение» */
    display: block; /* сделает элемент блочным */
        display: inline; /* сделает элемент строчным. Строчные элементы (например, <img> или <p>) располагаются на «базовой линии» текста. Базовая линия расположена выше нижнего края элемента, чтобы уместить свисающие части знаков. Наличие этого расстояния можно увидеть, если установить нулевой отступ между элементами.
        Строчные элементы предназначены для использования в середине абзацев, а не как самостоятельная часть макета интерфейса. Например, может быть, мы захотим добавить маленький значок в середине предложения, и тогда строчный элемент будет аккуратно выровнен по базовой линии остального текста.*/
        display: inline-block; /* сделает элемент блочно-строчным. С одной стороны, они не занимают собой всю горизонталь, с другой, восприимчивы к указанию размеров через CSS. */
        /* inline-block присвоить каждым тегам которые должны быть на одной горизонтали */
        display: table; /* задаёт боксу элемента тип таблица. */
        display: flex; /* Бокс с типом flex называют флекс-контейнером, а его дочерние боксы — флекс-элементами. Флекс-элементы автоматически выстраиваются вдоль главной оси. Можно делать колонки.
            По умолчанию флекс-элементы растягиваются по высоте, подстраиваясь под самый высокий элемент в строке
            Например, внутри него margin: auto работает не только по горизонтали */
            /* И строчные, и блочно-строчные элементы ведут себя как слова в предложении. А между словами стоят пробелы, ширина которых зависит от размера шрифта. Поэтому чтобы убрать между блоками пробел (отступ) нужно font-size: 0*/
            justify-content: flex-start; /* выравнивание по горизонтали */ /* Чтобы прижать колонки к краям родительского контейнера */ /* флекс-элементы располагаются в начале главной оси (по умолчанию — слева);
                flex-end — флекс-элементы располагаются в конце главной оси (по умолчанию — справа);
                center — флекс-элементы располагаются в центре главной оси;
                space-around — свободное пространство распределяется вокруг флекс-элементов;
                space-between — свободное пространство распределяется между флекс-элементами, при этом первый и последний элемент прижимаются к краям флекс-контейнера. */
            margin-left: auto; /* прижать к правому краю */
            margin-top: auto; /* прижать к нижнему краю */ /* margin-top: auto; + margin-bottom: auto; отцентрировать по середине*/
            align-items: start; /* выравнивание по вертикали */ /* Во флексах это свойство управляет расположением элементов на поперечной оси (Поперечная ось идёт перпендикулярно главной оси и по умолчанию направлена сверху вниз). В гридах управление по вертикали
                stretch — значение по умолчанию; элементы растягиваются на всю высоту поперечной оси.
                flex-start — элементы сжимаются до содержимого и располагаются в начале поперечной оси (по умолчанию сверху);
                flex-end — элементы сжимаются до содержимого и располагаются в конце поперечной оси (по умолчанию снизу);
                center — элементы сжимаются до содержимого и располагаются по центру поперечной оси; */
                    align-self: center; /* выравнивание по вертикали одного элемента */ /* указывает расположение флекс элемента на поперечной оси
                        stretch — значение по умолчанию; элементы начинаются у верхней границы и растягиваются на всю высоту.
                        end — элементы выстраиваются по нижней границе;
                        center — элементы располагаются по центру; */
            flex-direction: row; /* направление в ряд */ /* меняет направление главной и поперечной оси флекс или грид контейнера */ /* значение по умолчанию*/ /* Если главная ось направлена сверху вниз, то для выравнивания всех элементов по вертикали используют justify-content.
                column - направление в колонку (сверху вниз)
                column-reverse - направление в перевернутую колонку
                row-reverse - направление в перевернутый ряд */
            order: 0; /* порядок элементов внутри флекс контейнера */ /* значение по умолчанию */
                order: -1; /* переместить выше */ /* Элементы выстраиваются от меньшего значения order к большему. Если у нескольких элементов одинаковое значение, используется их порядок в разметке. */
            max-width: 100%; /* задаёт максимальную ширину, а значение 100% говорит, что элемент не должен становиться больше ширины родителя. */ /* Этот способ работает, потому что у CSS-свойств max-width и height приоритет выше, чем у атрибутов width и height в разметке. */
                height: auto; /*  задаёт высоту элемента. Значение auto используют, чтобы изображение не деформировалось и сохраняло свои пропорции. */
        flex-grow: 1; /* свойство указывает, может ли вырастать флекс-элемент при наличии свободного места, и на сколько */

        display: grid; /* Бокс с типом grid называют грид-контейнером, а дочерние, то есть непосредственно вложенные в него теги — грид-элементами. По умолчанию грид-контейнер одноколоночный.
            Можно делать колонки. Эта технология позволяет легко создавать как фиксированные, так и тянущиеся колонки, а также управлять отступами между ними. */
            grid-template-columns: 100px 150px 80px; /* разбивает содержимое по 3м колонкам */ /* + нужны padding отступы*/
                grid-template-columns: 1fr 200px; /* правая колонка 200px, а левая все оставшееся пространство */
                grid-template-columns: 1fr 2fr; /* сокращённое от fraction — «доля»). Она означает долю доступного пространства в грид-контейнере. */
                grid-template-columns: repeat(2, 295px); /* 2 по 295px */
                    grid-template-columns: repeat(auto-fit, 100px); /* Значение auto-fit указывает, что колонок должно быть столько, сколько может поместиться в грид-контейнере. */
                    grid-template-columns: repeat(auto-fit, minmax(100px, 150px)); /* ширина колонок изменялась динамически и зависела от наличия свободного пространства. В скобках после minmax задают минимальный и максимальный размеры колонок
                        Код позволит колонкам изменять ширину в зависимости от имеющегося в контейнере свободного пространства. При этом колонки не станут меньше 100px и не растянутся больше, чем на 150px:*/
                        grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); /* fr позволяет колонкам увеличивать ширину до тех пор, пока свободного пространства в контейнере не хватит на ещё одну колонку. Т.е. делает так, чтобы можно было засунуть еще одну колонку с min шириной 140px*/
            grid-column: span 3; /* растянет колонку на 3 колонки */
                grid-row: span 2; /* растянет ряд на 3 ряда */
                grid-auto-flow: row; /* row говорит располагать элементы в том порядке, в котором они идут в разметке, и при необходимости создавать новые ряды */ /* row - значение по умолчанию.
                dense - контейнер будет заполняться так, чтобы не было пропусков. Лучший вариант. Значение dense заставляет грид-контейнер заполнять пустые ячейки первым подходящим по размеру грид-элементом */
            column-gap: 15px; /* отвечает за расстояние между колонками. У последней колонки не будет отступа справа, что очень необходимо */
            row-gap: 5px; /* за расстояние между рядами. У последнего ряда не будет отступа снизу, что очень необходимо */
                gap: 20px; /* Если же отступы одинаковы, удобно использовать составное свойство gap */
            align-items: start; /* выравнивание по вертикали */ /* управляет выравниванием грид и флекс контейнеров по вертикали */ /* элементы выстраиваются по верхней границе и, если содержимого немного, не тянутся на всю высоту;
                stretch — значение по умолчанию; элементы начинаются у верхней границы и растягиваются на всю высоту.
                end — элементы выстраиваются по нижней границе;
                center — элементы располагаются по центру; */
                justify-self: start; /* выравнивание отдельного элемента по горизонтали
                                    stretch — значение по умолчанию; элемент занимает всё пространство по ширине.
                                    start — элемент сжимается до содержимого и прижимается к левой границе.
                                    end — элемент сжимается до содержимого и прижимается к правой границе.
                                    center — элемент сжимается до содержимого и располагается по центру. */
            flex-wrap: nowrap; /* запрещает перенос */ /* делает флекс элементы многострочными
                wrap; флекс-элементы начнут переноситься */
            grid-template-columns: 260px 165px 75px; /* сделать 3 грид колонки */
                grid-template-areas: "title1 title1 price1"; /* приравнять значения соответствующим классам */
                grid-template-areas: "title title price"       /* расположить в шаблоне класс=грид ячейка */
                                     "options disclaimer disclaimer";  /* два ряда по три колонки */
                grid-area: title1; /* внутри класса */
                align-self: center; /* выравнивание по вертикали одного элемента */ /* указывает расположение флекс элемента на поперечной оси
                                                stretch — значение по умолчанию; элементы начинаются у верхней границы и растягиваются на всю высоту.
                                                end — элементы выстраиваются по нижней границе;
                                                center — элементы располагаются по центру; */
                    justify-self: start; /* выравнивание отдельного элемента по горизонтали
                        stretch — значение по умолчанию; элемент занимает всё пространство по ширине.
                        start — элемент сжимается до содержимого и прижимается к левой границе.
                        end — элемент сжимается до содержимого и прижимается к правой границе.
                        center — элемент сжимается до содержимого и располагается по центру. */

    vertical-align: middle; /* описывает вертикальное выравнивание строчных (inline) (пример, текст), строчно-блочных (inline-block) элементов или ячеек таблицы (table-cell)
        Задаётся самому элементу (в отличии от text-align), а не содержанию (как в text-align)
        Помимо ключевых слов для vertical-align ещё есть возможность задавать значения в пикселях и процентах. Процентное значение (например, vertical-align: 100%) вычисляется относительно заданной высоты строки line-height. Значение 0% — это то же самое, что и baseline, а ещё оно может быть как положительным, так и отрицательным. Значение в пикселях (например, vertical-align: 10px) работает аналогично процентному, только отсчитывается в пикселях в большую или меньшую сторону. Значение 0px эквивалентно baseline. */

    display: none; /* скрыть элемент */
        visibility: hidden; /* Оно «прячет» элемент — он становится невидимым, но занимает место на странице. */

    float: right; /* прижать справа */
        float: left; /* аттрибут для картинки, если текст справа должен обвалакивать картинку слева */

    clear: both; /* запрещаем обтикание тега слева и справа*/

    overflow: hidden; /* hidden скрыть контент который выходит за рамки заданного размера */

/* Про гриды
.card {
  display: grid;
  grid-template-columns: 260px 165px 75px;
  grid-template-areas: "title1 title1 price1";
    grid-template-areas: "title title price"
                     "options disclaimer disclaimer";  два ряда по три колонки
}
.title {
  grid-area: title1;
}

.price {
  grid-area: price1;
}
}*/

img {
    font: normal 300% 'century gothic', arial, sans-serif; /* Список всех шрифтов https://www.cssfontstack.com/*/
    font-family: William, serif; /* Браузер проходит по списку слева направо и использует первый найденный в системе или на сайте шрифт.
    Одинарные названия можно оставлять как без кавычек, так и с ними для единообразия.
    serif — шрифт с засечками; sans-serif — шрифт без засечек; monospace — моноширинный шрифт; cursive — шрифт с неформальным начертанием, например, имитация рукописного текста или леттеринга; fantasy — декоративный шрифт, например, всемирно известный Comic Sans.*/
        font-family: 'Open Sans', 'Arial', sans-serif; /* свойство задаст всей странице шрифт Open Sans. Если такого шрифта нет на устройстве пользователя, браузер попробует использовать Arial. Если нет и Arial — браузер задействует системный шрифт без засечек.
        Если название шрифта состоит из нескольких слов, то его нужно заключать в кавычки. */
    font-weight: normal; /* «вес» шрифта, толщина (насыщенность) шрифта (отношение ширины штриха к высоте буквы)
        Более точная настройка осуществляется числами, вернее, сотнями в диапазоне от 100 (очень тонкое начертание) до 900 (ультра-массивное начертание).
        400 или normal — обычный шрифт, значение по умолчанию; 700 или bold — жирный шрифт. */
    /* 100: Thin; 200: Extra Light (Ultra Light); 300: Light; 400: Normal; 500: Medium; 600: Semi Bold (Demi Bold); 700: Bold; 800: Extra Bold (Ultra Bold); 900: Black (Heavy).
        А также, bolder и lighter. Эти значения делают шрифт жирнее и тоньше, чем текущее или унаследованное значение. */
    font-size: 31px; /* размер шрифта (высота символа шрифта.), пример, 100%, 0.8em */ /* Для блоков display: inline-block можно задать font-size: 0, чтобы не было отступов между блоками */
        font-size: 0.8em; /* ширина элемента в em зависит от размера шрифта родительского элемента. Величина 1em — это такой же размер шрифта, что и у родителя. Соответственно, если мы хотим, чтобы шрифт дочернего элемента был всегда в 2 раза больше родительского, то зададим значение 2em */
        font-size: xx-small; /* x-small, small, medium, large, x-large и xx-large. На практике этими единицами измерения пользуются редко. Подробно в https://www.w3.org/TR/css-fonts-3/#font-size-prop
        Существует пара «относительных» ключевых слов, которые применяются к размеру шрифта: larger и smaller. Они буквально делают размер шрифта элемента больше или меньше того размера, который задан его родительскому элементу. Подробнее в https://www.w3.org/TR/css-fonts-3/#relative-size-value */
    font-style: italic; /* стиль шрифта (начертание текста )
        normal — обычное начертание
        italic — курсивное начертание. Если задано значение italic, браузер будет пытаться найти в заданном шрифте отдельное курсивное начертание символов. В некоторых шрифтах отдельный курсив предусмотрен. Если отдельного курсивного начертания в шрифте не предусмотрено, то браузер сделает текст наклонным, то есть сымитирует курсив. Что равноценно заданию тексту значения font-style: oblique.
        oblique — наклонное начертание */

    font: 16px/26px "Arial", sans-serif; /* Про наследование
        font-size: 16px;                   было задано в font
        line-height: 26px;                 было задано в font. По умолчанию = normal
        font-family: "Arial", sans-serif;  было задано в font
        font-weight: normal;               не было задано в font
        font-style: normal;                не было задано в font
        font-variant: normal;              не было задано в font */

    text-decoration: underline; /* составное свойство стилизации текста (и тегов a).
        underline - подчеркнутый текст
        none - убирает подчёркивание
        line-through - перечеркнутый текст
        overline -  линия над текстом

        text-decoration — составное свойство, а это значит, что его можно разложить на следующие свойства:
            text-decoration-line — вид линии: underline, line-through, overline, none;
            text-decoration-style — стиль линии, может принимать значения:
                solid — сплошная линия;
                double — двойная линия;
                dotted — точечная линия;
                dashed — пунктирная линия;
                wavy — волнистая линия.
            text-decoration-color — цвет линии. */

    text-decoration: underline; /* для особого подчеркивания текста. Ни одно из свойств ниже не сработает, если мы не добавим в правило text-decoration: underline; */
        text-decoration-color: #dc5b34; /* цвет линии */
        text-decoration-thickness: 1px; /* толщина линии */
        text-underline-offset: 2px; /* расстояние между текстом и линией выделения. Но по умолчанию отступ отсчитывается от базовой линии текста, а Фигма показывает расстояние от нижней границы текстового блока.*/
        text-underline-position: under; /* положение подчёркивания на странице. В этом случае базовая «нулевая» позиция будет установлена не по базовой линии, а по нижней границе блока и мы получим точное совпадение*/

    text-transform: uppercase;  /* регистр символов. Все заглавные
        lowercase — все строчные;
        capitalize — каждое слово начинается с большой буквы;
        none — отменяет изменение регистра. */

    text-align: center; /* горизонтальное выравнивание всего текста внутри тега, но не самого тега. А также другие инлайновые элементы, то есть это изображения, инлайн-блоки, инлайн-таблицы и другие
        justify -  по ширине блока, при этом слова в строке будут размещаться так, чтобы занять равномерно всё пространство строки (пробелы между словами в таком случае становятся неравномерными, так как браузер «растягивает» слова в строке).
        start - выравнивание к началу блока
        end - выравнивание к концу блока
        Эффект от значения start совпадает со значением left, а end делает то же самое, что и right */
    writing-mode: bt-lr; /* управления направлением текста. Подробнее в https://www.w3.org/TR/css-writing-modes-3/#propdef-writing-mode */

    line-height: 18px; /* интерлиньяж, высота строки, межстрочный интервал. По умолчанию = normal. Оно указывает браузеру, что межстрочный интервал нужно подобрать автоматически, исходя из размера шрифта. Спецификация рекомендует устанавливать его в пределах 100-120% от размера шрифта. */
    /*  font-size: 10px; (line-height вычисляется в зависимости от font-size)
        line-height: 150%;  вычисленное значение: 10px (font-size) * 150% = 15px
        line-height: 2;     вычисленное значение: 10px (font-size) * 2 = 20px    */

    letter-spacing: normal; /* интервал между символами */
        letter-spacing: 0.1em;

    white-space: nowrap; /* white-space - управлять пробелами и переносами
        nowrap — схлопывает лишние пробелы и отображает весь текст одной строкой без переносов;
        pre — сохраняет пробелы и переносы как в исходном коде аналогично тегу <pre>;
        pre-wrap — работает как значение pre, но добавляет автоматические переносы, если текст не помещается в контейнер;
        normal — режим по умолчанию: лишние пробелы и переносы строк схлопываются, текст переносится, пробелы в конце строк удаляются.
        break-spaces — поведение идентично pre-wrap, но при схлопывании пробелов остаются нетронутыми зарезервированные пробелы, такие как пробелы в конце строки;
        pre-line — как normal, лишние пробелы схлопываются, но строки переносятся на символе переноса строки, на <br> и по мере заполнения строки. */

    box-shadow: -2px 2px 5px #FD6969;
    /* сдвинута на 2px влево, на 2px вниз */
    /* радиус размытия — 5px */
    /* цвет красноватый, #FD6969 */
    /*
    горизонтальный сдвиг - (отрицательное значение помещает тень левее элемента, положительное — правее);
    вертикальный сдвиг - (отрицательное значение помещает тень выше элемента, положительное — ниже);
    радиус размытия - (чем значение больше, тем тень шире и бледней);
    цвет - (задаётся так же, как цвет текста или фона).*/

    text-shadow: initial; /* для текста*/
}
  
div {   
    color: rgb(255 255 255 / 0.3); /* цвет текста, 30% цвета и 70% прозрачности
        color: #ffffff = #fff = white = rgb(255, 255, 255). Все цвета https://www.w3.org/TR/css-color-3/#svg-color
        color: rgba(255, 255, 255, 0.9) белый цвет, непрозрачный на 90%. Последняя "а" - степень непрозрачности цвета (alpha). Значение может быть от 0 (полностью прозрачный) до 1 (полностью непрозрачный):
        */

    background: #ffffff url("bg-page.png") no-repeat top center; /* background: background-color, background-image, background-repeat, background-position, background-attachment
        либо значения по умолчанию: прозрачный, нет фото, повтор во все стороны,слева сверху, scroll */
        background-color: deepskyblue; /*(цвет фона)*/
            background-color: rgb(95 13 238 / 0.5);
        background-image: url(https://yastatic.net/s3/auth2/_/msoffice.d1ada09f.svg); /* фоновое (декоративное) изображение
            декоративное внедряем в стили, img - контентное изображение внедряем в разметку */
            background-image: url("../img/berries.png"); /* используется абсолютный  путь (в отличии от подключения в файле разметки). "../" выйти из папки на уровень выше */
        background-repeat: no-repeat; /* не повторять
            repeat — повторять во всех направлениях. Это значение по умолчанию.
            repeat-x — повторять только по горизонтали.
            repeat-y — повторять только по вертикали. */
        background-position: center; /* расположение фона. по центру по горизонтали и по вертикали
            background-position: x y;
                В качестве значения x можно использовать ключевые слова left, center, right, значения в процентах и в пикселях.
                В качестве значения y можно использовать ключевые слова top, center, bottom, значения в процентах и в пикселях.
            background-position: right bottom; (по горизонтали к правому краю, по вертикали — к нижнему)
            background-position: 150px -50px; (по горизонтали сдвиг на 150px вправо от левого верхнего угла блока, по вертикали — на 50px вверх) */
        background-attachment: scroll; /* управление фоном. фон прокручивается вместе с содержимым. Это значение по умолчанию.
        fixed — фон не прокручивается, зафиксирован на одном месте. */
        background: /* множественные фоновые изображения */
                url("img1.png") no-repeat 0 0,
                url("img2.png") repeat-x 50% 50%,
                url("img3.png");

    background-size: cover; /*(размер фонового изображения - сожмёт или растянет картинку)*/
        background-size: contain; /*(сделает так, чтобы вся картинка уместилась)*/
        background-size: 220px 400px; /*(первое значение — ширина, второе — высота)*/
}

ul.menu li /* Такие селекторы называются вложенными или контекстными и читаются справа налево */
{
    list-style: none; /* убрать точки слева от списка (маркеры) */
    list-style-type: none; /* убрать точки слева от списка */
}

ul.menu li.selected a:hover /* тег.класс тег.класс тег */ /* :hover - псевдокласс, при наведении на ссылку, ссылка меняет цвет */
{
    color: #e4ec04;
}

a, img {
    /* Одно правило может относиться сразу к нескольким селекторам, в таком случае селекторы перечисляются через запятую */
}

.btn {
    cursor: pointer; /* стиль курсора при наведении */
}

/* CSS Mobile */ /* для мобильных устройств*/
@media only screen
and (min-device-width: 320px) /* для телефонов с таким мин размером экрана. Для примера взят iPhone5 */
and (max-device-width: 568px) /* для телефонов с таким макс размером экрана. У iPhone5 это высота, но видимо имеется ввиду альбомная ориентация */ {
    .header {
        /* тут можно задать стили для тегов только для экранов с размерами выше */
    }
}

/* pixel perfect Приём 1: Добавляем макет в разметку. Можно прямо в разметке разместить тег <img> с картинкой макета и добавить ему следующие стили. такие стили накладывают картинку поверх страницы, фиксируют её по центру экрана, делают полупрозрачной и меняют цвета, чтобы разница была визуально более заметной */
 .pixel-perfect-image {
     position: fixed;
     top: 50%;
     left: 50%;
     opacity: 0.5;
     filter: sepia(0.6);
     transform: translate(-50%, -50%);
}
/* pixel perfect Приём 2: Используем плагин PerfectPixel https://www.welldonecode.com/perfectpixel/  */

/*
Расчет специфичности
    Специфичность селектора разбивается на 4 группы — a, b, c, d:
        если стиль встроенный, то есть определён как style="...", то а=1, иначе a=0;
        значение b равно количеству идентификаторов (тех, которые начинаются с #) в селекторе;
        значение c равно количеству классов, псевдоклассов и селекторов атрибутов;
        значение d равно количеству селекторов по тегу и псевдо-элементов.

Цвета https://www.w3schools.com/html/html_colors.asp https://habr.com/ru/articles/189766/ */

/*
Разметка сетки:
    Разметка сетки списка блоков:
        cброс внешних отступов у <body>;
        установить ширину блока
        отцентрировать блок - margin: 0 auto;
        установить горизонтальные и вертикальные внутренние отступы - padding: 0 90px;
        установить нижний внешний отступ margin-bottom: 30px;
    Переходим к внутренним элементам:
        display: flex;
        установить ширины внутренних блоков
        установить горизонтальные отступы (справа)
        установить отступы во внутренних блоках
        обнулить верхний отступ у заголовков по умолчанию
            отступы у списков - margin: 0; padding: 0; list-style: none;
            отступы у картинок - margin-top: 0; margin-bottom: 0;
        сделать выравнивая

        внутри секции элементы сделать флексами
        выравниваем по горизонтали и вертикали
*/