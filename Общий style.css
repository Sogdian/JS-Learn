/*
PostCSS Sorting: Run форматирование Css свойств
В инструментах разработчика браузерные стили называются «Таблица стилей агента пользователя» или «User agent styles».

Наследование: наследование / не наследование свойств родителя
    Перекрёстное наследование: выносится общее отдельное правило CSS, и создаются доп. правила где меняется одно свойство

Каскадность: Этот механизм комбинирования стилей из разных источников в итоговый набор свойств и значений для каждого HTML-элемента.
    Каскад — это механизм работы браузера, по которому порядок следования правил в CSS имеет значение. Когда к одному элементу применяются два правила, используется то, которое идёт в CSS последним.
    Каскадность обозначает, что к одному и тому же элементу может применяться несколько CSS-правил.
    Среди этих свойств могут быть и конфликтующие между собой. Поэтому существуют инструкции, которые определяют, каким будет финальный набор свойств элемента.
    Каскадирование как раз и определяет, какие именно свойства из разных источников (CSS правил) применятся к данному элементу на странице.
    Конфликт стилей. Конфликт разрешается максимум за три шага:
        - важность. Сравниваются приоритеты стилевых файлов, авторские (наши) стили приоритетнее браузерных. У CSS-правил в style (в разметке) наивысший приоритет (так делать плохо)
            Однако существует способ переопределить из подключаемых CSS-файлов даже стили, заданные в атрибуте style. Для этого нужно использовать !important. Оно задаёт CSS-свойству усиленный приоритет. div { color: blue !important; }
        - специфичность. Чем меньшее количество элементов потенциально может выбрать селектор, тем он специфичнее. Например, селектор по классу более специфичен, чем селектор по тегу. Самый специфичный тег это #, т.е. атрибут id
            Расчет специфичности см. ниже
        - порядок исходного кода. Побеждает то свойство, которое находится ниже в коде.

Наследуемые свойства: font-size, font-family, font-style, font-weight, color, text-align, text-transform, text-indent, line-height, letter-spacing, word-spacing, white-space, direction и другие. Также  list-style, cursor, visibility, border-collapse и некоторые другие. https://www.w3.org/TR/CSS22/propidx.html (если есть Inherited?=yes)
    Но это не работает, если у браузеров есть стили по умолчанию. 
        Примеры: font-size, color для ссылок, font-weight для h1 от body не будет наследоваться заголовками. Это происходит из-за того, что размер шрифта заголовков явно задан внутри браузерных стилей по умолчанию (и наследуемое от body значение им не нужно).
Ненаследуемые свойства: background, border, padding, margin, width, height, position и другие. https://www.w3.org/TR/CSS22/propidx.html (если есть Inherited?=no). Не наследуются они из соображений здравого смысла. Например, если для какого-либо блока установлен внутренний отступ, автоматически выставлять такой же отступ каждому вложенному элементу нет никакой надобности. Эти параметры чаще всего уникальны для каждого отдельного блока.
    Флекс-элементы подчиняются только своему родителю. Настройки флекс-контейнеров более высокого уровня до них не доходят и не наследуются. Это важная особенность, о которой нужно помнить, когда управляете вложенными контейнерами.

Составные свойства
    где перечисляются сразу много значений (font: 16px/26px "Arial", sans-serif;)

Относительные и абсолютные размеры:
    width: 100%; % - относительный размер (em, rem, vh, vw, %), https://www.w3.org/TR/css3-values/#relative-lengths
    padding: 8px; - абсолютный размер, https://www.w3.org/TR/css3-values/#absolute-lengths

Селекторы
    Контекстные селекторы (селектор потомка) используются для вложенных друг в друга элементов. Селектор может состоять из нескольких частей, разделённых пробелом, пример,
        p strong { ... }
    Соседние селекторы (селектором смежных элементов) (которые расположены на одном уровне сразу друг за другом) используются для расположенных друг за другом элементов через "+", https://htmlacademy.ru/courses/42/run/6
        .fourth + li { background-color: red; }
    Дочерний селектор или селектор прямого потомка (первый прямой потомок)
        .places > li
    Селектор соседей, или селектор последующих элементов
        p ~ button - эти элементы не стоят рядом друг с другом, но являются прямыми потомками одного родителя.
    Селектор по атрибуту, https://doka.guide/css/attribute-selector/
        a[href]
    Частности:
        <span class="text green"></span>
        <p class="green text"></p>
        селектор .text.green - выбор элементов с двумя классами: text и green. CSS-селекторе классы могут идти в разном порядке — это не будет влиять на выборку элементов:

Псевдоклассы
    li:first-child (Подробнее https://htmlacademy.ru/demos/2#3)
    li:last-child
    li:nth-child(2) выберет второй элемент списка. Подробнее https://htmlacademy.ru/demos/2#1
        li:nth-child(2n) = li:nth-child(even) (выберет каждый второй элемент. Выражение :nth-child(2n) соответствует всем чётным элементам. Начинается n c 0)
    li:nth-child(odd) (для нечетных элементов)
    li:nth-child(3n-1) (для элементов: 2, 5. Начинается n c 0)
    li:nth-last-child
    ul:first-of-type выбирает первый дочерний элемент родителя, только с учетом типа, то есть тега, элементов. На случай если в родителе (body или main) есть другие теги не ul (div/selector)
        ul:first-of-type li выберет первый ul и все его li (с учетом типа ul)
        ul:last-of-type li выберет последний ul и все его li (с учетом типа ul)
        ul:nth-of-type(1) li выберет первый ul и все его li (с учетом типа ul)
        ul:nth-of-type(odd) Значение odd позволяет выбрать все нечётные элементы (указанного типа)
        ul:nth-of-type(even) значение even — все чётные элементы (указанного типа)
        ul:nth-of-type(n+1) все элементы кроме первого
        ul:nth-last-of-type li выбираются по их расположению, отсчет ведется от конца (с учетом типа ul)
    li:only-child Сработает, когда этот <li> в списке единственный, нужно прописать индивидуальные стили для элемента, который является единственным дочерним элементом внутри родительского контейнера.
        :only-child = elem:last-child:first-child
    p:only-of-type стили будут применены к элементу p, если это единственный p внутри своего родителя
    .container .card:first-of-type - первому элементу с классом card, вложенному в контейнер container, нужно задать отступ
    ul:has() можно добавить к селектору родителя и в скобках указать, какого ребёнка искать. Стили применятся к родителю у которого есть такой ребенок
        :has() сработает для любого уровня вложенности, .т.е. ребенок может быть не прямым наследником

    ul:empty выберутся все пустые элементы ul

    li:not(.class) выбирает все кроме элемента с классом .class
        li:not(:last-child) - выбирает все теги <li>, НЕ являющиеся последними в их родителе.
        li:not(:first-child):not(:last-child) - выберет все теги <li>, которые НЕ являются первыми и последними в их родителе. Объединять можно неограниченное количество селекторов.
        Сокращение: p:not(.text, .hint, .description) = p:not(.text):not(.hint):not(.description
        В комбинации с :not не применяются:
            :not(:not(...))
            объединение селекторов: например, li:not(.heart.jack) — некорректный селектор;
            псевдоэлементы: li:not(::after) — неправильная запись
            селекторы-потомки, групповые селекторы или комбинации: например, нельзя писать li:not(a span) или li:not(a + span).

    a:link - стилизует все ссылки, по которым ещё не переходили (только для ссылок). Равнозначен селектору a
        a:visited - отвечает за стили для ссылок, по которым уже переходили
            visited может задать только эти свойства: color, background-color, border-color, outline-color, column-rule-color, fill, stroke
        a:hover позволяет выбрать элемент, когда на него наведён курсор мыши и кнопка мыши не нажата
        a:active позволяет задать стили для элемента, с которым происходит взаимодействие прямо сейчас (кнопка мыши зажата на ссылке)
    Порядок применения псевдоклассов к a: link → visited → hover → active

    button:focus - состояние, когда элемент находится в фокусе. Состояние фокуса в устанавливается всем интерактивным элементам при клике по ним, не только при навигации по Tab
            В фокусе могут быть не только текстовые поля. Если вы переключаетесь между элементами веб-страницы с помощью клавиши tab, то в фокус будут попадать ссылки.
            Состояние задается через outline
        button:focus-visible - меняет стили элемента только при навигации с клавиатуры
            Если же элемент подразумевает использование клавиатуры (например, <input>), то неважно, что использовалось для навигации до него, :focus-visible применится в любом случае
        button:focus-within - задаёт стили не только для самого элемента в фокусе, но и для родительского контейнера, внутри которого есть элемент в фокусе
            элементы в фокусе не обязательно должны быть прямыми потомками элемента с :focus-within. Важно только, чтобы они были вложенными

Псевдоэлементы - Можно менять тип элемента, задавать ему позиционирование, отступы, фон и так далее.
    Псевдоэлементы нельзя задавать: <img>, <br>, <iframe>, <video>, <audio> и <option> и другим замещаемым элементам https://developer.mozilla.org/ru/docs/Web/CSS/Replaced_element#%D0%B7%D0%B0%D0%BC%D0%B5%D1%89%D0%B0%D0%B5%D0%BC%D1%8B%D0%B5_%D1%8D%D0%BB%D0%B5%D0%BC%D0%B5%D0%BD%D1%82%D1%8B
    ::before позволяет с помощью CSS добавить псевдотег внутрь другого элемента, Ведёт себя псевдотег так же, как обычный <span> с текстом
        Содержимое псевдотега задаётся с помощью свойства content. Достаточно даже пустой строки в значении свойства — content: "123\A456";.
    ::after добавляет псевдотег в конец элемента
    ::first-line задает стиль первой строки форматированного текста. В правилах стиля допустимо использовать только свойства, относящиеся к шрифту, изменению цвета текста и фона
    ::first-letter определяет стиль первого символа в тексте элемента, к которому добавляется. К этому псевдоэлементу могут применяться только стилевые свойства, связанные со свойствами шрифта, полями, отступами, границами, цветом и фоном.
    li::marker - сделать маркет (01. 02. 03.) для элементов списка
        можно стилизовать только: content; white-space; text-transform; letter-spacing; все свойства для работы с шрифтом (font-size, font-weight и другие); color.
    ::selection - меняет стили текста при выделении
        можно применить стили: color; background-color; text-decoration; text-shadow
    input::placeholder
    input:invalid стили если поле заполнено неправильно. Браузер назначает псевдоклассы valid и invalid не только самим элементам формы, с которыми взаимодействует пользователь, но и всей форме целиком
    input:valid стили если поле заполнено правильно
        form:valid Состояние valid видно всегда сразу, по умолчанию, до момента ввода любых данных в форму. Это не очень удобный механизм
    input:in-range помогают валидировать поля, в которых нужно указать числовое значение в каком-то диапазоне. При этом обязательно должны быть указаны значения для атрибутов min и max
        input:out-of-range

Как отцентровать элемент?
    Задать элементу ширину, которая меньше ширины родительского контейнера.
    Задать для внешних отступов справа и слева значение auto. (margin: 0 auto;)

Пути https://practicum.yandex.ru/trainer/frontend-developer/lesson/2cfbe34f-f21a-4382-8132-1eece9a279fd/
    ./ — выйдем в родительскую (ближайшую подпапку)
    ../ — выйдем из свой подпапки, где мы находимся на уровень выше
    / — сразу начинаем указывать путь от корневого (главного) каталога проекта
    ничего не прописывать — если нужен файл в этой же папке

Всякое
    Unicode символы https://copypastecharacter.com/
    Градиенты https://webgradients.com/
    Цвета https://www.w3schools.com/html/html_colors.asp https://habr.com/ru/articles/189766/

Cпецсимволы
    \A перенос текста
*/

@import url(main.css); /* import - название директивы, main.css - правила. Директивы - инструкции для CSS, которые меняют отображение или поведение элементов на странице.
    Ими можно подключать CSS-код и шрифты, создавать анимации. */

*, /* "*" - для всех элементов на странице*/
*::before,
*::after {
    box-sizing: content-box; /* По умолчанию. Границы и внутренний отступ расширяют элемент. Статья http://simonenko.su/32197993404/use-css3-box-sizing
    По умолчанию в боксовой модели ширина, которую вы задаёте элементу, применяется только для контента. Если у элемента есть внутренний отступ, то он добавится к ширине */
        box-sizing: border-box; /* границы и внутренние отступы отрисуются внутрь - ТАК ЛУЧШЕ   */
}

body, h1, p, img { /* Одно правило может относиться сразу к нескольким селекторам, в таком случае селекторы перечисляются через запятую */
    margin: 0
}

@font-face { /* подключение сторонних шрифтов.  */
    font-family: "Some Font Name";
    font-style: normal;
    font-weight: 400;
    src: url("../fonts/some-font.woff2") format("woff2");
    /* Обязательное свойство*/
    font-display: swap; /* сначала покажет альтернативный шрифт (например из body, который есть на компе), а когда загрузит нужный, заменит отображение текста (на шрифт из font-face, который должен был скачаться). Может возникнуть мигание, но текст будет виден почти сразу. */
        font-display: block; /* отрисует прозрачным альтернативным шрифтом текст, дождётся загрузки и перерисует видимым скачанным шрифтом весь текст */
}
@font-face {
    src:
    local('Best font ever'); /* браузер не будет скачивать файл со шрифтом из интернета, если на компьютере уже установлен шрифт с нужным именем. 'Best font ever' - название шрифта установденного на компе */
    url("../fonts/some-font.woff2") format('woff2'), /* шрифты работали во всех современных браузерах */
    url("../fonts/some-font.woff") format('woff'), /* шрифты работали во всех современных браузерах */
    url("../fonts/some-font.ttf") format('truetype'), /* можно сконвертировать в веб-формат в сервисе наподобие Font Squirrel (для кириллических шрифтов надо указать дополнительные параметры конвертации). */
    url("../fonts/some-font.eot") format('eot'),
}
/* Поддержку разных форматов браузерами можно уточнить на сайте CanIUse.com.
Проверить, скачивает ли браузер шрифт, можно в инструментах разработчика. В панели Network («Сеть») с выбранным фильтром Font («Шрифт»)
*/

input[type="text"] { /* Цвет вводимого в поле ввода текста не наследуется от родителя. Как и шрифт и другие текстовые стили */
    font-family: inherit; /* поэтому надо явно унаследовать */
    color: inherit;

    outline: 1px solid red; /* обводка, свойства границы, которые не влияет на ширину элемента
        outline: none - убирает подсветку границы инпута если поставить курсов в инпут
        при button:focus { outline: none; } - если установить фокус на кнопку, нажав на неё, обводки не будет. Но если использовать Tab, то обводка появится
        */

    outline-offset: 1px; /* Отодвигаем обводку элемента от его края. */

    caret-color: red; /* управлять цветом мигающего курсора в поле ввода */
    accent-color: #fff; /* можно задавать свой цвет для элементов формы */ /* Значение по умолчанию у этого свойства — auto. Браузер сам окрашивает элемент в зависимости от операционной системы и браузера. Значением может быть любое обозначение цвета. */
}

input:focus {
    outline-color: yellow;
        outline-color: -webkit-focus-ring-color; /* цвет обводки - стандартный от операционной системы */
    outline-style: solid;
    outline-width: 1px;
}

select {
    -webkit-appearance: none; /* Чтобы это значение работало во всех браузерах нам понадобятся вендорные префиксы */
    -moz-appearance: none;
    appearance: none; /* Сбрасывает стандартный внешний вид элементов, иначе элемент не примет нужную нам форму.
        Так в разных браузерах будут нужные вам стили*/
}

.header {
    min-width: 850px;  /* фиксированная верстка, не адаптивная*/
    width: 210px; /* width задаёт не общую ширину блока, а только ширину контента. Общая ширина блока затем складывается из трёх компонентов: ширины контента, внутренних отступов и ширины рамок слева и справа. */
        /* Фиксированное значение для элементов чревато некорректным отображением и усложнением кода. Особенно много неприятностей это добавит при создании верстки, адаптирующейся под различные экраны устройств. Фиксированные значение ширины приводят к тому, что вне зависимости от текстового содержимого и устройства просмотра - ширина будет равна только установленному в свойстве width значению. CSS предлагает более мягкое свойство - max-width. Чтобы не потерять отображение верстки при небольшом количестве текста внутри элемента - используйте связку max-width и width:100%. */
        width: 100%; /* блок занимает всю ширину родительского блока. Если блоку добавить внутренние отступы и рамки, то его общая ширина становится больше ширины родителя. 100% ширины тега равно 100% ширины окна просмотра (без отступов и рамок). */
        width: auto; /* Вернуть значения по умолчанию, т.е. ширину (высоту) как у родительского элемента. Если у блока есть внутренние отступы или рамки, то его ширина содержания автоматически уменьшается, а общая ширина остаётся равной ширине родителя. */
        width: 50vw; /* доли, в сравнении с окном просмотра*/ /* Вы можете встретить сайты, на которых секции точь-в-точь соответствуют размерам браузера. Точнее, окна браузера, в котором вы просматриваете сайт
            width: 50vw = высота станет равна половине высоты окна просмотра
            vw и vh не учитывают навигационные элементы страницы, поэтому
                при width: 100vw ширина (если мы про body) заедет на горизонтальный скрол, лучше написать width: 100% (для тега body), т.к. ширина будет до скрола (т.е. без скрола)
                    но по дефолту все html элементы растягиваются на width: 100%
                при height: 100vh высота (если мы про body) появится вертикальный скрол, лучше написать height: 100% (для тега html и также дублируем 100% для body), т.к. высота будет до скрола (т.е. без скрола)
                    width: 100% только для body (без прописывания в теге html) писать нельзя, т.к. значение высоты здесь не наследуется и нет величины, от которой высчитывать процент */
        width: unset; /* ширина не задана */
        width: fit-content; /* подогнать ширину контейнера под размер внутренних элементов */
    height: 50vh; /* доли, в сравнении с окном просмотра */
        /* Для правильного расположения элементов необходимо применять технологию выравнивания (высоту строки, отступы) и построения сетки (флекс/грид) */

    margin: 0 auto 20px; /* margin: auto - поместит тег по центру по горизонтали, но размер тега должен быть не равный всей ширине экрана (нужны размеры меньше) */
    margin-left: auto; /* отступ автоматически высчитывается браузером */
    margin: 100px auto 50px;
    margin-left: 50%; /* размер отступа вычисляется относительно ширины родительского элемента, а не размеров самого элемента */

    padding-top: 45px;
    padding-bottom: 56.25%; /* = соотношени 16:9 */ /* все значения padding в процентах вычисляются на основе ширины родителя */ /* https://practicum.yandex.ru/learn/frontend-developer/courses/738daf5a-b9fe-4bbe-800c-c43f30ebafd4/sprints/178889/topics/f5fbc35c-d86e-4e06-8f27-50f43c3b861b/lessons/7d0d2f41-e967-4f29-aee4-6deab5d8a969/ */
        /* Отступ между двумя соседними элементами равен максимальному отступу между ними. Этот эффект называется эффектом «схлопывания» внешних отступов.
            Во флексах и гридах схлопывание не работает
        «Выпадание» - если внутри родительского блока расположить блок и задать ему отступ, то внутренний блок прижмётся к краю родительского, а у родительского элемента появится отступ. То есть отступ внутреннего элемента «выпадает» из родительского элемента
        Если у родительского элемента тоже был задан внешний отступ, то выберется максимальный отступ между собственным и «выпавшим».
        Чтобы избавиться от эффекта выпадания, можно задать родительскому элементу: padding или border (или border-color: transparent???) или overflow:hidden */

        /* направление расстановки — по часовой стрелке, начиная сверху */
        /* 4 значения */
        /* для каждой стороны – своё значение */
        /*padding: 20px 15px 30px 15px;
        /* 3 значения */
        /* верх — 10px, по бокам — 20px, низ — 30px */
        /*padding: 10px 20px 30px;
        /* 2 значения */
        /* верх и низ — 10px, по бокам — 20px */
        /*padding: 10px 20px;
        /* 1 значение */
        /* 10px со всех сторон */
        /*padding: 10px; */
        /* между паддингами заголовков h1 и h2 есть дефолтный паддинг больше чем 4px */

    border: 3px solid #000; /* свойства границы */
        border-color: #000; /* цвет границы */
        border-width: 1px; /* толщина границы в px */
        border-style: solid; /* начертание границы */ /* https://practicum.yandex.ru/trainer/frontend-developer/lesson/c81e6879-f57a-4ce4-8d4c-fc980703825e/#:~:text=%D0%BE%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D1%8F%D1%8E%D1%82%20%D1%81%D0%B2%D0%BE%D0%B9%D1%81%D1%82%D0%B2%D0%B0%D0%BC%D0%B8%20%D0%B3%D1%80%D1%83%D0%BF%D0%BF%D1%8B-,border,-%3A */
    border-radius: 5px; /* скруглить углы у border*/
    border-top-left-radius: 5px; /* угол верхний левый */
    border-top: dashed; /* стороны границы
        border-bottom: dotted;
        border-left: solid;
        border-right: solid; */
    border-spacing: 5px; /* толщина границы */

    text-decoration: underline; /* сделать свою границу */ /* найти гдето в теории до https://up.htmlacademy.ru/fe-start/1/module/8/item/1/32*/
        text-decoration-thickness: 2px;
        text-underline-offset: 10px;
        text-underline-position: under;



    position: static; /* обычное позиционирование. Значение по умолчанию */
        /* top bottom left right - не влияют на сдвиг элемента*/
    position: relative; /* относительное позиционирование - элемент остаётся в потоке, но смещается относительно самого себя.
            Относительно спозиционированный элемент на самом деле никуда не смещается. Он остаётся в потоке ровно там же, где и был. А смещается иллюзорная копия блока. */
            top: -10px; /* позволяет сместить относительно спозиционированный элемент вверх или вниз относительно его исходного положения */ /* "-" смещает вверх, "+" вниз. top и left важнее, чем bottom и right . */
                bottom: -10px; /* "-" смещает вниз, "+" вверх */
                left: 10px; /* "-" смещает влево, "+" вправо */
                right: 10px; /* "-" смещает вправо, "+" влево */
                inset: 0; /* шорткат, работает также как и шорткат margin. одно значение установит одинаковое значение для  top, right, bottom и left */
            margin-bottom: 40px; /* если position: relative;, то маргины будут смещать от себя изначальное положение элемента */
    position: absolute; /* абсолютное позиционирование. Выпадают из потока документа. Место, которое они занимали, становится как бы пустым и его занимают соседние элементы.
            Элемент накладывается поверх спозиционированного родителя. Можно спозиционировать относительно любого первого родителя, который тоже спозиционирован (все кроме static)
                НО останется на месте если не заданы значения свойств top, left, right, bottom.
            Ширина по умолчанию зависит от содержимого (а не растягивается на всю доступную ширину).
            Cтрочному элементу можно задавать размеры с помощью width и height. */
        left: 10px; top: 10px; right: 10px; bottom: -10px;
            /* когда значение для left/top/right/bottom не задано, оно равно auto. top и left важнее, чем bottom и right . */
            left: auto; /* С помощью значения auto можно возвращать «абсолютные» элементы на исходное положение. */
        margin-left: 15px; /* Двигает элемент от левого края того места где раньше был элемент (до позиционирования) вправо. Неявная точка отсчета — это то место, где находился элемент до того, как ему задали абсолютное позиционирование. Можно сместить из неявной точки отсчета */
            /* Такой элемент можно сместить из неявной точки отсчета с помощью свойства margin. Оно будет работать примерно так же, как и свойства left … bottom для «относительного» элемента. */
        z-index: 100; /* чем больше z-index, тем выше располагается спозиционированный блок. z-index не действует на элемент со свойством position: static или если свойство position вообще не задано.
            Если элемент находится во flex- или grid-контейнере, то z-index сработает, даже когда позиция элемента — static
            Чтобы переместить блок назад, лучше сделать z-index: -1, а то, что выше z-index: 0; */
    position: fixed; /* задаёт элементу фиксированное позиционирование, т.е. неизменное положение */
        right: 0; left: 0; /* зафиксирует положение элемента по всей ширине */
    position: sticky; /* Элемент прилепляется пока не прокрутится весь родитель в окне просмотра браузера
        Нужно указать свойства top / bottom при вертикальном (обычном) скролле или left / right при горизонтальном скролле для того, чтобы браузер знал, где та точка, в которой надо «прилеплять» элемент */

    /* display по-английски «отображение»
    Браузерные стили по умолчанию - дефолтные стили, которые не задаются, но они есть:
        <ul/ol> есть маркеты, внутренние отступы!, внешние отступы!, padding-left!
        <h> margin-top / margin-bottom
        <p> padding-top/padding-bottom = 1em, margin
        <blockquote> - левй отступ
        <img> margin-top/margin-bottom. Можно просто сделать display: block, чтобы не было доп браузерных отступов как у строчных элементов (т.е. для контроля вертикальных размеров.)
    Браузеры по умолчанию добавляют абзацам (и другим блочным элементам, например, цитатам и спискам) верхнее и нижнее поля по 1em */

    display: block; /* сделает элемент блочным. Блочные элементы: div, h, ul/ol, section, p, nav, quote. Определяет поведение конкретного компонента
        Элементы занимают всю ширину родителя, если явно не задано другое. А вот высота элемента подстраивается под контент. */
        display: inline; /* сделает элемент строчным. Строчные элементы: img, а, span, em, b. Определяет поведение конкретного компонента
        Браузер игнорирует внешние отступы по вертикали у строчных боксов, а их внутренние отступы сверху и снизу не влияют на расположение других элементов и высоту строки.
            Им невозможно задать ширину или высоту — они игнорируют указание размеров через стили. Строчные боксы реагируют только на горизонтальные внешние и внутренние отступы. Воспринимают рамки. Аналогично padding рамки сверху и снизу не увеличивают занимаемое элементом место.
        Располагаются на «базовой линии» текста. Базовая линия расположена выше нижнего края элемента, чтобы уместить свисающие части знаков. Наличие этого расстояния можно увидеть, если установить нулевой отступ между элементами.
            Строчные элементы предназначены для использования в середине абзацев, а не как самостоятельная часть макета интерфейса. Например, может быть, мы захотим добавить маленький значок в середине предложения, и тогда строчный элемент будет аккуратно выровнен по базовой линии остального текста.*/
        display: inline-block; /* сделает элемент блочно-строчным. С одной стороны, они не занимают собой всю горизонталь, с другой, восприимчивы к указанию размеров через CSS. Определяет поведение конкретного компонента */
        /* inline-block присвоить каждым тегам которые должны быть на одной горизонтали. width равна ширине вложенного контента */
        display: table; /* задаёт боксу элемента тип таблица. */
        display: flex; /* Бокс с типом flex называют флекс-контейнером, дочерние — флекс-элементами. Флекс-элементы автоматически выстраиваются вдоль главной оси. Определяет поведение всех дочерних компонентов
            Внутри флекс-контейнера элементы по умолчанию растягиваются по поперечной оси (т.е. по высоте)
            margin: auto работает по горизонтали и вертикали, т.е. есть флекс родитель, внутри него дочка тоже флекс (с какимито элементами), у дочки прописываем margin: auto. Тут дочка выровнит сразу все свои внутренние элементы (а между собой элементы не будут выровнены (нужны доп поля))
                либо лучше сразу justify-content и align-items в родителе
                margin: auto есть смысл использовать когда (не флекс) элемента два, если будет 3ий, то лучше использовать justify-content и align-items в родителе
                https://practicum.yandex.ru/learn/frontend-developer/courses/5ecb339e-36b3-4099-b71d-796dc66d7f42/sprints/178884/topics/93deff6d-0e6c-4053-849e-8271950a0397/lessons/24f96822-5bdc-4049-bf5f-4c6b27cc9adb/
            Когда вы пишете display: flex, внутри контейнера появляются две оси — основная (слева направо) и поперечная (сверху вниз).
            И строчные, и блочно-строчные элементы ведут себя как слова в предложении. А между словами стоят пробелы, ширина которых зависит от размера шрифта. Поэтому чтобы убрать между блоками пробел (отступ) нужно font-size: 0
            Флекс-элементы подчиняются только своему родителю. Настройки флекс-контейнеров более высокого уровня до них не доходят и не наследуются. Это важная особенность, о которой нужно помнить, когда управляете вложенными контейнерами.
            Элементы настраивают свою ширину так, чтобы поместиться в контейнер. Флексбокс игнорирует указание ширины элементов. В этом случае можно сделать перенос на другую строку */
            justify-content: space-between; /* выравнивание по горизонтали */ /* Свойство работает на основной (главной) оси флекс-контейнера (в родителе).
                flex-start: сначала идут флекс-элементы, за ними — оставшееся пустое пространство (или start)
                flex-end: сначала идёт пустое пространство, а элементы прижаты к концу контейнера (или flex-end)
                center: флекс-элементы собраны посередине, а пустое пространство распределено поровну с двух сторон от них.
                space-between: первый элемент прижат к началу контейнера, последний — к концу, а остальные расставлены между ними с одинаковыми промежутками.
                space-around: всё пустое пространство делится на равные промежутки. Каждый флекс-элемент получает отступы по обе стороны, равные этому промежутку. Так между флекс-элементами оказывается отступ в два промежутка, а перед первым и после последнего элементов — в один промежуток.
                space-evenly: все отступы равной величины. И между элементами, и между границами контейнера и первым и последним элементами. */
            align-content: center; /* распределяет пространство между строками при переносе элементов (при flex-wrap: wrap). Свойство отвечает за то, как поведут себя элементы при переносе на новую строку или колонку при включённом flex-wrap и Высота флекс-контейнера больше, чем высота вложенных в него элементов
                = justify-content для поперечной оси если есть несколько строк
                stretch (значение по умолчанию) — строки растягиваются одинаково так, чтобы занять всё доступное пространство родителя.
                flex-start — все строки располагаются у начала родителя.
                flex-end — все строки располагаются у конца родителя.
                center — строки выравниваются по центру родителя.
                space-between — первая строка прижимается к началу, последняя — к концу родительского контейнера, а остальные располагаются так, чтобы свободное пространство разделилось между ними равномерно.
                space-around — отступы у каждой строки равнозначны отступам у любой другой строки.
                space-evenly — отступы между строками и от краёв родителя одинаковые. */
            place-content: center space-between; /* шорткат для align-content затем justify-content
                place-content: center; к обоим свойствам одно значение */
            align-items: start; /* выравнивание всех элементов на поперечной оси, т.е. по вертикали (если не было смены направления флекс контейнера)
                stretch: элементы растягиваются вдоль поперечной оси так, чтобы заполнить всего родителя (значение по умолчанию)
                flex-start: элементы прижимаются к началу поперечной оси
                flex-end: элементы прижимаются к концу поперечной оси.
                center: элементы выстраиваются по центру поперечной оси.
                baseline: элементы выравниваются по базовой линии текста. */
            place-items: end center;  /* Первое его значение — align-items, второе — justify-items. Если значения одинаковые для обеих осей, можно не писать его дважды: */
            align-self: center; /* выравнивание на поперечной оси конкретного флекс элемента, т.е. по вертикали (если не было смены направления флекс контейнера)
                stretch: элементы растягиваются вдоль поперечной оси так, чтобы заполнить всего родителя (значение по умолчанию)
                flex-start: элементы прижимаются к началу поперечной оси
                flex-end: элементы прижимаются к концу поперечной оси.
                center: элементы выстраиваются по центру поперечной оси.
                baseline: элементы выравниваются по базовой линии текста. */
            flex-direction: column; /* меняет напрвления флекс контейнера
                column - направление в колонку (сверху вниз). Главная ось теперь верху вниз, поперечная слева направо.
                    Если после смены направления главная ось направлена сверху вниз, то для выравнивания всех элементов по вертикали используют justify-content.
                column-reverse - направление в перевернутую колонку. Колонка прижата к низу
                row-reverse - ряд в обратном порядке, справа налево. Ряд прижат к правому краю
                row - обычный ряд, элементы следуют в потоке, слева направо. Это значение по умолчанию. */
            margin-left: auto; /* прижать к правому краю */
                margin-top: auto; /* прижать к нижнему краю */ /* margin-top: auto; + margin-bottom: auto; отцентрировать по середине*/
            gap: 5px 15px;
            flex-wrap: nowrap;
            order: 0; /* порядок элементов внутри флекс контейнера */ /* значение по умолчанию */
                order: -1; /* переместить выше */ /* Элементы выстраиваются от меньшего значения order к большему. Если у нескольких элементов одинаковое значение, используется их порядок в разметке. */
            max-width: 100%; /* задаёт максимальную ширину, а значение 100% говорит, что элемент не должен становиться больше ширины родителя. */ /* Этот способ работает, потому что у CSS-свойств max-width и height приоритет выше, чем у атрибутов width и height в разметке. */
                height: auto; /*  задаёт высоту элемента. Значение auto используют, чтобы изображение не деформировалось и сохраняло свои пропорции. */
            flex: 0 1 auto; /* flex-grow: 0; flex-shrink: 1; flex-basis: auto; */
                flex-grow: 1; /* свойство указывает, может ли вырастать флекс-элемент при наличии свободного места, и на сколько
                    При "1" вы отдали ему всё оставшееся свободное пространство main по высоте. В итоге футер оказался прижатым к низу страницы.
                    0 - расширяться нельзя (по умолчанию)
                    2 - элемент заберёт себе в два раза больше свободного пространства, чем элементы с flex-grow: 1 */
            flex-shrink: 1; /* сжатие элемента
                1 - все элементы сжимаются с одинаковой скоростью (по умолчанию)
                0 - элементы не сжимаются. Их размер не может стать меньше, чем тот, что задан с помощью flex-basis.  */
            flex-basis: 200px; /* свойство указывает размер элемента до того, как на него начнёт действовать расширение
                auto - элемент занимает столько пространства, сколько требуется для отображения его контента (по умолчанию)  */
        display: grid; /* грид-контейнер, дочерние - грид-элементы. По умолчанию грид-контейнер одноколоночный.
            По умолчанию распределение элементов происходит слева направо и сверху вниз. */
            grid-template-columns: 100px 150px 80px; /* 3 колонки */
                grid-template-columns: auto 80px; /* При значении auto размер грид-треков подстраивается под размер грид-элементов так, чтобы уместился самый большой из них. Другие элементы поделят между собой оставшееся пространство. */
                grid-template-columns: 1fr 200px; /* правая колонка 200px, а левая все оставшееся пространство */ /* отступы учитываются автоматически и вычитаются из конечной ширины столбца. Это поможет избежать случайного переполнения контейнера.  */
                grid-template-columns: 1fr 2fr; /* сокращённое от fraction — «доля»). Она означает долю доступного пространства в грид-контейнере. */
                grid-template-columns: repeat(2, 295px); /* 2 по 295px */
                    grid-template-columns: repeat(auto-fit, 100px); /* Значение auto-fit указывает, что колонок должно быть столько, сколько может поместиться в грид-контейнере. */
                    grid-template-columns: repeat(auto-fit, minmax(100px, 150px)); /* ширина колонок изменялась динамически и зависела от наличия свободного пространства. В скобках после minmax задают минимальный и максимальный размеры колонок
                        Код позволит колонкам изменять ширину в зависимости от имеющегося в контейнере свободного пространства. При этом колонки не станут меньше 100px и не растянутся больше, чем на 150px:*/
                        grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); /* fr позволяет колонкам увеличивать ширину до тех пор, пока свободного пространства в контейнере не хватит на ещё одну колонку. Т.е. делает так, чтобы можно было засунуть еще одну колонку с min шириной 140px*/
            grid-template-rows: 10px 10px; /* 2 строки */
                grid-template-rows: [aside-start] 300px [aside-end]; /* можно называть словами */
                    grid-row: aside-start / 4; /* задать элементу расположение, отсчитывая от линии с именем aside-start */
                    grid-template-rows: auto 100px; /* При значении auto размер грид-треков подстраивается под размер грид-элементов так, чтобы уместился самый большой из них. Другие элементы поделят между собой оставшееся пространство. */
            grid-template-areas: "title title price"       /* расположить в шаблоне класс=грид ячейка */ /* приравнять значения соответствующим классам */
                                 ". disclaimer disclaimer";  /* два ряда по три колонки, "." значит пусто */
                grid-area: title1; /* внутри класса */
            column-gap: 15px; /* отвечает за расстояние между колонками. У последней колонки не будет отступа справа, что очень необходимо */
            row-gap: 5px; /* за расстояние между рядами. У последнего ряда не будет отступа снизу, что очень необходимо */
                gap: 20px; /* Если же отступы одинаковы, удобно использовать составное свойство gap */
                gap: 5px 15px; /* строки, столбцы */ /* Все отступы фиксированные и не изменятся в результате сжатия или растяжения. */
            flex-wrap: nowrap; /* делает флекс элементы многострочными
                nowrap - запрещает перенос
                wrap - флекс-элементы начнут переноситься
                wrap-reverse - переносятся не последние, а первые элементы строки или колонки */
            grid-column-start: 1; /* для вертикальных грид-линий. Эти свойства применяются к грид-элементу. */ /* Можно накладывать элементы друг на друга задавая им пересекающиеся / одинаковые значения*/
                grid-column-end: 3; /* Размещение элемента на нескольких ячеек, от 1 до 3ьей, т.е. для 1 и 2 ячеек */
                grid-column-start: - 1; grid-column-end: -3; /* элемент растянется с конца на две колонки */
                grid-column: 1/3; /* сокращеннам запись начало и конец грид линии */
                grid-column: 1;  /* Если только одно значение, второе по умолчанию - auto и будет охватывать одну ячейку */
            grid-row-start: 1; /* для горизонтальных линий. Эти свойства применяются к грид-элементу. */
                grid-row-end: 3; /* Размещение элемента на нескольких ячеек, от 1 до 3ьей, т.е. для 1 и 2 ячеек */
                grid-column-start: - 1; grid-column-end: -3; /* элемент растянется с конца на две колонки */
                grid-row: 1/3; /* сокращеннам запись начало и конец грид линии. */
                grid-row: 1;  /* Если только одно значение, второе по умолчанию - auto и будет охватывать одну ячейку */
                grid-row: aside-start / 4; /* задать элементу расположение, отсчитывая от линии с именем aside-start */
            grid-column: span 3; /* растянет колонку на 3 колонки */
                grid-row: span 2; /* растянет ряд на 3 ряда */
                grid-auto-flow: row; /* row говорит располагать элементы в том порядке, в котором они идут в разметке, и при необходимости создавать новые ряды */ /* row - значение по умолчанию.
                    dense - контейнер будет заполняться так, чтобы не было пропусков. Лучший вариант. Значение dense заставляет грид-контейнер заполнять пустые ячейки первым подходящим по размеру грид-элементом */
            justify-content: space-between; /* выравнивание всей сетки по горизонтали */
            align-content: center; /* выравнивание всей сетки по вертикали */
            place-content: center space-between; /* шорткат для align-content затем justify-content
                place-content: center; к обоим свойствам одно значение */
            justify-items: center; /* выравнивание всех элементов по горизонтали внутри своих областей
                start — элементы выстраиваются по верхней границе и, если содержимого немного, не тянутся на всю высоту;
                stretch — значение по умолчанию; элементы начинаются у верхней границы и растягиваются на всю высоту.
                end — элементы выстраиваются по нижней границе;
                center — элементы располагаются по центру; */
            align-items: start; /* выравнивание всех элементов по вертикали внутри своих областей
                start — элементы выстраиваются по верхней границе и, если содержимого немного, не тянутся на всю высоту;
                stretch — значение по умолчанию; элементы начинаются у верхней границы и растягиваются на всю высоту.
                end — элементы выстраиваются по нижней границе;
                center — элементы располагаются по центру; */
            place-items: end center;  /* Первое его значение — align-items, второе — justify-items. Если значения одинаковые для обеих осей, можно не писать его дважды: */
            justify-self: start; /* выравнивание отдельного элемента по горизонтали внутри своей области
                stretch — значение по умолчанию; элемент занимает всё пространство по ширине.
                start — элемент сжимается до содержимого и прижимается к левой границе.
                end — элемент сжимается до содержимого и прижимается к правой границе.
                center — элемент сжимается до содержимого и располагается по центру. */
            align-self: center; /* выравнивание по вертикали отдельного элемента внутри своей области
                start — элементы выстраиваются у начала оси
                stretch — значение по умолчанию; элементы начинаются у верхней границы и растягиваются на всю высоту.
                end — элементы выстраиваются по нижней границе;
                center — элементы располагаются по центру; */
            z-index: -1; /* В контексте гибких раскладок работает свойство z-index, которое управляет близостью элемента. Чем больше значение, тем ближе элемент.  */

        display: inline-grid; /* грид-контейнер будет вести себя как строчный элемент и занимать только то пространство, которое необходимо, чтобы разместить грид-элементы
            В inline-grid контейнере элементы занимают лишь то пространство, которое необходимо для контента внутри */
        display: none; /* скрыть элемент */

    visibility: hidden; /* Оно «прячет» элемент — он становится невидимым, но занимает место на странице. свойство наследуется. элемент вроде здесь и соседние блоки его чувствуют, но его не видно. не даёт с ним взаимодействовать: навести, кликнуть, сфокусировать.*/

    .visually-hidden { /* альтернативный вариант скрыть элемент, но чтобы скринридер прочел элемент */ /* https://practicum.yandex.ru/learn/frontend-developer/courses/738daf5a-b9fe-4bbe-800c-c43f30ebafd4/sprints/178889/topics/e2822bf2-331d-4471-9e3a-23813a5fdb98/lessons/e40f211d-d60d-4748-8d85-b1dc62d38da3/ */
        position: absolute; /* элемент вырывают из потока */
        width: 1px; /* делают элемент очень маленьким, но таким, чтобы не пропал совсем */
        height: 1px;
        margin: -1px; /* элемент убирают из поля зрения, сдвинув на размер самого себя */
        padding: 0; /* обнуляют отступы, они есть у некоторых элементов по умолчанию */
        border: 0; /* убирают границу, она тоже может быть у каких-то элементов */
        clip-path: inset(50%); /* превращает элемент в невидимую глазу точку */
            clip: rect(0 0 0 0); /* это свойство обрезает видимую область до нулевого значения */ /* Оно уже устарело и нужно, только если вы поддерживаете старые браузеры. Если нет — его можно удалить. Вместо него теперь используется свойство clip-path */
        overflow: hidden; /* на всякий случай скрывают видимое за пределами блока */

    vertical-align: middle; /* описывает вертикальное выравнивание строчных (inline) (пример, текст), строчно-блочных (inline-block) элементов или ячеек таблицы (table-cell)
        Задаётся самому элементу (в отличии от text-align), а не содержанию (как в text-align)
        Помимо ключевых слов для vertical-align ещё есть возможность задавать значения в пикселях и процентах. Процентное значение (например, vertical-align: 100%) вычисляется относительно заданной высоты строки line-height. Значение 0% — это то же самое, что и baseline, а ещё оно может быть как положительным, так и отрицательным. Значение в пикселях (например, vertical-align: 10px) работает аналогично процентному, только отсчитывается в пикселях в большую или меньшую сторону. Значение 0px эквивалентно baseline. */

    float: right; /* прижать справа */
        float: left; /* аттрибут для картинки, если текст справа должен обвалакивать картинку слева */

    clear: both; /* запрещаем обтикание тега слева и справа*/

    overflow: hidden; /* Свойство overflow назначается родительскому элементу, в который не помещается содержимое.
        hidden - скрыть контент который выходит за рамки заданного размера
        scroll - убрать за скроллбар
        visible — значение по умолчанию, c переполнением; Но лучше auto
        auto — включает скролл, если переполнение случилось;
        clip — обрезает невместившийся контент и делает так, что блоку невозможно приделать скролл даже при программировании, значение запрещает блоку становиться «скроллящимся». Но лучше hidden */
            overflow-x: scroll; /* управление переполнением по разным осям */
            overflow-y: hidden;
                overflow: hidden scroll; /* для X и Y */
    text-overflow: ellipsis; /* свойство работает только в комбинации с white-space: nowrap и overflow: hidden;. Свойство применимо только к однострочным текстам, а также к блокам, значение свойства overflow которых установлено в auto, scroll или hidden.
        ellipsis - многоточие.
        clip — текст просто обрежется по краю, значение по умолчанию
        ellipsis — появится многоточие */
    word-wrap: break-word; /* переносы по символам
        normal — значение по умолчанию. При этом значении текст будет переноситься по пробелам, специальным символам и тегу <br>.
        break-word — слово переносится на любой букве при достижении края родительской области. */
    overflow-wrap: break-word; /* Говорим браузеру, как поступать со словами, которые не поместились в контейнер.
        normal — длинные слова или строки с неразрывным пробелом не переносятся, даже если выходят за границы родителя (значение по умолчанию).
        break-word — слово разбивается в любом месте, если не помещается в размеры, заданные родительскому элементу. Правила мягкого переноса не учитываются.
        anywhere — как и при значении break-word, слово разбивается в любом месте, но во внимание берутся правила мягкого переноса.    */

    }

.element::-webkit-scrollbar { /*Убрать скролл у элемента*/
    width: 0;
}

/* Про гриды
.card {
  display: grid;
  grid-template-columns: 260px 165px 75px;
  grid-template-areas: "title1 title1 price1";
    grid-template-areas: "title title price"
                     "options disclaimer disclaimer";  два ряда по три колонки
}
.title {
  grid-area: title1;
}
}*/

img {
    font: normal 300% 'century gothic', arial, sans-serif; /* Найти в https://fonts.google.comв "CSS rules to specify families" значение serif / sans-serif */
    font-family: William, serif; /* Браузер проходит по списку слева направо и использует первый найденный в системе или на сайте шрифт.
    serif — шрифт с засечками; sans-serif — шрифт без засечек; monospace — моноширинный шрифт; cursive — шрифт с неформальным начертанием, например, имитация рукописного текста или леттеринга;
    fantasy — декоративный шрифт, например, всемирно известный Comic Sans; system-ui - шрифт системы, установленный по умолчанию */
        font-family: 'Open Sans', 'Arial', sans-serif; /* свойство задаст всей странице шрифт Open Sans. Если такого шрифта нет на устройстве пользователя, браузер попробует использовать Arial. Если нет и Arial — браузер задействует системный шрифт без засечек.
        Если название шрифта состоит из нескольких слов, то его нужно заключать в кавычки. */
    font-weight: normal; /* «вес» шрифта, толщина (насыщенность) шрифта (отношение ширины штриха к высоте буквы)
        Более точная настройка осуществляется числами, вернее, сотнями в диапазоне от 100 (очень тонкое начертание) до 900 (ультра-массивное начертание).
        400 или normal — обычный шрифт, значение по умолчанию; 700 или bold — жирный шрифт. */
    /* 100: Thin; 200: Extra Light (Ultra Light); 300: Light; 400: Normal; 500: Medium; 600: Semi Bold (Demi Bold); 700: Bold; 800: Extra Bold (Ultra Bold); 900: Black (Heavy).
        А также, bolder и lighter. Эти значения делают шрифт жирнее и тоньше, чем текущее или унаследованное значение. */
    font-size: 31px; /* размер шрифта (высота символа шрифта.), пример, 100%, 0.8em */ /* Для блоков display: inline-block можно задать font-size: 0, чтобы не было отступов между блоками */
        font-size: 0.8em; /* ширина элемента в em зависит от размера шрифта родительского элемента. Величина 1em — это такой же размер шрифта, что и у родителя. Соответственно, если мы хотим, чтобы шрифт дочернего элемента был всегда в 2 раза больше родительского, то зададим значение 2em */
        font-size: xx-small; /* x-small, small, medium, large, x-large и xx-large. На практике этими единицами измерения пользуются редко. Подробно в https://www.w3.org/TR/css-fonts-3/#font-size-prop
        Существует пара «относительных» ключевых слов, которые применяются к размеру шрифта: larger и smaller. Они буквально делают размер шрифта элемента больше или меньше того размера, который задан его родительскому элементу. Подробнее в https://www.w3.org/TR/css-fonts-3/#relative-size-value */
    font-style: italic; /* стиль шрифта (начертание текста )
        normal — обычное начертание
        italic — курсивное начертание. Если задано значение italic, браузер будет пытаться найти в заданном шрифте отдельное курсивное начертание символов. В некоторых шрифтах отдельный курсив предусмотрен. Если отдельного курсивного начертания в шрифте не предусмотрено, то браузер сделает текст наклонным, то есть сымитирует курсив. Что равноценно заданию тексту значения font-style: oblique.
        oblique — наклонное начертание */

    font: 16px/26px "Arial", sans-serif; /* Про наследование
        font-size: 16px;                   было задано в font
        line-height: 26px;                 было задано в font. По умолчанию = normal
        font-family: "Arial", sans-serif;  было задано в font
        font-weight: normal;               не было задано в font
        font-style: normal;                не было задано в font
        font-variant: normal;              не было задано в font */

    text-decoration: underline; /* составное свойство стилизации текста (и тегов a).
        underline - подчеркнутый текст
        none - убирает подчёркивание
        line-through - перечеркнутый текст
        overline -  линия над текстом

        text-decoration — составное свойство, а это значит, что его можно разложить на следующие свойства:
            text-decoration-line — вид линии: underline, line-through, overline, none;
            text-decoration-style — стиль линии, может принимать значения:
                solid — сплошная линия;
                double — двойная линия;
                dotted — точечная линия;
                dashed — пунктирная линия;
                wavy — волнистая линия.
            text-decoration-color — цвет линии. */

    text-decoration: underline; /* для особого подчеркивания текста. Ни одно из свойств ниже не сработает, если мы не добавим в правило text-decoration: underline; */
        text-decoration-color: #dc5b34; /* цвет линии */
        text-decoration-thickness: 1px; /* толщина линии */
        text-underline-offset: 2px; /* расстояние между текстом и линией выделения. Но по умолчанию отступ отсчитывается от базовой линии текста, а Фигма показывает расстояние от нижней границы текстового блока.*/
        text-underline-position: under; /* положение подчёркивания на странице. В этом случае базовая «нулевая» позиция будет установлена не по базовой линии, а по нижней границе блока и мы получим точное совпадение*/

    text-transform: uppercase;  /* регистр символов. Все заглавные
        lowercase — все строчные;
        capitalize — каждое слово начинается с большой буквы;
        none — отменяет изменение регистра. */

    text-align: center; /* горизонтальное выравнивание всего текста внутри тега, но не самого тега. А также другие инлайновые элементы, то есть это изображения, инлайн-блоки, инлайн-таблицы и другие
        justify -  по ширине блока, при этом слова в строке будут размещаться так, чтобы занять равномерно всё пространство строки (пробелы между словами в таком случае становятся неравномерными, так как браузер «растягивает» слова в строке).
        start - выравнивание к началу блока
        end - выравнивание к концу блока
        Эффект от значения start совпадает со значением left, а end делает то же самое, что и right */
    writing-mode: bt-lr; /* управления направлением текста. Подробнее в https://www.w3.org/TR/css-writing-modes-3/#propdef-writing-mode */

    line-height: 18px; /* интерлиньяж, высота строки, межстрочный интервал. По умолчанию = normal. Оно указывает браузеру, что межстрочный интервал нужно подобрать автоматически, исходя из размера шрифта. Спецификация рекомендует устанавливать его в пределах 100-120% от размера шрифта. */
        /* font-size: 10px; (line-height вычисляется в зависимости от font-size)
        line-height: 150%;  вычисленное значение: 10px (font-size) * 150% = 15px
        line-height: 2;     вычисленное значение: 10px (font-size) * 2 = 20px    
        line-height: 120% = 1.2 */

    letter-spacing: normal; /* интервал между символами */
        letter-spacing: 0.1em;

    text-indent: 24px; /* отступ для первой строки блока текста */

    column-count: 2; /* разбить текст на несколько колонок */
        column-width: 50px; /* минимальную желаемую ширину колонки */
        column-gap: 25px; /* промежуток между колонками. По умолчанию 1em */

    direction: ltr; /* направление слева направо и rtl (направление справа налево).
        unicode-bidi для задания браузера настроек направления текста :
            normal — браузер самостоятельно определяет, как ему следует отображать текст на основе используемых символов Unicode;
            embed — переопределяет направление текста, располагая его согласно свойству direction (применяется, когда в блоке текст на двух разнонаправленных языках);
            bidi-override — переопределяет порядок символов в тексте согласно значению direction. */

    white-space: nowrap; /* white-space - управлять пробелами и переносами
        nowrap — схлопывает лишние пробелы и отображает весь текст одной строкой без переносов;
        pre — сохраняет пробелы и переносы как в исходном коде аналогично тегу <pre>;
        pre-wrap — работает как значение pre, но добавляет автоматические переносы, если текст не помещается в контейнер;
        normal — режим по умолчанию: лишние пробелы и переносы строк схлопываются, текст переносится, пробелы в конце строк удаляются.
        break-spaces — поведение идентично pre-wrap, но при схлопывании пробелов остаются нетронутыми зарезервированные пробелы, такие как пробелы в конце строки;
        pre-line — как normal, лишние пробелы схлопываются, но строки переносятся на символе переноса строки, на <br> и по мере заполнения строки. */

    word-spacing: 15px; /* Интервал между словами */

    box-shadow: -2px 2px 5px #FD6969;
        /* сдвинута на 2px влево, на 2px вниз */
        /* радиус размытия — 5px */
        /* цвет красноватый, #FD6969 */
        /*
        горизонтальный сдвиг - (отрицательное значение помещает тень левее элемента, положительное — правее);
        вертикальный сдвиг - (отрицательное значение помещает тень выше элемента, положительное — ниже);
        радиус размытия - (чем значение больше, тем тень шире и бледней);
        цвет - (задаётся так же, как цвет текста или фона).*/

    text-shadow: initial; /* тень для текста*/
        text-shadow: 20px 30px 1px #111111; /*
            20px (px, em, pt) - смещение тени по горизонтали относительно текста. Положительное значение этого параметра сдвигает тень вправо, отрицательное — влево
            30px - смещение тени по вертикали. Положительное значение сдвигает тень вниз, отрицательное — вверх.
            1px - радиус размытия тени (необязателен), значение по умолчанию = 0 . Чем больше значение параметра, тем сильнее тень размывается и становится светлее
            #111111 - цвет тени (необязателен), значение по умолчанию = цвет текста, может быть полупрозрачным */
        text-shadow: /* первая тень в списке — самая верхняя, последняя в списке — самая нижняя */
            1px 1px 1px #111111,
            2px 2px 2px #222222;

    transform: rotate(-10deg); /* повернуть против часовой стрелки*/
}
  
div {   
    color: rgb(255 255 255 / 0.3); /* цвет текста, 30% цвета и 70% прозрачности
        color: #ffffff = #fff = white = rgb(255, 255, 255). Все цвета https://www.w3.org/TR/css-color-3/#svg-color
        color: rgba(255, 255, 255, 0.9) белый цвет, непрозрачный на 90%. Последняя "а" - степень непрозрачности цвета (alpha). Значение может быть от 0 (полностью прозрачный) до 1 (полностью непрозрачный):
        */

    background: #ffffff url("bg-page.png") no-repeat top center; /* background: background-color, background-image, background-repeat, background-position, background-attachment
        либо значения по умолчанию: прозрачный, нет фото, повтор во все стороны,слева сверху, scroll */
        background-color: deepskyblue; /*(цвет фона)*/
            background-color: rgb(95 13 238 / 0.5);
            background-color: transparent; /* сделать фон прозрачным */
        background-image: url(https://yastatic.net/s3/auth2/_/msoffice.d1ada09f.svg); /* фоновое (декоративное) изображение
            декоративное внедряем в стили, img - контентное изображение внедряем в разметку */
            background-image: url("../img/berries.png"); /* используется абсолютный  путь (в отличии от подключения в файле разметки). "../" выйти из папки на уровень выше */
            background: /* множественные фоновые изображения */
                    url("../images/Polygon 1.svg") no-repeat right / 120px 128px,
                    url("../images/Ellipse 2.svg") no-repeat left 100% / 120px 120px;
        background-repeat: no-repeat; /* не повторять
            repeat — повторять во всех направлениях. Это значение по умолчанию.
            repeat-x — повторять только по горизонтали.
            repeat-y — повторять только по вертикали. */
        background-position: center; /* расположение фона. по центру по горизонтали и по вертикали
            x y -
                В качестве значения x можно использовать ключевые слова left, center, right, значения в процентах и в пикселях.
                В качестве значения y можно использовать ключевые слова top, center, bottom, значения в процентах и в пикселях.
            right bottom - (по горизонтали к правому краю, по вертикали — к нижнему)
            150px -50px - (по горизонтали сдвиг на 150px вправо от левого верхнего угла блока, по вертикали — на 50px вверх) */
        background-attachment: scroll; /* управление фоном. фон прокручивается вместе с содержимым. Это значение по умолчанию.
        fixed — фон не прокручивается, зафиксирован на одном месте. */
    background-size: cover; /* фон будет = размеру фонового изображения, может обрезать картинку */
        background-size: contain; /* сделает так, чтобы вся картинка уместилась */
        background-size: 220px 400px; /*(первое значение — ширина, второе — высота)*/
}

video {
    object-fit: cover; /* управлять тем, как картинка <img> или видео <video> будет подстраиваться под заданные размеры
        cover - картинка без нарушения пропорций заполнит всю доступную область, обрезая всё ненужное
        fill — значение по умолчанию, картинка полностью вписывается в указанные размеры без соблюдения собственных пропорций. Часто это приводит к ощутимым деформациям.
        contain — картинка подстроится под заданные размеры так, чтобы поместиться внутри целиком без нарушения пропорций.
        none — картинка отображается без изменения пропорций или размеров.
        scale-down — браузер сравнивает размеры картинки со значением none и со значением contain и выбирает одно из этих значений, деформируя картинку соответствующим образом. Сложно объяснить, посмотрите демку 🥴 */

    object-position: center; /* помогает спозиционировать отрисовку картинки <img> или видео <video> внутри контейнера, если к нему применили свойство object-fit
        bottom, top, center, left или right */
}

table {
    border-collapse: collapse; /* схлопывает границы соседних ячеек таблицы */
}

ul.menu li { /* Такие селекторы называются вложенными или контекстными и читаются справа налево */
    list-style: none; /* убрать точки слева от списка (маркеры) */
    list-style-type: none; /* убрать точки слева от списка */
    list-style-type: "- " /* особый маркет */
}

.btn {
    cursor: pointer; /* стиль курсора при наведении */
}

#part-11 { /* селектор для id. Но лучше так не делать */
    color: #ff0000;
}

/* CSS Mobile */ /* для мобильных устройств*/
@media only screen
and (min-device-width: 320px) /* для телефонов с таким мин размером экрана. Для примера взят iPhone5 */
and (max-device-width: 568px) /* для телефонов с таким макс размером экрана. У iPhone5 это высота, но видимо имеется ввиду альбомная ориентация */ {
    .header {
        /* тут можно задать стили для тегов только для экранов с размерами выше */
    }
}

/* pixel perfect Приём 1: Добавляем макет в разметку. Можно прямо в разметке разместить тег <img> с картинкой макета и добавить ему следующие стили. такие стили накладывают картинку поверх страницы, фиксируют её по центру экрана, делают полупрозрачной и меняют цвета, чтобы разница была визуально более заметной */
 .pixel-perfect-image {
     position: fixed;
     top: 50%;
     left: 50%;
     opacity: 0.5; /* для двух соседних элементов (ссылка = рамка + текст) надо выделить оба элемента (рамку и текст) */
     filter: sepia(0.6);
     transform: translate(-50%, -50%);
}
/* pixel perfect Приём 2: Используем плагин PerfectPixel https://www.welldonecode.com/perfectpixel/  */

/*
Расчет специфичности
    Специфичность селектора разбивается на 4 группы — a, b, c, d:
        a - если стиль встроенный, то есть определён как style="...", то а=1, иначе a=0;
        b - количество идентификаторов (тех, которые начинаются с #) в селекторе;
        c - количество классов, псевдоклассов и селекторов атрибутов;
            Псевдоклассы :is(), :has() и :not() весят столько, сколько самый тяжёлый селектор внутри скобок.
        d - количество селекторов по тегу и псевдо-элементов.
    Оператор прямого потомка ">" и другие операторы, а также "*" не имеют веса и не участвуют в расчёте

/*
Базовые стили - параметров шрифта и цвета фона элементов.
Разметка сетки:
    Разметка сетки списка блоков:
        cброс внешних отступов у <body>;
        установить ширину блока
        отцентрировать блок - margin: 0 auto;
        установить горизонтальные и вертикальные внутренние отступы - padding: 0 90px;
        установить нижний внешний отступ margin-bottom: 30px;
    Переходим к внутренним элементам:
        display: flex;
        установить ширины внутренних блоков
        установить горизонтальные отступы (справа)
        установить отступы во внутренних блоках
        обнулить верхний отступ у заголовков по умолчанию
            отступы у списков - margin: 0; padding: 0; list-style: none;
            отступы у картинок - margin-top: 0; margin-bottom: 0;
        сделать выравнивая

        внутри секции элементы сделать флексами
        выравниваем по горизонтали и вертикали
*/

/* Наследование
Применять непосредственно к классу с соответствующим текстовым тегом, не в родителе:
    font-weight: 400;
    font-size: 16px;

   Можно в родителе:
    line-height: 1.2;
    color: #CCC;
*/

/* Фолбеки
div { — Вендорные префиксы. важно указывать сущности (свойства, селекторы, директивы и так далее) с вендорными префиксами выше, чем без префиксов.
    -webkit-user-select: none; — Safari, Chrome, Opera 15+ и другие браузеры на основе движка WebKit или Blink
    -moz-user-select: none; — Firefox и браузеры на движке Gecko.
    -ms-user-select: none; — Opera 12 и раньше, на движке Presto.
    user-select: none; — Internet Explorer и старый Microsoft Edge 12–18.
}

div {
    background-color: red; — указываем точно работающее правило
    background-color: color(display-p3 0.9176 0.2003 0.1386); — новое правило, которое может не работать
}

div { display: flex; }
@supports (display: grid) { — В фигурных скобках пишем CSS-правило, которое нужно будет применять в случае наличия поддержки
    div {
        display: grid;
    }
}
*/