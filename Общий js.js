/*Ванильный js ------------------------------
Типы данных:
  примитивы (элементарные типы), у которых есть только значение:
    number — числа: целые и с точкой
    string — строки
    boolean — логические, или булевы, значения: true — «истина» и false — «ложь»
    undefined — undefined; - Значение не определено
    массивы - для хранения однородных элементов, хранит последовательность значений, и порядок этих значений важен. сложные, или составные, типы данных
    функции -
    null - Значения нет
  объекты, имеющие свойства пары: «ключ + значение»:
    объекты - состоит из множества пар «ключ-значение», порядок этих пар не важен; сложные, или составные, типы данных
Составные типы содержат не одно, а несколько значений

Операция сложения — бинарная, так как в ней два операнда.
    Существуют и унарные операции, с одним операндом, и тернарные операции, с тремя операндами.
    Приоритет операторов https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Operator_Precedence

Конкатенацией - сложение строк (“catenate” — «связывать в одну цепь».)
Зарезервированные слова https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Lexical_grammar#%D0%9A%D0%BB%D1%8E%D1%87%D0%B5%D0%B2%D1%8B%D0%B5_%D1%81%D0%BB%D0%BE%D0%B2%D0%B0
*/

//Переменные
  let user = 'John', age = 25, message = 'Hello'; //в одной строке

console.log(21 + "2"); //"212"
  console.log(2 ** 3); // возведение в степень. выведет в консоль 8
  console.log((2 + 2) / 2);
  console.log(4 * 3 ** 2); // = 4 * 3 в степени 2
  console.log(document.querySelector('.page'));
  console.log('вино' + 'град'); //Конкатенация
  console.log('Время, мин: ' + 50); // = 'Время, мин: 50'. Плюс может быть знаком сложения или конкатенации, но так как один из операндов — строка, то сложение не подходит. Поэтому число 50 приводится к строке '50' и склеивается со строкой 'Время, мин: '.
  console.log('2' * 50); // = 100. Звёздочка — это знак умножения, со строками она не используется. Поэтому JavaScript пытается превратить строку '2' в число, и ему это удаётся. Затем числа 2 и 50 перемножаются, и получается 100.
  console.log("Республика Кот-д'Ивуар");
  console.log('Никогда не говори "никогда" — можешь ошибиться.');
  console.log(`Это - шаблонная строка,
  несколько строк`); //Шаблонные строки, ограничиваются с обеих сторон обратными кавычками ``
  console.log(`${2 + 5} раз отмерь - ${value} отрежь`); // "7 раз отмерь - 1 отрежь"
  let merry = true;
    console.log(!merry); // false

//Символы Symbol. Фактически их можно воспринимать как гарантированно уникальное значение, предоставляемое JavaScript.
  //Для его создания нужно явно обратиться к типу по имени Symbol и в качестве аргумента передать подпись
  let id = Symbol('id');
  console.log(id); //Выведет Symbol(id)

//Строки
  console.log('эспрессо'[0]); // "э". получить символ из строки по его индексу

//Числа
  //После объявления эти числа можно использовать в вычислениях наряду с десятичными, но при выводе они будут автоматически сконвертированы в десятичную систему
  let hex = 0xFF; //255
  let binary = 0b011110; //30
  let num = 1234; //это десятичное число

/* Мат операции
  Остаток от деления %
    1 % 3: 1. Поскольку 1 не делится на 3 нацело, остаток равен самому числу, то есть 1. Поэтому результат равен 1.
    2 % 5: 2. Поскольку 2 не делится на 5 нацело, остаток также равен самому числу, то есть 2. Поэтому результат равен 2.
    3 % 3: 0. В данном случае 3 делится на 3 нацело (1 раз), поэтому остаток равен 0. Поэтому результат равен 0. */

//Неявное преобразование типов
  //Приведение к строке
  console.log(100 + '500'); // "100500"
  console.log(1 + ''); // "1"
  console.log(undefined + ''); // "undefined"

  //Приведение к числу
  console.log(null >= 1); // false
  console.log('451' < 452); // true
  //Унарные операторы приводят нечисловые значения после «+, -, /, *» к численному типу. Так +'33' вернёт число 33, +'-77' вернет число -77.
  //Если операторы сложения и унарный плюс стоят рядом, они не помешают друг другу
  console.log(67 + +'33'); // 100
  console.log('3' - 1); // 2
  console.log('4' / 4); // 1
  console.log('2' * 2); // 4
  //Но сложения со строкой — будет воспринято как конкатенация
  console.log('4' + 4); // 44 - здесь выполнится конкатенация

  //Приведение к булевым значениям
  //В круглых скобках условия if любые данные всегда приводятся к логическому типу
  //Если элемента с классом username на странице нет, в переменную usernameElement запишется null.
  //В круглых скобках условной конструкции null приводится к логическому типу и становится false. Поэтому тело условия if выполнено не будет
  const usernameElement = document.querySelector('.username');
  if (usernameElement) {
    console.log('Привет, ' + usernameElement.textContent);  }

//Явное преобразование типов
  //Приведение к строке
  const numberToString = String(2); // "2"
  const nanToString = String(NaN); // "NaN"
  const undefinedToString = String(undefined); // "undefined"
  const nullToString = String(null); // "null"
  const booleanToString = String(true); // "true"
  num.toString(1); // Выведет строку: 1 (String)
  num.toString(16); //4d2 это уже шестнадцатеричное число
  num.toString(2); //10011010010 а вот так двоичное

  //Приведение к числу
  const stringToNumber = Number('2'); // 2
  const nullToNumber = Number(null); // 0
  const anotherStringToNumber = Number('счастье не за горами'); // NaN
  const undefinedToNumber = Number(undefined); // NaN
  num.parseInt('17');   // Вернёт 17.
  num.parseInt('10001', 2); // Вернёт 17. вторым аргументом в parseInt мы передаём именно систему исчисления, из которой мы преобразуем исходное число.
  num.parseInt('11', 16);   // Вернёт 17

  //Приведение к булевым значениям
  Boolean(2) // true
  Boolean(0) // false
  Boolean('') // false
  Boolean(NaN); Boolean(null); Boolean(undefined) // false
  Boolean('Непустая строка'); // true
  Boolean({}); // true
  Boolean([]); //true

//Определение типа данных. Оператор typeof
  typeof 10; // "number"
  typeof 'Hello World!'; // "string"
  typeof true; // "boolean"
  typeof undefined; // "undefined" - Значение не определено
  typeof (10 + 5) // "number". Скобки ставят, когда нужно определить тип целого выражения
  typeof NaN; // "number". "Not a Number" имеет тип данных "number"
  typeof null; // "object"
  typeof function () {} // "function". Хоть такого типа и нет.

  console.log(typeof(input.value));

//Date
  //Если параметры метода не указаны, то он использует настройки браузера для локализации даты.
  //getDay() - выяснить день недели для указанной даты в виде целого числа от 0 до 6.
    //У метода есть одна особенность началом недели он считает воскресенье, то есть число 0 соответствует воскресенью, 1 — это понедельник, 2 — вторник, 6 — суббота
  const date = new Date('2023-03-05');
  const options = { day: "numeric", month: "short" }; //вывести день числом, а месяц в сокращённом формате
    const options2 = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' }; //В консоли отобразится "воскресенье, 5 марта 2023 г."
    //Для форматирования даты на русском языке используется локаль «ru».
  new Date(date).toLocaleDateString('ru-RU', options); //date - объект класса Date

  const formatDate = (date) => new Date(date).toLocaleDateString("ru", {
    day: "numeric",
    month: "short",
  }); //Функция formatDate вернёт дату в виде 5 мар.
  const getWeekday = (date) => new Date(date).toLocaleDateString("ru", {
    weekday: "short"
  }); //Функция getWeekday вернёт дату в виде первых двух букв для недели — вс.

//Формат JSON, метод toJSON
  //JSON.stringify - для преобразования объектов в JSON
  let student = {
    name: 'John',
    age: 30,
    courses: ['html', 'css', 'js'],
  };
  let json = JSON.stringify(student);
  alert(json); //выведет объект в формате JSON

  //JSON поддерживает следующие типы данных
  alert( JSON.stringify(1) ) // 1. // число в JSON остаётся числом
  alert( JSON.stringify('test') ) // "test".   // строка в JSON по-прежнему остаётся строкой, но в двойных кавычках
  alert( JSON.stringify(true) ); // true
  alert( JSON.stringify([1, 2, 3]) ); // [1,2,3]

  //JSON.parse - для преобразования JSON обратно в объект


//Логические операторы
  //Оператор логическое НЕ (!)
  //Если поставить ! перед небулевым значением, движок JS сначала приведёт тип к булю, а затем изменит значение на противоположное
  !false; // true
  !'Непустая строка' // false
  !!true; // true

  //Оператор логическое ИЛИ (||)
  //true || true - возвращает true, если хотя бы один из операндов равен true.
  //оператор || не различает false, 0, пустую строку "" и null/undefined. Для него они все одинаковы, т.е. являются ложными значениями.
  let condition =  0 || NaN || 'строка' || false;  // Значение переменной condition: 'строка'

  //Оператор логическое И (&&)
  //true && true - возвращает значение true, если оба операнда равны true.
  //сокращенное вычисление логического выражения в реакте
  <div> { isFinished && <Modal /> } </div> //если isFinished = true, то вызовется <Modal />, Если же isFinished равно false, то выражение вернёт false и <Modal /> не вызовется
  //Если поставить && между правдивыми условиями, оператор вернёт последнее из них:
  console.log(2 * 2 === 4 && 5 < 6 && 'Каждый может стать'); // 'Каждый может стать'
  //Если среди условий есть ложные, && вернёт из них первое ложное:
  console.log(2 * 2 === 4 && undefined && 'Каждый может стать'); // undefined

  //Оператор строгого равенства, тут нет приведения типов (т.е. сравниваются типы (которые не меняются, не приводятся)). https://htmlacademy.ru/courses/209/run/5
  2 === 'a'; // Результат: false
  'a' !== 'a'; // Результат: false
  //оператор нестрогого равенства, тут есть приведение типов
  2 == 'a'; // Результат: true
  //оператор нестрогого неравенства
  'a' != 'a';

  //Приоритетность операторов https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence#table
  //сначала выполняется логическое НЕ, потом И, а затем — ИЛИ
  //Операции в скобках выполняются первыми
  const optimism = !'Жить' && !'Быть' || 'Жить и быть';
  //Сначала !'Жить' → false, потом !'Быть' → false, затем false && false → false и наконец false || 'Жить и быть' → 'Жить и быть'.
  console.log(optimism); // "Жить и быть". сначала выполняется !, потом &&, затем ||

  //Пример
    function checkTheCar (distance, ownersNumber, crushed) {
      if (distance <= 100000) { // проверяем пробег
        if (ownersNumber === 1) { // 1 владелец по ПТС?
          if (crushed === false) { // не битая?
            return true;
          }
          else return false;
        }
        else if (ownersNumber === 2) { // Владелец не 1? Тогда может 2?
          if (crushed === false) { // не битая?
            return true;;
          } else return false
        } else return false;
      } else return false;
    }

  //Сравнение чисел - сравнивает два объекта по полю economy.
  //Если значение поля economy у объекта a меньше, чем у объекта b, то функция возвращает отрицательное число (-1) и т.д.
  function compareTicketsByEconomyPrice(ticket1, ticket2) {
    if (ticket1.economy < ticket2.economy) {
      return -1;
    } else if (ticket1.economy > ticket2.economy) {
      return 1;
    } else {
      return 0;
    }
  }
  //Или тоже самое в более лаконичной форме:
    [...tickets].sort((a, b) => a.date > b.date ? 1 : -1); //Отсортируйте данные по возрастанию даты. Перед тем как сортировать данные, нужно создать их копию через [...tickets]

  //Сравнение строк - сравнение будет производиться в соответствии с лексикографическим порядком символов (сравниваются символьные коды)
  function compareStrings(a, b) {
    const stringA = a.toLowerCase();
    const stringB = b.toLowerCase();
    if (stringA < stringB) {
      return -1;
    }
    if (stringA > stringB) {
      return 1;
    }
    return 0;
  }
    //Прямое сравнение для строк, которые содержат символы кириллицы, может дать неправильный результат. Универсальный способ сравнения строк — метод localeCompare(). Метод localeCompare() сравнивает две строки в соответствии с локалью (языком), учитывая правила сортировки этого языка, и возвращает целое число, которое указывает, какая строка должна быть отсортирована перед другой строкой. Пример сортировки массива строк по алфавиту:
    const fruits = ['яблоко', 'банан', 'арбуз', 'груша'];
    fruits.sort((a, b) => a.localeCompare(b));
    console.log(fruits); // ["арбуз", "банан", "груша", "яблоко"]
    //Добавим строки со «сложными» символами в массив:
    const fruits = ['яблоко', 'банан', 'арбуз', 'груша', 'ёжик', 'йогурт'];
    fruits.sort((a, b) => a.localeCompare(b));
    console.log(fruits); // ['арбуз', 'банан', 'груша', 'ёжик', 'йогурт', 'яблоко']
    fruits.sort((a, b) => a > b ? 1 : -1);
    console.log(fruits); // ['арбуз', 'банан', 'груша', 'йогурт', 'яблоко', 'ёжик']

//Операторы нулевого слияния и присваивания: '??', '??='
  //Оператор нулевого слияния (??)
  //Результат выражения a ?? b будет следующим:
    //если a определено, то a (т.е. оператор ?? возвращает первый аргумент, если он не null/undefined)
    //если a не определено, то b (т.е. иначе второй)
    let res = a ?? b //= (a !== null && a !== undefined) ? a : b;

  let user;
  alert(user ?? "Аноним"); // Аноним (user не существует)
  let user = "Иван";
  alert(user ?? "Аноним"); // Иван (user существует)

  //Важное различие между ними заключается в том, что:
    // || возвращает первое истинное значение.
    // ?? возвращает первое определённое значение.
    let height = 0;
    alert(height || 100); // 100
    alert(height ?? 100); // 0

  //Оператор нулевого присваивания (??=)
  //проверить, равна ли переменная null или undefined, и если это так — присвоить этой переменной какое-либо другое значение
  x ??= y //Оператор ??= присвоит x значение y только в том случае, если x не определено (null/undefined).


//Условия if else
  //блоки if else нельзя использовать в JSX-выражениях в фигурных скобках.
  const a = 5, b = 10;
  let max;
  if (a > b) {
    max = a;
  } else {
    max = b;
  }

//Методы поиска в строке
  //Поиск по строке. Метод indexOf. Метод indexOf ищет символ в строке и возвращает его индекс
  //indexOf чувствителен к регистру
  'Яндекс.Практикум'.indexOf('Я'); // 0
  'эспрессо'.indexOf('c'); // 1. Если таких символов в строке несколько, метод вернёт индекс первого из них
  'эспрессо'.indexOf('к'); // -1. Если символа в строке нет, indexOf вернёт -1
  //indexOf может найти и комбинацию символов. При этом вернётся индекс первого символа из последовательности
  const blok = 'Ночь, улица, фонарь, аптека';
  blok.indexOf('фонарь'); // 13.

//Поиск в начале и конце строки. Методы startsWith и endsWith
  //Метод startsWith сравнивает начало строки с переданной ему подстрокой
  'Вендетта'.startsWith('В'); // true
  'Родина'.startsWith('Картинка в букваре'); // false

  //Метод endsWith делает всё то же самое, только с концом строки
  const theRealEnd = 'Это ещё не конец';
  theRealEnd.endsWith('конец'); // true

//Управление регистром. Методы toLowerCase и toUpperCase
  'Включите Caps Lock'.toLowerCase(); // "включите caps lock"
  'Выключите Caps Lock'.toUpperCase(); // "ВЫКЛЮЧИТЕ CAPS LOCK"

//Превращение строки в массив. Метод split
  //Метод split принимает на вход один аргумент — разделитель. Он показывает, где заканчивается один элемент массива и начинается следующий
  //метод String.split ожидает, что какой-то элемент должен быть и до, и после разделителя
  //Поэтому если ваша строка начинается с разделителя или заканчивается разделителем, в полученном массиве первым или последним элементом будет пустая строка
  'Пришёл. Увидел. Победил.'.split(' '); // ["Пришёл.", "Увидел.", "Победил."]
  'Пришёл. Увидел. Победил.'.split('. '); // ["Пришёл", "Увидел", "Победил."]

//Извлечение части строки. Метод slice
  //Метод slice возвращает часть строки. На вход он принимает два аргумента — с какого индекса начинать отсчёт и на каком закончить
  //Второй аргумент необязательный: если его не указать, slice() вернёт все символы от заданного в первом аргументе до конца строки
  'Не прислоняться'.slice(6, 10); // "слон"
  'Яндекс.Практикум'.slice(7); // "Практикум"

//Объект Math и его методы
  // округляет переданное число «вниз»
  Math.floor(9.99); // 9
  // округляет «вверх»
  Math.ceil(9.01); // 10
  // округляет до ближайшего целого
  Math.round(9.51); // 10
  // возвращает наибольшее из переданных чисел
  Math.max(1, 2, 3, 4, 5); // 5
  // возвращает наименьшее из переданных чисел
  Math.min(1, 2, 3, 4, 5); // 1
  // возвращает случайное число от 0 включительно до 1 не включительно
  Math.random(); // 0.31764219954126016

//Работа с дробной частью. Функция parseInt
  //Функция parseInt приводит переданный аргумент к целому числу.
  //Она читает аргумент слева направо, если встречает не цифру, останавливается и возвращает всё, что прочитала до этого
  //Если первый символ передаваемой строки не цифра, parseInt вернёт NaN:
  parseInt('37 лет, 8 месяцев и 10 дней'); //37
  parseInt('38 попугаев'); //38
  //Второй аргумент parseInt — система счисления, в которой число передаётся функции
  parseInt('100', 10); // 100. Чаще всего вам нужна десятичная система. Явно указывайте её, чтобы избежать неожиданных результатов.
  parseInt('100', 2); // 4 (100 в двоичной системе)

//Функция parseFloat
  //Функция parseFloat работает аналогично parseInt, только выделяет не целое число, а число с плавающей точкой
  parseFloat('36.6'); // 36.6
  parseFloat('36.6 нормальная температура человека '); // 36.6

//Проверка на принадлежность к целым числам. Метод Number.isInteger
  //Метод Number.isInteger принимает число как аргумент и проверяет, целое оно или дробное
  const eightAndAHalf = 8.5;
  Number.isInteger(eightAndAHalf); // false



//Массивы
  //в массиве можно хранить любые данные: строки, булевы значения, числа и даже другие массивы
  //если в массиве нет элемента под тем номером, под которым мы записываем, то этот элемент будет создан
  //Массив — это объект со специальными методами (например, push и map) и свойством length.
  //Числовые индексы — это ключи, а соответствующие им элементы — значения этих ключей
  //Поскольку массивы — это объекты, они передаются и сравниваются по ссылке.
  let phrases = []; //пустой массив
  let numbers = [1, 2, 3, 4, 5];
  numbers[numbers.length] = 7; //добавить новый элемент в конец массива
  console.log(numbers); //[ 1, 2, 3, 4, 5, 7 ]

  numbers.four = 4;
  console.log(numbers); // [ 1, 2, 3, 4, 5, 7, four: 4 ]

  //Проверка на массив Array.isArray
  const arr = [1, 2, 3];
  const obj = {};
  console.log(Array.isArray(arr)); // true
  console.log(Array.isArray(obj)); // false

  //Копирование массива
  const boringTale = [
    'У попа была собака, он её любил,'
  ];
  const boringTale2 = Object.assign([], boringTale); //в boringTale2 скопировалось boringTale
  //метод slice, не передавая тому никаких аргументов
  const boringTale2 = boringTale.slice();

  let aliExpress = [1, 2, 3].length //длина массиыв = 3 элемента

  let guest = "Jane";
  let admin = "Pete";
  [guest, admin] = [admin, guest]; //мы создаём временный массив из двух переменных и немедленно деструктурируем его в порядке замены
  alert(`${guest} ${admin}`); //Pete Jane

  const results = new Array(size); //size - размер массива. У этого массива задана длина, но он не будет заполнен элементами. Для элементов создаются «ячейки» — слоты
    const results = new Array(size).fill(value); //fill - для заполнения слотов пустого массива

  const count = 5;
    const results = Array.from({length: count}, (_,i) => i * 2); //Где size — это желаемый размер массива, i — значение, которое мы добавляем в массив.
      //Метод from создаёт массив из любого объекта, похожего на массив. Здесь мы создаём новый массив с помощью метода Array.from()
    console.log(results)

  const count = 5;
    const results = [...Array(count)].map((_, i) => i * 2); //Ещё один способ заполнить «разреженный» массив — создать его копию spread-оператором
    console.log(results)

  /*Шпаргалка по методам массивов
  1	concat()	Объединяет массивы и элементы
  2	push()	Добавляет элементы в конец массива
  3	pop()	Удаляет последний элемент массива и возвращает его значение
  4	unshift()	Добавляет элементы в начало массива
  5	shift()	Удаляет первый элемент массива и возвращает его значение
  6	slice()	Копирует часть массива и создаёт из неё новый массив
  7	splice()	Удаляет часть элементов, а на их место ставит новые
  8	forEach()	Перебирает элементы, выполняя для каждого какой-то код
  9	map()	Создаёт новый массив, получая каждый элемент из уже имеющегося массива
  10	filter()	Создаёт новый массив, выкидывая из исходного элементы по заданным правилам
  11	some()	Проверяет, есть ли в массиве хоть один элемент, соответствующий заданному правилу
  12	every()	Проверяет, все ли элементы массива соответствуют заданному правилу
  13	find()	Проверяет, есть ли в массиве определённый элемент
  14	reduce()	Сводит массив к какому-то одному значению
  15	sort()	Сортирует  */

  //Добавление элементов. Метод concat
  //Метод concat не меняет структуру начального массива, а возвращает новый
  const toDoList = ['Посадить', 'Построить'];
  const toDoListUpdated = toDoList.concat('Вырастить', 'Прибраться');
  console.log(toDoListUpdated);  //["Посадить", "Построить", "Вырастить", "Прибраться"];
  //Как аргумент можно передать и другой массив — его элементы будут скопированы и добавлены в новый массив
  const moscowAttractions = ['Кремль', 'Третьяковская галерея'];
  const spbAttractions = ['Эрмитаж', 'Мариинский театр'];
  const russiaAttractions = moscowAttractions.concat(spbAttractions);

  //Преобразование массива в строку. Метод join
  //с исходным массивом ничего не произошло
  //Если не передать join аргумент, элементы в строке будут перечислены через запятую
  const bremenMusicians = ['Кот', 'Пёс', 'Трубадур', 'Осёл', 'Петух'];
  console.log(`Представляем музыкантов: ${bremenMusicians.join(', ')}`); // "Представляем музыкантов: Кот, Пёс, Трубадур, Осёл, Петух"

  //Добавление элемента: метод push
  //Метод push добавляет переданные ему аргументы в конец массива
  const emeraldCityHeroes = ['Лев'];
  emeraldCityHeroes.push('Элли');
  console.log(emeraldCityHeroes); // ["Лев", "Элли"]

  //Удаление элемента: метод pop
  //Метод pop удаляет последний элемент массива. Если массив пуст, pop вернёт undefined
  const insects = ['Бабочка', 'Комар'];
  console.log(insects.pop()); // "Комар". Метод возвращает значение удалённого элемента
  console.log(insects); // ["Бабочка"]

  //Удаление первого элемента: метод shift
  const italyCities = ['Помпеи', 'Рим', 'Неаполь'];
  const volcanoEruption = italyCities.shift(); // метод shift() возвращает удалённый элемент
  console.log(volcanoEruption); // "Помпеи"

  //Добавление элемента в начало массива: метод unshift
  //Метод unshift добавляет элементы в начало массива. Их передают через запятую
  const queue = ['Рабочие'];
  queue.unshift('Пенсионеры');
  console.log(queue);  //["Пенсионеры", "Рабочие"]
  //Метод unshift изменит исходный массив и напишет, сколько элементов в новом массиве
  const queue = ["Пенсионеры", "Инвалиды", "Рабочие", "Школьники", "Студенты"];
  console.log(queue.length); // 5
  console.log(queue.unshift('Мне только спросить')); // 6

  //Получение части массива: метод slice. Исходный массив при этом не изменяется
  //Метод slice копирует часть массива и делает из неё новый массив. Он принимает на вход два аргумента:
    //индекс элемента, с которого нужно начать копирование (включительно);
    //индекс элемента, на котором нужно остановиться (не включительно)
  //Второй аргумент можно не указывать. Тогда скопированы будут все элементы до конца
  const months = ['Январь', 'Февраль', 'Март', 'Апрель', 'Май', 'Июнь', 'Июль', 'Август', 'Сентябрь', 'Октябрь', 'Ноябрь', 'Декабрь'];
  const spring = months.slice(2, 5); //начиная с индекса 2 ("Март") и до, но не включая индекс 5 ("Июнь")
  console.log(spring); // ["Март", "Апрель", "Май"]
  //Можно передавать как аргумент и отрицательные числа. Тогда индекс будет считаться с конца массива
  //начиная с четвёртого элемента с конца и до первого с конца (не включительно)
  const autumn = months.slice(-4, -1);
  console.log(autumn); // ["Сентябрь", "Октябрь", "Ноябрь"]
  //Можно вызывать slice вообще без аргументов. Получится новый массив, состоящий из всех элементов исходного
  const months2 = months.slice();
  console.log(months2); //['Январь', 'Февраль', 'Март', 'Апрель', 'Май', 'Июнь', 'Июль', 'Август', 'Сентябрь', 'Октябрь', 'Ноябрь', 'Декабрь'];

  //Замена части элементов массива: метод splice
  const week = ['Понедельник', 'Вторник', 'Среда', 'Четверг', 'Пятница', 'Суббота', 'Воскресенье'];
  const removedItems = week.splice(0, 5, 'Воскресенье', 'Суббота', 'Воскресенье', 'Суббота', 'Воскресенье'); // начиная с индекса 0 удалим пять элементов и вставим на их место другие пять
  console.log(removedItems); // ["Понедельник", "Вторник", "Среда", "Четверг", "Пятница"]
  console.log(week); // ["Воскресенье", "Суббота", "Воскресенье", "Суббота", "Воскресенье", "Суббота", "Воскресенье"]
  //Новые значения добавлять необязательно — можно удалить существующие
  week.splice(2, 1); // ["Среда"]
  console.log(week); //['Понедельник', 'Вторник', 'Четверг', 'Пятница', 'Суббота', 'Воскресенье'];
  //И наоборот. Можно ничего не удалять — только добавить новые элементы
  week.splice(2, 0, "Земля"); // []
  console.log(week); // ['Понедельник', 'Вторник', 'Земля', 'Среда', 'Четверг', 'Пятница', 'Суббота', 'Воскресенье'];

  //Array.from. создаёт массив из «массивоподобного» объекта
  const posts = content.querySelectorAll('.post');
  const postsArray = Array.from(posts); // такой вызов вернёт полноценный массив

  //Обход массива: метод forEach
  //В качестве аргумента forEach принимает функцию. Она будет вызвана на каждом элементе массива поочерёдно
  //Но с forEach нельзя использовать директивы continue и break
  //Метод forEach нужен, когда мы хотим просто пройтись по массиву и для каждого элемента что-то сделать
  const how = ['быстрее', 'выше', 'сильнее'];
  how.forEach(function (item) {
    console.log(item + '.'); // быстрее выше сильнее
  });
  //пример с NodeList
  const elements = document.querySelectorAll('.text');
  elements.forEach((item) => {
    item.classList.add('text_is-active');
  });
  //если ключами в объекте оказались строки, которые можно привести к числам, большинство JS-движков упорядочит их сразу у себя

  //Создание одного массива из другого: метод map
  //Метод map создаёт новый массив на основе существующего.
  //В качестве аргумента map, как и forEach, принимает функцию.
  //Эта функция должна вернуть значение, которое станет элементом нового массива
  //Метод map нужен, когда мы хотим создать новый массив из старого и преобразовать его элементы
  const firstArr = [0, 1, 2, 3, 4];
  const secondArr = firstArr.map(function (item) { // Берём каждый элемент массива
    return item * item; //функция должна вернуть значение, которое станет элементом нового массива (пример, возводим каждый элемент в квадрат)
  });
  console.log(secondArr); //[0, 1, 4, 9, 16]
  //Метод map нельзя применить к массивоподобным объектам, но можно создать новый (Array.from) и на нем сделать map
  const elements = document.querySelectorAll('.text');
  const elementsArr = Array.from(elements);
  const newArr = elementsArr.map((item) => {
    item.classList.add('text_is-active');
  });
  //пример 2
    const numbers = [1, 2, 3, 4, 5];
    const results = numbers.map(number => number * 2);
    console.log(results); // [2, 4, 6, 8, 10]
  //пример 3. вывод элементов массива (feature) в шаблоне { featuresList }
    const features = [
        '2 каюты',
        '4 спальных места',
    ];
    const featuresList = features.map((feature) => (
      <li>{feature}</li>
    ));
      <ul>{featuresList}</ul>

  //Поиск по строке. Метод includes. Метод используется для проверки наличия элемента в строке / массиве.
  //Если элемент найден, возвращает true, если нет — false
  //Пример 1 с массивом
    const fruits = ["apple", "banana", "orange", "mango"];
    console.log(fruits.includes("banana")); // true
    console.log(fruits.includes("kiwi")); // false
      //Эту же операцию можно записать методом indexOf, который вернёт индекс нужного элемента в массиве, и сравнить его с -1.
    //Пример 2 с массивом
      root.render(<App words={words} selectedItems={selectedItems}/>);
      const selectedItems = ['3', '4'];
      const words = [ { id: '1', word: 'Сasa' };
      function App({words = [], selectedItems = []}) {
          const cards = words.map((item) => (
            <Card isSelected={selectedItems.includes(item.id)} /> //https://up.htmlacademy.ru/fe-react/1/demos/10321#19
          ));
          return (
                <ul> {cards} </ul>
          );}
    //Пример со строкой
      'Гарри Поттер и узник Азкабана'.includes('Гарри Поттер'); // true

  //Отбор элементов массива: метод filter
  //Метод filter создаёт новый массив из элементов, для которых функция-фильтр вернула true. При этом исходный массив не меняется.
  //Колбэк метода filter — те же три параметра, что и у map и forEach. Текущий элемент, его индекс и исходный массив:
  const persons = [
    { name: 'Пётр', age: 16 },
    { name: 'Максим', age: 18 },
  ];
  const fullAgePersons = persons.filter(person => person.age >= 18); //На вход filter передадим другую функцию, которая возвращает true, если поле age больше либо равно 18.
  console.log(fullAgePersons); //[{ name: 'Максим', age: 18 }]

  const fruits = ['apple', 'banana', 'orange', 'grape'];
  const itemToRemove = 'orange';
  const filteredFruits = fruits.filter((item) => item !== itemToRemove); //filter можно использовать и для удаления элемента из массива
  console.log(filteredFruits); //['apple', 'banana', 'grape'];

  //find - используется для поиска первого элемента в массиве, который удовлетворяет заданному условию в виде колбэк-функции
    const numbers = [1, 2, 3, 4, 5, 6, 7];
    const result = numbers.find((item) => item > 3);
    console.log(result); // 4. Метод find находит первый элемент массива, удовлетворяющий условию, и возвращает его.
      // В нашем случае это элемент 4. Иначе вернет undefined
    //пример с объектами
      const persons = [
        { id: 1, name: 'Alice' },
        { id: 2, name: 'Bob' },
      ];
      const resultByName = persons.find((item) => item.name === 'Bob'); //Метод find можно использовать для поиска объекта в массиве по значению одного из его полей.
      console.log(resultByName); // { id: 2, name: 'Bob' }

  //Проверка элементов массива. Метод some
  //Метод some проверяет, есть ли в массиве хотя бы один элемент, который соответствует определённому правилу.
  //Колбэк с этим правилом проверяет каждый элемент и возвращает true или false
  //Колбэк метода some — те же три параметра, что и у map и forEach. Текущий элемент, его индекс и исходный массив:
  const oceanResidents = ['Флаундер', 'Немо', 'Губка Боб', 'Аквамен'];
  const nemo = oceanResidents.some(function (resident) {
    return resident === 'Немо';
  });
  console.log(nemo); // true

  //Поиск элемента в массиве. Метод find
  //find возвращает значение элемента, на котором он завершил проверку
  const birds = [
    'Ворона',
    'Чёрно-белая ворона',
    'Белая ворона',
    'Ворона обыкновенная'
  ];
  const crow = birds.find(function (bird) {
    return bird.includes('ворона');
  });
  console.log(crow); // "Чёрно-белая ворона"

  //Проверка элементов массива. Метод every
  //Метод every проверяет все элементы массива и возвращает true, только если все элементы прошли проверку.
  //Колбэк — единственный аргумент метода. Он содержит логику проверки каждого элемента и возвращает true или false
  const jokes = [
    'смешная шутка и доля правды',
    'не очень смешной анекдот + доля правды',
    'доля правды в дурацкой шутке, услышав которую, все улыбнулись из вежливости'
  ];
  const allJokesWithTruth = jokes.every(function (joke) {
    return joke.indexOf('доля правды') > -1;
  });
  console.log(allJokesWithTruth); // true

  //Сведение массива. Метод reduce
  //аргументы: промежуточное значение (На каждой итерации этот аргумент равен тому, что в прошлый раз вернул колбэк), текущий элемент, его индекс и исходный массив
  //На первой итерации значение previousValue — первый элемент массива, item — второй
  const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];
  const sum = arr.reduce(function (previousValue, item) {
    return previousValue + item; //означает: «прибавь текущий элемент массива к тому, что получилось на предыдущей итерации»
  });
  console.log(sum);
  //previousValue можно задать самостоятельно
  const winsAndLoses = [10, 20];
  const total = winsAndLoses.reduce(function (previousValue, item) {
    return previousValue + item;
  }, 100); // Начальное значение (100) передаём методу reduce как второй аргумент.
  console.log(total); // 130

  //Сортировка массива sort
  //Может вызываться без функции обратного вызова (колбэка)
  const myNumbers = [0, 3.14, 2.718, 13];
  myNumbers.sort(); //если не передавать ему аргументы, пытается сортировать элементы массива по возрастанию Unicode кодов.
  myNumbers; // [0, 13, 2.718, 3.14]
  //Вызов с аргументами (колбэком)
  //если вы хотите отсортировать массив по возрастанию, колбэк должен возвращать a - b, по убыванию — b - a.
  const myNumbers = [0, 3.14, 2.718, 13];
  myNumbers.sort(function (a, b) {
    return a - b; //отсортировать по возрастанию
    /* Если a меньше b, вернётся отрицательное число.
    Это значит, что a должно расположиться в итоговом массиве
    раньше, b — позже. Например:
      a = 0, b = 3.14
      a - b = -3.14
    Получили отрицательное число, значит a стоит раньше b */
  });
  console.log(myNumbers); // [0, 2.718, 3.14, 13] — так и есть
  //Сортиорвка строк
  const chessChampions = ['Вильгельм', 'Эммануил', 'Александр' ];
  chessChampions.sort(function (a, b) {
    a = a.toLowerCase();
    b = b.toLowerCase();
    if (a < b) return -1; // a расположится раньше b
    return 0;
  });
  console.log(chessChampions); //'Александр', 'Вильгельм', 'Эммануил'

  //findIndex() - нахождения индекса объекта в массиве, Этот метод работает аналогично indexOf
  //Если элемент в массиве найден, findIndex вернёт его индекс, в противном случае метод вернёт значение -1.

//Объекты. Объекты состоят из пар «ключ — значение». Пары «ключ — значение» часто называют полями.
  //Значение — это данные, которые мы хотим записать.
  //Значением может быть строка, число, булево значение, массив, другой объект - такую пару называют свойством
  //Значением может быть функция - такую пару называют методом
  //Ключ — это уникальное имя этого значения. По ключу мы можем обратиться к значению
  //Пары «ключ — значение» делятся на два типа: свойства и методы.
  let user = {};  // синтаксис "литерал объекта", let user = new Object(); // синтаксис "конструктор объекта"

  let user = {
      nickname: 'Мария',
      getGreeting: function() {
          return 'nickname';
      },
      getGreeting2: function() {
          return this.nickname; //вернуть значение ключа этого же объекта
      },
      "likes birds": true  //имя свойства из нескольких слов должно быть в кавычках. Обращение через [] скобки - user["likes birds"] = true;
  };
  console.log(user.nickname); //Мария
  console.log(user['nickname']); //Мария. Квадратные скобки также позволяют обратиться к свойству, имя которого может быть результатом выражения
  console.log(user.getGreeting()); //Мария
  console.log(user.getGreeting2()); //Мария

  //Операторы: delete, in
  let user = {
    nickname: 'Мария'
  };
  delete user.nickname; //удаление свойства
  console.log(user.nickname); //undefined
  console.log(user); //{}. удалится и сам ключ

  let admin = user; //копируется ссылка на user, но не сам объект

  //Запись новых свойств
  const obj = {
    one: 1,
  };
  obj.two = 2;
  console.log(obj.two); //2
  //Если при записи нового свойства мы передаём значение ключа, которое не является строкой, оно автоматически преобразуется в строку
  const obj = {};
  obj[1] = 'единица';
  obj[true] = 'истина';
  console.log(obj['1']); // "единица"
  console.log(obj['true']); // "истина"
  //при доступе к свойству в квадратных скобках указать значение, не являющееся строкой, оно преобразуется в строку
  console.log(obj[1]); // "единица"
  console.log(obj[true]); // "истина"

  //Запись (записать) в свойство - объект
  const phonebook = {
    'Тёма': {
      mobile: '+79995164420',
    }
  };
  function addPhoneNumber(name, numberType, number) {
    if (!phonebook[name]) { //если свойства нет
      phonebook[name] = {}; //записать в свойство пустой объект
    }
    phonebook: phonebook[name][numberType] = number; //в объект phonebook добавить объект Анастасия = { mobile: '+79111545616' }
  }
  addPhoneNumber('Анастасия', 'mobile', '+79111545616');

  //Записать в свойство объекта значение переменной или функцию
  function getCartoonName() {
    return 'Трое из Простоквашино';
  }
  const cartoon = {
    getCartoonName: getCartoonName //можно просто getCartoonName без дублирования
  };
  console.log(cartoon); //getCartoonName: f getCartoonName()

  //Сравнение объектов
  //Если в переменные записаны ссылки на объекты, движок проверяет, на один ли объект ведут ссылки.
  //Если на один — возвращает true, если на разные — false.
  const time = {};
  const money = time;
  console.log(time === money); // true. Ведь time и money — это две ссылки на один и тот же объект.

  //Объект, объявленный через const, может быть изменён. объявление const защищает от изменений только саму переменную obj, а не её содержимое
  const obj = {
    firstName: 'John',
    lastName: 'Doe',
    'как хочу, так и называю': true,
    '123anarchy!!!': true,
    one: 1, //one это переменная
    red: "#f00",
    'добро пожаловать': 'или посторонним вход воспрещён', //имя ключа неизвестно на момент написания кода
    birthday  : {
      month: 'февраль',
      day: 12
    }
  };
  const propertyName = 'firstName';
    console.log(obj[propertyName]); // Выведет 'John'
  obj['как хочу, так и называю']; // true
    obj['123anarchy!!!']; // true
  const key = 'one'; //one это переменная использованная потом
    console.log(obj[key]); // 1
  const key = prompt('red, green или blue?');
    console.log(obj[key]); // "#f00"
  const key = prompt('red, green или blue?');
    console.log(obj.key); //undefined. мы попытались обратиться к свойству 'key', которого в объекте нет.
  const part1 = 'добро'; //имя ключа неизвестно на момент написания кода
    const part2 = 'пожаловать';
    const key = `${part1} ${part2}`;
    console.log(obj[key]); // "или посторонним вход воспрещён"
  obj.birthday.month = 'февраль'; //эквивалентна birthday['anya']['month'].
    obj['birthday']['month'] = 'февраль';

  //задание динамических свойств объектов
  const propertyName = 'firstName';
  const obj = {
    [propertyName]: 'John',
    lastName: 'Doe',
  };
  console.log(obj.firstName); // Выведет 'John'

  //Квадратные скобки также позволяют обратиться к свойству, имя которого может быть результатом выражения
  let user = {
    name: "John",
  };
  let key = prompt("Что вы хотите узнать о пользователе?", "name");
  //доступ к свойству через переменную
  alert(user[key]); // John (если ввели "name"). Через alert( user.key ); //undefined

  //Вычисляемые свойства
  let fruit = prompt("Какой фрукт купить?", "apple");
  let bag = {
    [fruit]: 5, // имя свойства будет взято из переменной fruit
  };
  alert(bag.apple); // 5, если fruit="apple"

  //Свойство из переменной
  function makeUser(name, age) {
    return {
      name, // то же самое, что и name: name (параметр функции)
      age   // то же самое, что и age: age (параметр функции)
    };
  }

  //Проверка существования свойства, оператор «in»
  let user = { name: "John", age: 30 };
  alert("age" in user); // true, user.age существует
  alert("blabla" in user ); // false, user.blabla не существует

  if ('name' in user) {
    console.log(user.name); //John
  } else ('age' in user) {
    console.log(user.age); //30
  }

  //Цикл "for...in"
  let user = { name: "John", age: 30 };
  for (let key in user) {
    alert( key );  // ключи // name, age
    alert( user[key] ); // значения ключей // John, 30
  }

  //Object.keys
  let cat = { name: "Алан", surname: 'Кей' };
  Object.keys({ name: 'Алан', surname: 'Кей' }); // ["name", "surname"]
  Object.keys(cat).forEach(function (a) { //в "a" записываются ключи
    console.log(a); //руп трёшку пятёрку десятку сотку
  });

  //Object.values
  //Метод Object.values возвращает значения всех свойств и методов объекта
  const paulMcCartney = {
    yesterday: 'all my troubles seemed so far away'
  };
  console.log( Object.values(paulMcCartney) ); // ["all my troubles seemed so far away"]
  //Object.entries
  //Метод Object.entries возвращает все пары «ключ-значение».
  console.log( Object.entries(paulMcCartney) ); // [["yesterday", "all my troubles seemed so far away"]]

  //Копирование объекта Object.assign. Создать поверхностную копию объекта
  //Первый аргумент dest — целевой объект.
  //Остальные аргументы src1, ..., srcN являются исходными объектами
  Object.assign(dest, [src1, src2, src3...])

  let user = { name: "John" };
  let permissions1 = { canView: true };
  let permissions2 = { canEdit: true };
  Object.assign(user, permissions1, permissions2); // копируем все свойства (первой вложенности, родительской, основной) из permissions1 и permissions2 в user
    //теперь user = { name: "John", canView: true, canEdit: true }

  //использовать Object.assign для замены цикла for..in для простого клонирования
  let user = {
    name: "John",
    age: 30
  };
  let clone = Object.assign({}, user); //Он копирует все свойства user в пустой объект и возвращает его.
  //клонирование с использованием оператора расширения
  let clone = {...user};

  //Методы объекта
  //Функцию, которая является свойством объекта, называют методом этого объекта.
  let user = {
    name: "John"
  };
  user.sayHi = function() {
    alert("Привет!");
  };
  user.sayHi(); // Привет!
  //Сокращённая запись метода
  user = {
    sayHi: function() {
      alert("Привет");
    }
  };
  //или так
  user = {
    sayHi() { // то же самое, что и "sayHi: function(){...}"
      alert("Привет");
    }
  };

  //this в объектах
  let user = {
    name: "John",
    sayHi() {
      alert(this.name); // this = объект user, точнее ссылка на объект user
    }
  };
  user.sayHi(); // John

//Словари
  let users = {
      'favorite food': 'Сметана',
      fullname: 'Иванова'
  };
  console.log(users['favorite food']); //Сметана
  console.log(user['fullname']); //Иванова

//Тернарный оператор. тернарный оператор возвращает значение, а условная конструкция — нет
  //условие ? значение1 : значение2;
  const a = 5, b = 10;
  const max = (a > b) ? a : b;
  //пример 2
  const someStorage = localStorage.getItem(LocalStorageKeys.SidebarMenuItemActive);
  const someVariable = someStorage ? JSON.parse(someStorage) : true; //Если значение переменной someStorage истинно (не равно null, undefined, false, 0, '' или другим "ложным" значениям), то это выражение принимает значение true.
  //тернарный оператор в реакте
  <div>{ condition ? <Component1 /> : <Component2 />; }</div>

//циклы
  //for
    for (let i = 0; i <= 4; i = i + 1) {
        console.log(aliExpress[i]);
      continue; //Директива continue не прерывает весь цикл, а только пропускает текущую итерацию.
      break; //Директива break нужна, когда дальнейшее выполнение цикла бессмысленно или может привести к неправильным результатам
    }
  //for of
  //Метод обеспечивает удобный способ перебора значений, а не ключей или индексов
  //for...of не работает со свойствами объектов, так как они не являются итерируемыми.
  const arr = [1, 2, 3];
  for (let value of arr) {
    console.log(value); //1 2 3
  }
  //for in
  //for...in используется для перебора свойств объекта.
  //Он проходит по всем перечисляемым свойствам объекта и его прототипу.
  const obj = { a: 1, b: 2, c: 3 };
  for (let key in obj) {
    console.log(key, obj[key]); //a 1 b 2 c 3
  }

  //while
    let a = 1; let b = 0;
    while (a >= b) {
      console.log("do");
      a +=1;
    }

  //do while. тело цикла выполнится хотя бы один раз
  do {
    console.log("do");
  } while (a >= b);

  //Конструкция switch-case
    let day = 'Monday';
    switch (day) {
      case 'Monday':
        alert('Сегодня понедельник');
        break;
      case 'Tuesday':
        document.body.style.backgroundColor = 'blue';
        break;
      default:
        alert('Сегодня неизвестный день недели');
        break;
    }

  //пример 2. Можно сознательно пропустить break, чтобы прописать логику сразу нескольких случаев
  let catName;
  const cartoon = 'Зима в Простоквашино';
  switch (cartoon) {
    case 'Зима в Простоквашино':
    case 'Весна в Простоквашино':
      catName = 'Матроскин';
      break;
    case 'Лето кота Леопольда':
      catName = 'Леопольд';
  }
  console.log(catName); // "Матроскин"

//Функции. При объявлении функции описывают её параметры. При вызове — передают аргументы.
  //функции в JavaScript — это объекты с дополнительными методами. В них тоже можно добавлять свойства
  //Объявление функции Function Declaration
  //Объявленную функцию можно вызвать до объявления, функциональное выражение — нельзя
  function makeHelloWorld() { //makeHelloWorld - Объявление функции
    function helloWorld() { //helloWorld - Объявление функции
      return console.log("Hello world!");
    }
    return helloWorld; //тут мы не вызываем функцию
  }
  const helloWorld = makeHelloWorld(); //в helloWorld запишется ссылка на simpleFunction
  console.log(helloWorld); //[Function: helloWorld]
  helloWorld(); //"Hello world!"

  //Самовызываемая функция IIFE
  //Функция создаётся и сразу же вызывается
  (function helloWorld(name) {
    return console.log();
  })("Hello world!")

  //Функциональные выражения Function Expression
  //Объявленную функцию можно вызвать до объявления, функциональное выражение — нельзя
  let functionName = function (userName, bookName) { //Передавать аргументы надо в том же порядке, в котором объявлены параметры функции. Потому что порядок аргументов соответствует порядку параметров в функции. У нас параметры записаны в таком порядке: userName, bookName.
      console.log('Меня зовут ' + userName + '. Моя любимая книга: ' + bookName);
      let name = userName + bookName;
      return name;
  };
  function sayHello(name) {
      return 'Привет, ' + name;
  }

  //Стрелочные функции
  //В стрелочных функциях нельзя использовать this
  const consoleWombat = (wombat) => {
    console.log(wombat);
  };
  //Короткий return в стрелочных функциях
  const singleAnecdote = (anecdote) => {
    return `я знаю только один анекдот: ${anecdote}`;
  };
  const shorterSingleAnecdote = (anecdote) => `я знаю только один анекдот: ${anecdote}`; //можно без return и фигурных скобок
  //Если возвращаемое значение — объект, его нужно заключить в круглые скобки. Иначе то, что в фигурных скобках, движок воспримет как тело функции
  const colorHex = () => ({ white: '#FFF' }); //вот так правильно
  const colorHexWhite = () => { white: '#FFF' }; //вот так не правильно
  //Короткая запись параметров
  //Если у стрелочной функции один параметр, можно не заключать его в скобки:
  const boatArrival = survivor => {
    console.log(`до другого берега доберётся только ${survivor}`);
  };
  //Стрелочные функции как колбэки
  const array = [1, 2, 3, 4];
  array.forEach(() => {
    console.log('Кнопка нажата!');
  });
  //Если единственное, что делает колбэк — это возвращает значение (через return), то можно использовать короткий return
  const array = [1, 2, 3, 4];
  const newArray = array.map(elem => elem * 2);

  //Анонимные функции
    element.addEventListener('click', function () { //function (){...} - анонимная функция
      console.log('Клик');
    });

  //Функция-конструктор
  //Имя функции-конструктора должно начинаться с большой буквы
  //Функция-конструктор должна выполняться только с помощью оператора new
  function User(name) {
    this.name = name;
  }
  let user = new User("Jack");
  alert(user.name); // Jack

  //можно вызывать без скобок
  let user = new Users();
  let user = new Users;

  //Создание методов в конструкторе
  function User(name) {
    this.name = name;
    this.sayHi = function() {
      alert( "Меня зовут: " + this.name );
    };
  }
  let john = new User("John");
  john.sayHi(); // Меня зовут: John

  //return
  //return без значения просто говорит функции «хватит». Если передать такой функции пустую строку, она прекратит работу. Функция при этом вернёт специальное значение undefined
  function sayHello(name) {
    if (name === '') {
      return; // если имя — пустая строка, выйдем из функции
    }
    let greeting = 'Привет, ' + name;
    return greeting;
  }
  //Аргументы по умолчанию
  //Параметр по умолчанию может принимать любое значение: число, строку, объект, функцию
  function generateName(firstName, lastName, middleName = '') {
    return `${firstName} ${middleName} ${lastName}`;
  }
  //Значением одного параметра функции даже может быть другой её параметр:
  function generateName(firstName, lastName = firstName) {
    return `${firstName} ${lastName}`;
  }
  //spread в функциях
  //При вызове функции — разбивает массив
  const nums = [4, 8, 15, 16, 23, 42];
  Math.max(...nums); // 42
  //rest в функциях
  //При объявлении функции — собирает аргументы в массив
  //rest-параметр всегда стоит в конце
  function consoleDogs(firstDog, ...otherDogs) {
    console.log(`Первый: ${firstDog}`);
    console.log(`Остальные: ${otherDogs}`);
  }
  consoleDogs('Спаниель', 'Овчарка', 'Борзая', 'Метис'); //"Первый: Спаниель" и "Остальные: ['Овчарка', 'Борзая', 'Метис']"
  //Старый код. Переменная arguments
  //В старом коде, до появления оператора spread, можно встретить другой способ работы с такими функциями — переменную arguments.
  function gimmeSomeArguments() {
    console.log(arguments);
  }
  gimmeSomeArguments(1, 2); // [1, 2]

  //prompt. позволяет получить ответ от пользователя.
  //Функция выводит диалоговое окно с текстовым полем. Если пользователь введёт что-то и нажмёт кнопку "ОК", в переменной password сохранится введённый текст.
  //Если пользователь не настроен на диалог и нажмёт «Отмена», в переменную попадёт null.
  password = prompt('Введите пароль:');

  //alert
  alert("Hello"); //Она показывает сообщение и ждёт, пока пользователь нажмёт кнопку «ОК».

  //confirm
  let res = confirm(question); //Функция confirm отображает модальное окно с текстом вопроса question и двумя кнопками: OK и Отмена

  //Присвоение функции свойства
  function multiply(a, b) {
    return a * b;
  }
  multiply.someValue = 4; //Если обратиться к свойству функции с ключом someValue, вернётся 4

  //Проверка на функцию
  function multiply(a, b) {
    return a * b;
  }
  console.log(typeof multiply); // "function"

  //Передача по ссылке
  function multiply(a, b) {
    return a * b;
  }
  let multiplyRef = multiply;
  console.log(multiply === multiplyRef); // true

  //Колбэк
  //Синхронные. каждый блок кода здесь выполняется за другим и последовательность заранее определена
  function handleError(tweet) {
    const newTweetContainer = document.createElement('div');
    newTweetContainer.textContent = tweet;
    document.body.append(newTweetContainer);
  }
  function insertTweet(tweet, containerSelector, callback) {
    const tweetContainer = document.querySelector(containerSelector);
    if (!tweetContainer) {
      callback(tweet);
      return;
    }
    tweetContainer.textContent = tweet;
  }
  insertTweet('Твит, адресованный Илону Маску', '.tweets', handleError);
  //Асинхронные
  function imageLoadCallback(evt) { // колбэк, который нужно выполнить после того как изображение загрузится
    document.body.append(evt.target);
  }
  function loadImage(imageUrl, loadCallback) {
    const img = document.createElement('img');
    img.src = imageUrl;
    img.onload = loadCallback;
  }
  loadImage('https://yastatic.net/q/logoaas/v1/Практикум.svg', imageLoadCallback); // Теперь картинка появится в разметке только после загрузки

//js функции
  Math.ceil(number); //принимает на вход число и округляет его до целого в большую сторону
  Math.floor(number) //делает то же самое, только округляет в меньшую сторону
  Math.round(number) //округляет число до ближайшего целого значения
  Math.random() ;//Она возвращает случайное число между 0 и 0.99999999999, включая 0:
  Math.max(a, b, c...); //Math.min(a, b, c...); - возвращает наибольшее или наименьшее число из перечисленных аргументов.
  Math.round(arg); //округляет аргумент до ближайшего целого.
  Math.ceil(arg); //округляет аргумент в большую сторону.
  throwDice(min, max); //генерирует случайные числа в заданном промежутке, включая минимальное и максимальное значение.
  Math.floor(Math.random() * array.length); //floor - Мы можем округлить наше число от 0 включительно до array.length в меньшую сторону, «отбрасывая» дробную часть случайного числа
  price.toLocaleString(); //1500 -> 1 500 //преобразует число в строку и возвращает значение, используя указанный языковой стандарт.
    //Если метод используется без параметров, то он использует язык по-умолчанию.
    //const formatPrice = (price) => `${price.toLocaleString()} ₽`; //1 500 ₽

  //У img есть свойства onload и onerror
  //onload сработает, когда изображение загружено,
  //onerror сработает если произошла ошибка

//Интерполяция шаблонной строки
  const formattedPrice = `Значение = ${price.toLocaleString()} ₽/час`; // = price.toLocaleString() + " ₽/час"
    const formattedPrice = `cards ${!isShownByGrid ? 'list' : ''}`; // "cards list" или "cards"
    className="{'button button-${firstSelectedOption}'}";

//Опциональная цепочка ?. (value?.prop)
  //(value?.prop) работает как value.prop, если значение value существует,
  //в противном случае (когда value равно undefined/null) он возвращает undefined
  let user = {}; // пользователь без адреса. Также ?. работает и при let user = null
  alert( user?.address?.street ); // undefined (без ошибки)
  //пример с document.querySelector
  let html = document.querySelector('.elem')?.innerHTML; //будет undefined, если элемента нет

  //Другие варианты применения: ?.(), ?.[]
  //?.() используется для вызова функции, которая может не существовать.
  let userAdmin = {
    admin() {
      alert("Я админ");
    }
  };
  let userGuest = {};
  userAdmin.admin?.(); // Я админ
  userGuest.admin?.(); // ничего не произойдет (такого метода нет)

  //?.[] синтаксис также работает, если мы хотим использовать скобки [] для доступа к свойствам вместо точки "."
  let user1 = {
    firstName: "John"
  };
  let user2 = null;
  alert( user1?.['firstName'] ); // John
  alert( user2?.['firstName'] ); // undefined

//Деструктуризация
  const x = 5;
      const obj = {x}; //или const obj = {x: x}; //создать объект со свойством x, равный значению этой переменной х = «возьми значение из переменной x и помести его в свойство объекта с таким же именем».
      const arr = [x]; //также для массивов
  //Деструктуризация массива
  let arr = ["Ilya", "Kantor"];
  let [firstName, surname] = arr; //firstName = arr[0] и surname = arr[1]
  alert(firstName); //Ilya
  alert(surname);  //Kantor
  //Пропускайте элементы, используя запятые
  let [firstName, , title] = ["Julius", "Caesar", "Consul", "of the Roman Republic"];
  alert( title ); //Consul, оставшиеся элементы массива также пропускаются (так как для них нет переменных).
  //Трюк обмена переменных
  let guest = "Jane";
  let admin = "Pete";
  [guest, admin] = [admin, guest]; //Здесь мы создаём временный массив из двух переменных и немедленно деструктурируем его в порядке замены

  //Spread (распыление)
  const arr1 = [1, 2, 3];
  const arr2 = [4, 5, 6];
  const combinedArray = [...arr1, ...arr2];
  console.log(combinedArray); // [1, 2, 3, 4, 5, 6]

  //Rest (остаток). Переменная rest является массивом из оставшихся элементов.
  const [first, second, ...restOfArray] = [1, 2, 3, 4, 5];
  console.log(first); // 1
  console.log(restOfArray); // [3, 4, 5]
  //Значения по умолчанию
  let [name = "Guest", surname = "Anonymous"] = ["Julius"];
  alert(name);    //Julius (из массива справа)
  alert(surname); //Anonymous (значение по умолчанию)
  //Rest (остаток) объекта
  let options = {
    title: "Menu",
    height: 200,
    width: 100
  };
  let {title, ...rest} = options;   // сейчас title="Menu", rest={height: 200, width: 100}
  alert(rest.height);  // 200
  alert(rest.width);   // 100

  //Деструктуризация объекта
  let options = {
    title: "Menu",
    width: 100,
    height: 200
  };
  let {title, width, height} = options; //Порядок слева не имеет значения, "let {height, width, title}" - так – тоже работает
  alert(title);  // Menu
  alert(width);  // 100
  alert(height); // 200
  //Если мы хотим присвоить свойство объекта переменной с другим названием, например, свойство options.width присвоить переменной w, то мы можем использовать двоеточие
  //Двоеточие показывает «что : куда идёт»
  let {width: w, height: h, title} = options;
  alert(title);  // Menu
  alert(w);      // 100
  alert(h);      // 200
  let {width = 100, height = 200, title} = options; //Для потенциально отсутствующих свойств мы можем установить значения по умолчанию
  let {width: w = 100, height: h = 200, title} = options; //Мы также можем совмещать : и =
  let { title } = options; //Если у нас есть большой объект с множеством свойств, можно взять только то, что нужно
  let {title, ...rest} = options; //пример с Rest

  //Вложенная деструктуризация
  let options = {
    size: {
      width: 100,
    },
    items: ["Cake", "Donut"],
  };
  let {
    size: { // положим size сюда
      width,
    },
    items: [item1, item2], // добавим элементы к items
  } = options;
  alert(width);  // 100
  alert(item1);  // Cake
  alert(item2);  // Donut

  //Умные параметры функций. Мы можем передать параметры как объект, и функция немедленно деструктурирует его в переменные
  let options = {
    title: "My menu",
    items: ["Item1", "Item2"]
  };
  function showMenu({title = "Untitled", items = []}) {
    alert( `${title}` ); //My Menu. title – взято из options
    alert( items ); //Item1, Item2. items – взято из options
  }
  showMenu(options);
  showMenu({}); //все значения будут по умолчанию.
  //Мы можем исправить это, сделав {} значением по умолчанию для всего объекта параметров
  //Весь объект аргументов по умолчанию равен {}, поэтому всегда есть что-то, что можно деструктурировать
  function showMenu({ title = "Menu", width = 100, height = 200 } = {}) {
    alert( `${title} ${width} ${height}` );
  }
  showMenu(); // Menu 100 200

//Таймеры setTimeout, setInterval
  //setTimeout - принимает: функцию колбэк, которую нужно запустить, время в миллисекундах, через которое эта функция должна быть вызвана, аргументы, которые нужно передать колбэку на вход.
  //для установки в таймер отложенного выполнения кода нужно передать функцию, а не вызывать её.
  function tellMeLater(name) {
    console.log(name);
  }
  setTimeout(tellMeLater, 1000, "Petr");
  //clearTimeout - отменяет таймер, созданный функцией setTimeout
  function logOut() {}
  let timer = setTimeout(logOut, 300000);   // через 300 секунд выкинем пользователя
  // если пользователь кликнул куда-то, сбросим таймер и будем ждать заново
  window.addEventListener('click', function () {
    clearTimeout(timer); //сбросим таймер
    timer = setTimeout(logOut, 300000); //будем ждать заново
  });
  //setInterval - устанавливает циклический таймер. Он позволяет вызывать колбэк много раз, через заданные промежутки времени
  setInterval(tellMeLater, 1000); //команда tellMeLater будет повторяться каждые 1000 миллисекунд
  //clearInterval - отменяет таймер, созданный функцией setInterval
  let interval = setInterval(checkEmail, 10000);
  window.addEventListener('blur', function () {   // Если пользователь переключил вкладку,
    clearInterval(interval); // удаляем таймер.
  })
  // Если пользователь вернулся на вкладку,
  window.addEventListener('focus', function() {
    interval = setInterval(checkEmail, 10000); // снова запускаем таймер.
  })

//Promise часть отдельного API, специально сделанного для работы с асинхронным кодом
  //Промисы позволяют добавлять задачи в асинхронную очередь.
  //Для этого нужно дописать в коде ещё один then или catch.
  //Первые then и catch на странице получат те значения, которые мы передавали на вход функциям resolve и reject.
  //Все последующие — то, что возвращали предыдущие методы then и catch.
  const newPromise = new Promise(function (resolve, reject) { //можно и без reject
    const rand = Math.random() > 0.5 ? true : false;
    if (rand) {
      resolve('Запрос обработан успешно'); //метод resolve вернет просто строку "Запрос обработан успешно"
    } else {
      reject('Запрос отклонён'); //метод reject вернет просто строку "Запрос отклонён"
    }
  });
  newPromise
    .then(function (value) { // Если промис был обработан. (Первые then и catch)
      /* Параметр value хранит значение, переданное методу resolve при создании промиса, то есть просто строку "Запрос обработан успешно" */
      console.log(value);
    })
    .catch(function (value) { // Если промис был отклонён. (Первые then и catch)
      /* Здесь параметр value будет хранить то значение, которое было передано методу reject, то есть просто строку "Запрос отклонён" */
      console.log(value + ', нам жаль :(');
    })
    .finally(function () { // В любом случае
      console.log('Как бы там ни было — запрос мы в глаза видели');
    });
  //Все последующие — то, что возвращали предыдущие методы then и catch.
  //then(thirdAction) = then(secondAction) = then(firstAction)
  newPromise.then(firstAction).then(secondAction).then(thirdAction);
  //Если вы сразу хотите создать исполненный или отклонённый промис
  Promise.resolve('Этот промис исполнен')
    .then(function (value) {
      console.log(value); // "Этот промис исполнен"
    });
  Promise.reject('Этот промис отклонён')
    .catch(function (value) {
      console.log(value); // "Этот промис отклонён"
    });
  //Promise.all
  //принимает на вход массив с промисами и выполняет записанный в then код, только когда все промисы вернулись со статусом «исполнен»
  const promises = [firstPromise, secondPromise] //Создаём массив с промисами
  Promise.all(promises) //Передаём массив с промисами методу Promise.all
    .then((results) => {
      console.log(results); // ["Первый промис", "Второй промис"]
    });

//Валидация ValidityState и слущатель input
  //свойство validity — объект из 11 свойств с булевыми значениями:
  //valueMissing — принимает true, когда обязательное поле пустое;
  //typeMismatch — принимает true, когда ввели неправильные значения данных для атрибута type. Это круто работает в связке с type="email" и type="url";
  //tooLong — всегда false, потому что в современных браузерах невозможно ввести больше символов, чем указано в maxlength;
  //tooShort — принимает true, когда количество символов не превышает значение атрибута minlength.
  //patternMismatch - отвечает за проверку ввода регулярным выражением. Если поле равно true, значит, введённый текст не прошёл проверку
  //valid - В нём находится итоговое решение проверки данных. Если во всех других 10 свойствах значения корректны, поле ввода валидно и свойство valid приобретает значение true
  const formElement = document.querySelector('.form');
  const formInput = formElement.querySelector('.form__input');
  formInput.addEventListener('input', function (evt) { // Слушатель события input - «Живая» проверка данных происходит одновременно с тем, как пользователь вводит в поле данные
    console.log(evt.target.validity.valid); //Выведем в консоль значение свойства validity.valid поля ввода,
    // на котором слушаем событие input
  });

  //Изменение сообщения об ошибке validationMessage
  //Свойство validationMessage есть у всех полей ввода. В нём записан стандартный текст сообщения об ошибке
  //Браузер показывает его по умолчанию, когда вводят некорректные данные
  const formElement = document.querySelector('.form');
  const formInput = formElement.querySelector('.form__input');
  const formError = formElement.querySelector(`.${formInput.id}-error`);
  const showInputError = (element, errorMessage) => { // Передадим текст ошибки вторым параметром
    element.classList.add('form__input_type_error'); //стили для класса невалидного input
    formError.textContent = errorMessage; // Заменим содержимое span с ошибкой на переданный параметр
    formError.classList.add('form__input-error_active');
  };
  const hideInputError = (element) => {
    element.classList.remove('form__input_type_error');
    formError.classList.remove('form__input-error_active');
    formError.textContent = ''; // Очистим ошибку
  };
  const isValid = () => {
    if (!formInput.validity.valid) {
      showInputError(formInput, formInput.validationMessage); // Передадим сообщение об ошибке вторым аргументом
    } else {
      hideInputError(formInput);
    }
  };
  formInput.addEventListener('input', isValid);

//Запросы
  //Метод fetch
  //Первый — обязательный — URL запрашиваемого ресурса
  //Второй аргумент — необязательный. Это объект options: method, headers и body — они отвечают за метод запроса, его заголовки и тело
  fetch('https://example.com')   //по умолчанию это GET
    .then((res) => { //в then пишем колбэк, т.е. функцию: () => {}
      console.log(res); // если всё хорошо, получили ответ
    })
    .catch((err) => { //в catch пишем колбэк
      console.log('Ошибка. Запрос не выполнен'); //либо console.error
    });

  //POST с options
  fetch('https://example.com/users', { //options {}
    method: 'POST',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      username: 'ivan'
    })
  });

  //Promise.all
  //Все запросы должны успешно выполнится
  const promiseA = fetch('https://example.com/users');
  const promiseB = fetch('https://example.com/users');
  Promise.all([promiseA, promiseB])
    .then(([resultA, resultB]) => console.log(resultA, resultB))
    .catch(console.error);

  //Как передать данные на сервер
    //1. В теле запроса
    //2. В параметрах запроса
    //Их перечисляют прямо в URL после вопросительного знака
    //Имя параметра и его значение указывают друг за другом через знак равенства: name=value. Такие пары имя атрибута=значение разделяют амперсандами &:
    fetch('https://example.com/images/random?type=portrait&name=DorianGrey', {
      method: 'GET'
    });
    //3. Прямо в URL
    //Например, если картинке присвоен идентификатор, можно запросить его в URL и получить картинку
    fetch('https://example.com/images/ewfh23d832jnf2903', { // ewfh23d832jnf2903 — идентификатор картинки
      method: 'GET'
    });

//Методы JSON.stringify
  //делает из объекта строку JSON
  const songs = [
    {
      title: 'Вектора',
      artist: 'OZORA'
    }
  ];
  const songsJSON = JSON.stringify(songs);
  console.log(songsJSON);
  console.log(typeof songsJSON); // "string"

  //Метод JSON.parse
  //Преобразовывает JSON-строку (Строка должна быть JSON-совместимой) в объект JavaScript
  const songs = [
    {
      title: 'Вектора',
      artist: 'OZORA'
    }
  ];
  const songsJSON = JSON.stringify(songs);
  const songsObject = JSON.parse(songsJSON);
  console.log(typeof songsObject); // "object"
  console.log(songsObject[0].title); // "Вектора"

  //Метод res.json — асинхронный метод.
  //Метод json читает ответ от сервера в формате json и возвращает промис
  fetch('https://praktikum.yandex.ru')
    .then((res) => {
      return res.json(); // возвращаем результат работы метода и идём в следующий then
    })
    .then((data) => {
      console.log(data); // если мы попали в этот then, data — это объект
    })
    .catch((err) => {
      console.log('Ошибка. Запрос не выполнен');
    });

  //Ответ на запрос
  //2 — значит, запрос прошёл успешно; 200 OK;
  // 3 — запрос был перенаправлен;
  // 4 — с запросом что-то не так: ресурс не найден или у вас нет к нему доступа; 401 Unauthorized; 403 Forbidden; 404 Not Found;
  // 5 — на сервере произошла какая-то ошибка. 500 Internal Server Error.

  //res.status - статус
  //res.statusText - сообщение статуса
  fetch('https://api.kanye.rest')
    .then(res => {
      console.log(res.status, res.statusText); // 200 OK
    });

  //res.ok
  //хранит в себе true, если ответ успешный (начинается с 2), и false — в любом другом случае
  fetch('https://api.kanye.rest')
    .then(res => {
      console.log(res.ok); // true
    });
  //пример 2
  const quoteElement = document.querySelector('div.quote');
  fetch('https://api.kanye.rest')
    .then((res) => {
      if (res.ok) {
        return res.json(); //или Promise.resolve()
      }
      return Promise.reject(`Что-то пошло не так: ${res.status}`); //отклоняем промис, чтобы перейти в блок catch, если сервер вернул ошибку
      //или Promise.reject()
    })
    .then((data) => {
      quoteElement.textContent = data.quote;
    })
    .catch((err) => {
      console.log(err); // "Что-то пошло не так: ..."
    });

  //Заголовки ответа, headers.get
  fetch('https://api.kanye.rest')
    .then((res) => {
      if (res.headers.get('Content-Type').contains('application/json')) {
        return res.json();
      }
    });

  //Тело ответа
  // res.json — разбирает JSON в объект, этот метод вы уже знаете;
  // res.text — разбирает тело как текст;
  // res.blob — разбирает тело ответа как бинарные данные: это нужно при получении файлов (изображений, видео, pdf-документов).
  fetch('https://api.kanye.rest')
    .then(res => res.text())
    .then((result) => {
      console.log(result);
    });





















//Регулярные выражения
  const userList = 'Маша, Петя, Катя, Лёша, Лера, Иннокентий, Влад';
  const innokentiy = /Иннокентий/g; // /.../ - литерал регулярного выражения
  userList.match(innokentiy);  //[ "Иннокентий" ]

  //Методы строк String.match
  //Нужен для поиска совпадений: им вы можете проверить, есть ли слово в тексте, и посчитать, сколько раз оно встречается
  //Если найти строку удалось, String.match вернёт массив с тем, что нашёл
  //Если символ найти не удалось, String.match вернёт null
  //Метод String.match можно настроить: например, заставить его считать все совпадения в тексте, а не только первое. Для такой настройки и нужны флаги
  const regex = /л/;
  const word = 'солнце';
  word.match(regex); // [ "л" ] — метод нашёл символ в строке
  //Если передать методу String.match регулярное выражение без флага g, полученному массиву будут определены дополнительные свойства
  const str = 'тро-ло-ло';
  const result = str.match(/ло/);
  result[0]; // "ло"
  result.index; // 4. индекс первого совпадения в строке
  result.input; // "тро-ло-ло". input содержит исходную строку

  //Методы регулярных выражений RegExp.test
  //Если совпадение найти удалось, RegExp.test вернёт true, иначе false
  const regex = /т/;
  const word = 'лестница';
  regex.test(word); // true — метод подтвердил, что в строке есть совпадение
  //Если установить флаг g, метод вернёт первое совпадение, а затем — запишет в свойство lastIndex регулярного выражения номер символа в тексте, на котором это совпадение произошло
  //Если запустить метод RegExp.test снова, он будет искать не с начала строки, а с того символа, на котором остановился в прошлый раз. То есть с записанного в свойство lastIndex:
  //RegExp.test обновляет свойство lastIndex после каждого вызова.
  const regex = /\w+@\w+\.\w+/g;
  const str = 'Stas Basov: stas-basov@yandex.ru, Telegramm: basov-stas';
  regex.test(str); // true
  regex.lastIndex; // 32 - номер символа, где было найдено совпадение
  // Вызовем метод RegExp.test ещё раз:
  regex.test(str); // false - поиск начался с 32 символа, поэтому совпадения найдены не были
  regex.lastIndex; // 0. предыдущий поиск не дал результатов, поэтому свойство lastIndex было сброшено до нуля

  //String.replace
  //Метод ищет в тексте совпадение с регуляркой, составляет какую-то новую строку из полученной и возвращает её нам
  const strObj = 'Пробел всегда нужно ставить после запятой ,а не до неё.';
  const regex = /\s,/g;
  strObj.replace(regex, ', '); // "Пробел всегда нужно ставить после запятой, а не до неё."

  //String.split
  const regex = /\n/im;
  `Мой дядя самых честных правил,
  И лучше выдумать не мог.`.split(regex);  //"Мой дядя самых честных правил,", "И лучше выдумать не мог."

  //Флаги
  //Флаг — символ, который стоит в регулярном выражении в самом конце (после слеша) и задаёт настройки поиска.
  //Всего их шесть: g, i, m, u, y, s.
  //В регулярном выражении флагов может быть несколько, и они могут идти в любом порядке.
    //Флаг g
    //Если установить флаг g, мы будем искать все совпадения, а не только первое
    const regex = /с/;
    const regexGlobal = /с/g;
    const word = 'искусство';
    word.match(regex); // [ "с" ]
    word.match(regexGlobal); // [ "с", "с", "с" ];

    //Флаг i
    //Если поставить флаг i, поиск не будет различать строчных и прописных букв
    const str = 'Вильгельм Конрад Рентген стал лауреатом Нобелевской премии в 1901 году.'
    const regex = /рентген/;
    const regexIgnore = /рентген/i;
    str.match(regex); // null
    str.match(regexIgnore); //[ "Рентген" ]

    //Флаг m
    //движок будет считать каждый перенос концом одной строки и началом другой
    const str = `Эта личность мне знакома! Знак допроса вместо тела.
    Многоточие шинели. Вместо мозга — запятая.`;
    const regex = /[А-Я]*\.$/gim;
    str.match(regex); // [ "тела.", "запятая." ]
    //Это работает и с шаблонными строками, и с обычными: в них движок будет считать началом и концом строки комбинации \n
    const regex = /^I got/gm;
    const str = 'I got, I got, I got, I got\n' +
      'I got power, poison, pain and joy\n' +
      'I got hustle, though, ambition, flow\n' +
    str.match(regex); // [ "I got", "I got", "I got" ]

  //Точка в выражении. В шаблоне регулярного выражения точка заменяет любой символ
  //Но у точки есть одна слабость: она не найдёт перенос строки.
  const str = `
    Не помню, как именно его зовут:
    то ли Сортини, то ли Сордини.
    Быть может, и Сардини, через «а».`;
  const regex = /С.р.ини/g; // Точки в регулярном выражении заменяют любой символ.
  str.match(regex); // [ "Сортини", "Сордини", "Сардини" ]

  //Спецсимволы https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/RegExp
  const str1 = 'yandex.ru/maps/';
  const regex1 = /\.ru/; // экранировали точку, движок будет искать только точки, а не любые символы
  const regex2 = /\/maps/; // экранировали слеш перед словом maps
  str1.match(regex1); // [ ".ru" ]
  str1.match(regex2); // [ "/maps" ]
  const str2 = 'C:\\'; // Чтобы найти обратный слеш, его тоже нужно экранировать
  const regex3 = /\\/; // экранировали слеш
  str2.match(regex3); // [ "\" ]

  //Спецсимвол \w
  //спецсимвол говорит движку искать любую цифру, латинскую букву или нижнее подчёркивание
  const str = 'Простите, я отправил старую версию файла диплом_финал_2_копия_3.docx. Не смотрите не неё. Высылаю вам актуальную диплом_финал_2_копия_4.docx';
  const regex = /диплом\wфинал\w\w\wкопия\w\w.docx/g;
  str.match(regex); // [ "диплом_финал_2_копия_3.docx", "диплом_финал_2_копия_4.docx" ]
  //Обратный класс: \W
  //\W - ищет всё что угодно: знаки вопроса, пробелы, слеши, кириллические символы, — но только не цифры, буквы базовой латиницы и нижние подчёркивания
  const str = `
    Даты основания некоторых IT-компаний:
    Yandex: 23.09.1997
    Apple: 01/04/1976
    IBM: 16-06-1911`;
  const regex = /\w\w\W\w\w\W\w\w\w\w/g; /* цифры в дате мы обозначили строчной \w, а разделители —
    заглавной \W. Разделитель это НЕ цифра, НЕ латинская буква и НЕ нижнее подчёркивание. */
  str.match(regex); // [ "23.09.1997", "01/04/1976", "16-06-1911" ]

  //Спецсимвол \d
  //Спецсимвол \d совпадает с любой цифрой
  const str = 'Владивосток 2000';
  const regex = /\d\d\d\d/g;
  str.match(regex); // [ "2000" ]
  //Обратный класс: \D
  //\D - ищет все не-цифры: буквы, пробелы, спецсимволы
  const someSimbol = /\D/g;
  const string = 'I was born in 1987';
  string.match(someSimbol);   // ["I", " ", "w", "a", "s", " ", "b", "o", "r", "n", " ", "i", "n", " "]

  //Спецсимвол \s
  //Спецсимвол \s ищет «пустоты» в тексте: пробелы, в том числе неразрывные, переносы строк и табуляции
  const str = 'Сдают паспорта,\n' +
    '              и я' +
    '                сдаю';
  const regex = /\s/g;
  str.match(regex).length; // 32 — Маяковский любил пробелы
  //Обратный класс: \S
  //ищет любые символы, только не пробелы, табуляции и переносы
  const str = 'Сдают паспорта,\n' +
    '              и я' +
    '                сдаю';
  const regex = /\S/g;
  str.match(regex).length; // 22 (буквы с запятыми)

  //Спецсимвол \b
  //Возвращаемся к спецсимволам. \b означает границу слова. Движок считает границей слова:
    // начало строки;
    // конец строки;
    // любой символ, кроме цифр, латинских букв и нижнего подчёркивания
  const string = 'sadness';
  string.match(/\bs/).index; // 0 — это первая буква s. спецсимвол указал границу левее неё, т. е. начало
  string.match(/s\b/).index; // 6 - а это последняя. спецсимвол указал границу правее неё, т. е. конец
  //Обратите внимание: любая нелатинская буква прочитывается движком как отдельное слово. Поэтому с кириллицей спецсимвол \b не работает.
  'A333HP99'.match(/\d\d\b/); //["99", index: 6, input: "A333HP99", groups: undefined]
  //Обратный класс: \S
  //ищет не конец слова: цифру, латинскую букву или нижнее подчёркивание. Таким образом, \B делает то же самое, что \w

  //Начало строки ^
  const regex = /^\d+/g;
  const newReg = /\d+/g;
  const str = '2001 год: Космическая одиссея, вышел в 1968 году';
  str.match(regex); // [ "2001" ];
  str.match(newReg); // [ "2001", "1968" ];
  //Конец строки $
  const regex = /\d+$/;
  const str = 'https://praktikum.yandex.ru/trainer/frontend-developer/lesson/45';
  str.match(regex); // ( ["45"] )
  //Перенос строки \n
  const str2 = 'Это утро, радость эта,\nЭта мощь и дня и света,'

  //Наборы
  //Чтобы создать набор, нужно перечислить подходящие символы в квадратных скобках
  //ищем все символы «а» и «б»:
  'барабан'.match(/[аб]/g); // [ "б", "а", "а", "б", "а" ]
  //шаблон ищет все дни весны
  const str = '14/03/2018';
  const regex = /\d\d\W0[345]\W2018/g; // этот шаблон ищет все дни весны
  str.match(regex);

  //Диапазоны
  //Диапазон — часть набора. Это два символа, разделённых дефисом
  const regex = /[м-р]/gi;
  'Марсианин'.match(regex); // [ "М", "р", "н", "н" ]
  //шаблон ищет все дни первого полугодия
  const str = '20/04/2019';
  const regex = /\d\d\W0[1-6]\W2019/g;
  str.match(regex); // [ "20/04/2019" ]

  //Наборы + Диапазоны
  const regex = /[a-z0-9\-]/gi; // все латинские буквы, все цифры и дефис
  const str = 'В Берлин я летал на boeing 737-800';
  str.match(regex).join(''); // "boeing737-800"

  //Кириллица
  //Ищем всю латиницу и всю кириллицу, а от знаков препинания избавляемся
  //в таблице символов "ё" стоит обособленно от других кириллических букв. Поэтому, чтобы не терять «ё», дописывайте её в набор:
  const regex = /[\wа-я\sё]/gi;
  const str = 'Yandex 2020. Ещё не вечер!';
  str.match(regex).join(''); // "Yandex 2020 Ещё не вечер"

  //Исключающие наборы и диапазоны
  //Чтобы сделать набор или диапазон исключающим, перед ним нужно поставить «шляпку» ^ (карет)
  const str = 'Оценки за четверть: 2 3 3 5 2 4 2 3 5';
  const regex = /[^1-3]/g;
  str.match(regex).join(''); // "Оценки за четверть:    5  4   5"
  //пусть шаблон выловит любые символы, кроме нижнего подчёркивания и заглавных латинских букв
  const cardholder = 'VASSiliy_PUPK1N';
  const forbidden = /[^A-Z\_]/g
  console.log(cardholder.match(forbidden));

  //Квантификаторы
  //От одного до бесконечности повторений — квантификатор +
  const str = 'Правильно писать «свиной», с одной «н»';
  const regex = /свин+ой/; // такое регулярное выражение найдёт оба варианта: и с «н», и с «нн»
  str.match(regex); // [ "свиной" ]

  //От нуля до бесконечности повторений — квантификатор *
  const exc = 'экскаватор';
  const esc = 'эскалатор';
  const regex = /эк*ска[вл]атор/; // буква "к" может встречаться, а может и не встречаться
  exc.match(regex); // [ "экскаватор" ]
  esc.match(regex); // [ "эскалатор" ]

  //Необязательный символ — квантификатор ?
  const regex = /favou?rite/g; // делает букву "u" необязательной и будет искать оба варинта написания favourite и favorite
  const str = 'favourite for favorite';
  str.match(regex); // ["favourite", "favorite"]

  //Контроль повторов — квантификатор {}
  const regionCode = /\d{3}/;
  const phoneNumber = 'Мой номер телефона: +7(999)123-12-21';
  phoneNumber.match(regionCode); // [ "999" ]
  //Можно также указывать не точное количество повторений, а диапазон
  const str = 'столько, стооолько и вот стооооооооолько';
  const regex = /сто{2,5}лько/;
  str.match(regex); // [ "стооолько" ]. в слове "стооооооооолько" повторов "о" больше 5
  //Верхнюю границу числа повторений можно не указывать
  const someSymbol = /a{1,}/g;
  const    str = 'alohaa';
  console.log(str.match(someSymbol)); // ["a", "aa"]

