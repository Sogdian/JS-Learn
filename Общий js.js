/*Ванильный js ------------------------------
Типы данных:
  примитивы (элементарные типы), у которых есть только значение:
    number — числа: целые и с точкой
    string — строки
    boolean — логические, или булевы, значения: true — «истина» и false — «ложь»
    undefined — undefined; - Значение не определено
    массивы - для хранения однородных элементов, хранит последовательность значений, и порядок этих значений важен. сложные, или составные, типы данных
    функции -
    null - Значения нет
  объекты, имеющие свойства пары: «ключ + значение»:
    объекты - состоит из множества пар «ключ-значение», порядок этих пар не важен; сложные, или составные, типы данных
Составные типы содержат не одно, а несколько значений

Операция сложения — бинарная, так как в ней два операнда.
    Существуют и унарные операции, с одним операндом, и тернарные операции, с тремя операндами.
    Приоритет операторов https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Operator_Precedence

Конкатенацией - сложение строк (“catenate” — «связывать в одну цепь».)
Зарезервированные слова https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Lexical_grammar#%D0%9A%D0%BB%D1%8E%D1%87%D0%B5%D0%B2%D1%8B%D0%B5_%D1%81%D0%BB%D0%BE%D0%B2%D0%B0

Событийный цикл - выполняет сначала: скрипт (весь асинхронный код в скрипте), микрозадача (например, промис), макрозадача (например, таймер)
  В очереди микрозадач и в очереди макрозадач быстрее выполняются те задачи, которые выполнились быстрее в своей очереди
  Очереди работают последовательно

Ошибки:
  runtime - во время исполнения программы
  компиляции - во время компиляции кода
*/

//Переменные
  import { useState } from 'react';

let user = 'John', age = 25, message = 'Hello'; //в одной строке

console.log(21 + "2"); //"212"
  console.log(2 ** 3); // возведение в степень. выведет в консоль 8
  console.log((2 + 2) / 2);
  console.log(4 * 3 ** 2); // = 4 * 3 в степени 2
  console.log(document.querySelector('.page'));
  console.log('вино' + 'град'); //Конкатенация
  console.log('Время, мин: ' + 50); // = 'Время, мин: 50'. Плюс может быть знаком сложения или конкатенации, но так как один из операндов — строка, то сложение не подходит. Поэтому число 50 приводится к строке '50' и склеивается со строкой 'Время, мин: '.
  console.log('2' * 50); // = 100. Звёздочка — это знак умножения, со строками она не используется. Поэтому JavaScript пытается превратить строку '2' в число, и ему это удаётся. Затем числа 2 и 50 перемножаются, и получается 100.
  console.log(`Это - шаблонная строка,
  несколько строк`); //Шаблонные строки, ограничиваются с обеих сторон обратными кавычками ``
  console.log(`${2 + 5} раз отмерь - ${value} отрежь`); // "7 раз отмерь - 1 отрежь"
  let merry = true;
    console.log(!merry); // false

//Символы Symbol. Фактически их можно воспринимать как гарантированно уникальное значение, предоставляемое JavaScript.
  //Для его создания нужно явно обратиться к типу по имени Symbol и в качестве аргумента передать подпись
  let id = Symbol('id');
  console.log(id); //Выведет Symbol(id)

//Строки
  console.log('эспрессо'[0]); // "э". получить символ из строки по его индексу

//Числа
  //После объявления эти числа можно использовать в вычислениях наряду с десятичными, но при выводе они будут автоматически сконвертированы в десятичную систему
  let hex = 0xFF; //255
  let binary = 0b011110; //30
  let num = 1234; //это десятичное число

/* Мат операции
  Остаток от деления %
    1 % 3: 1. Поскольку 1 не делится на 3 нацело, остаток равен самому числу, то есть 1. Поэтому результат равен 1.
    2 % 5: 2. Поскольку 2 не делится на 5 нацело, остаток также равен самому числу, то есть 2. Поэтому результат равен 2.
    3 % 3: 0. В данном случае 3 делится на 3 нацело (1 раз), поэтому остаток равен 0. Поэтому результат равен 0. */

//Неявное преобразование типов
  //Приведение к строке
  console.log(100 + '500'); // "100500"
  console.log(1 + ''); // "1"
  console.log(undefined + ''); // "undefined"

  //Приведение к числу
  console.log(null >= 1); // false
  console.log('451' < 452); // true
  //Унарные операторы приводят нечисловые значения после «+, -, /, *» к численному типу. Так +'33' вернёт число 33, +'-77' вернет число -77.
  //Если операторы сложения и унарный плюс стоят рядом, они не помешают друг другу
  console.log(67 + +'33'); // 100
  console.log('3' - 1); // 2
  console.log('4' / 4); // 1
  console.log('2' * 2); // 4
  //Но сложения со строкой — будет воспринято как конкатенация
  console.log('4' + 4); // 44 - здесь выполнится конкатенация

  //Приведение к булевым значениям
  //В круглых скобках условия if любые данные всегда приводятся к логическому типу
  //Если элемента с классом username на странице нет, в переменную usernameElement запишется null.
  //В круглых скобках условной конструкции null приводится к логическому типу и становится false. Поэтому тело условия if выполнено не будет
  const usernameElement = document.querySelector('.username');
  if (usernameElement) {
    console.log('Привет, ' + usernameElement.textContent);  }

//Явное преобразование типов
  //Приведение к строке
  const numberToString = String(2); // "2"
  const nanToString = String(NaN); // "NaN"
  const undefinedToString = String(undefined); // "undefined"
  const nullToString = String(null); // "null"
  const booleanToString = String(true); // "true"
  num.toString(1); // Выведет строку: 1 (String)
  num.toString(16); //4d2 это уже шестнадцатеричное число
  num.toString(2); //10011010010 а вот так двоичное

  //Приведение к числу
  const stringToNumber = Number('2'); // 2
  const nullToNumber = Number(null); // 0
  const anotherStringToNumber = Number('счастье не за горами'); // NaN
  const undefinedToNumber = Number(undefined); // NaN
  num.parseInt('17'); // Вернёт 17.
  num.parseInt('10001', 2); // Вернёт 17. вторым аргументом в parseInt мы передаём именно систему исчисления, из которой мы преобразуем исходное число.
  num.parseInt('11', 16);   // Вернёт 17

  //Приведение к булевым значениям
  Boolean(2) // true
  Boolean(0) // false
  Boolean('') // false
  Boolean(NaN); Boolean(null); Boolean(undefined) // false
  Boolean('Непустая строка'); // true
  Boolean({}); // true
  Boolean([]); //true

  //as, см. в Общий ts.ts

  //isNaN()
  //функция проверяет, является ли переданное значение «не числом» (Not-a-Number).
  //Функция возвращает true, если переданное значение — не число, и false — если значение является числом или может быть преобразовано в число
  console.log(isNaN(42)); // false, число
  console.log(isNaN("42")); // false, строка, но может быть преобразована в число
  console.log(isNaN("abc")); // true, не может быть преобразована в число
  console.log(isNaN(true)); // false, true преобразуется в 1
  console.log(isNaN(undefined)); // true, undefined не является числом
  console.log(isNaN(null)); // false, null преобразуется в 0

//Возвращает строку со значением типа переменной. Оператор typeof
  typeof 10; // "number"
  typeof 'Hello World!'; // "string"
  typeof true; // "boolean"
  typeof undefined; // "undefined" - Значение не определено
  typeof (10 + 5) // "number". Скобки ставят, когда нужно определить тип целого выражения
  typeof NaN; // "number". "Not a Number" имеет тип данных "number"
  typeof null; // "object"
  typeof function () {} // "function". Хоть такого типа и нет.
  console.log(typeof(input.value));

  const checkType = (name1) => {
    const names = name1;
    if (typeof names === 'string') {
      return names;
    }
    return 'Имя не задано';
  }

//Date
  //Если параметры метода не указаны, то он использует настройки браузера для локализации даты.
  //getDay() - выяснить день недели для указанной даты в виде целого числа от 0 до 6.
    //У метода есть одна особенность началом недели он считает воскресенье, то есть число 0 соответствует воскресенью, 1 — это понедельник, 2 — вторник, 6 — суббота
  const date = new Date('2023-03-05');
  const options = { day: "numeric", month: "short" }; //вывести день числом, а месяц в сокращённом формате
    const options2 = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' }; //В консоли отобразится "воскресенье, 5 марта 2023 г."
    //Для форматирования даты на русском языке используется локаль «ru».
  new Date(date).toLocaleDateString('ru-RU', options); //date - объект класса Date

  const formatDate = (date) => new Date(date).toLocaleDateString("ru", {
    day: "numeric",
    month: "short",
  }); //Функция formatDate вернёт дату в виде 5 мар.
  const getWeekday = (date) => new Date(date).toLocaleDateString("ru", {
    weekday: "short"
  }); //Функция getWeekday вернёт дату в виде первых двух букв для недели — вс.

//Формат JSON, метод toJSON
  //JSON.stringify - для преобразования объектов в JSON
  let student = {
    name: 'John',
    age: 30,
    courses: ['html', 'css', 'js'],
  };
  let json = JSON.stringify(student);
  alert(json); //выведет объект в формате JSON

  //JSON поддерживает следующие типы данных
  alert( JSON.stringify(1) ) // 1. // число в JSON остаётся числом
  alert( JSON.stringify('test') ) // "test".   // строка в JSON по-прежнему остаётся строкой, но в двойных кавычках
  alert( JSON.stringify(true) ); // true
  alert( JSON.stringify([1, 2, 3]) ); // [1,2,3]

  //JSON.parse - для преобразования JSON обратно в объект


//Логические операторы
  //Оператор логическое НЕ (!)
  //Если поставить ! перед небулевым значением, движок JS сначала приведёт тип к булю, а затем изменит значение на противоположное
  !false; // true
  !'Непустая строка' // false
  !!true; // true
  //пример
  if (children === 0 || children === undefined || children === null) return <></>; //= if (!children) return <></>;

  //оператор двойного отрицания
  //используется для приведения значения к булеву типу
  !!''        // false
  !!null      // false
  !!0         // false
  !!'test'    // true
  !!{}        // true
  !![]        // true
  !!function() {} // true

  //Оператор логическое ИЛИ (||). возвращает true, если хотя бы один из операндов равен true. || возвращает первое истинное значение.
  //true || true    // true
  // false || false // false
  // true || false  // true
  // false || true // true
  //оператор || не различает false, 0, пустую строку "" и null/undefined. Для него они все одинаковы, т.е. являются ложными значениями.
  let condition =  0 || NaN || 'строка' || false;  // Значение переменной condition: 'строка'

  //Оператор логическое И (&&). возвращает значение true, если оба операнда равны true.
  // true && true    // true
  // false && false // false
  // true && false  // false
  // false && true  // false
  //Если поставить && между правдивыми условиями, оператор вернёт последнее из них:
  console.log(2 * 2 === 4 && 5 < 6 && 'Каждый может стать'); // 'Каждый может стать'
  //Если среди условий есть ложные, && вернёт из них первое ложное:
  console.log(2 * 2 === 4 && undefined && 'Каждый может стать'); // undefined

  //Оператор строгого равенства, тут нет приведения типов (т.е. сравниваются типы (которые не меняются, не приводятся)). https://htmlacademy.ru/courses/209/run/5
  2 === 'a'; // Результат: false
  'a' !== 'a'; // Результат: false
  //оператор нестрогого равенства, тут есть приведение типов
  2 == 'a'; // Результат: true
  //оператор нестрогого неравенства
  'a' != 'a'; // Результат: false

  //Приоритетность операторов https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence#table
  //сначала выполняется логическое НЕ, потом И, а затем — ИЛИ,  т.е. !, потом &&, затем ||
  //Операции в скобках выполняются первыми
  const optimism = !'Жить' && !'Быть' || 'Жить и быть';
  //Сначала !'Жить' → false, потом !'Быть' → false, затем false && false → false и наконец false || 'Жить и быть' → 'Жить и быть'.
  console.log(optimism); // "Жить и быть". сначала выполняется !, потом &&, затем ||

  //Пример
    function checkTheCar (distance, ownersNumber, crushed) {
      if (distance <= 100000) { // проверяем пробег
        if (ownersNumber === 1) { // 1 владелец по ПТС?
          if (crushed === false) { // не битая?
            return true;
          }
          else return false;
        }
        else if (ownersNumber === 2) { // Владелец не 1? Тогда может 2?
          if (crushed === false) { // не битая?
            return true;;
          } else return false
        } else return false;
      } else return false;
    }

  //Сравнение чисел - сравнивает два объекта по полю economy.
  //Если значение поля economy у объекта a меньше, чем у объекта b, то функция возвращает отрицательное число (-1) и т.д.
  function compareTicketsByEconomyPrice(ticket1, ticket2) {
    if (ticket1.economy < ticket2.economy) {
      return -1;
    } else if (ticket1.economy > ticket2.economy) {
      return 1;
    } else {
      return 0;
    }
  }
  //Или тоже самое в более лаконичной форме:
    //Отсортируйте данные по возрастанию даты. Перед тем как сортировать данные, нужно создать их копию через [...tickets]
    [...tickets].sort((a, b) => a.date > b.date ? 1 : -1);

  //Сравнение строк - сравнение будет производиться в соответствии с лексикографическим порядком символов (сравниваются символьные коды)
  function compareStrings(a, b) {
    const stringA = a.toLowerCase();
    const stringB = b.toLowerCase();
    if (stringA < stringB) {
      return -1;
    }
    if (stringA > stringB) {
      return 1;
    }
    return 0;
  }
    //Прямое сравнение для строк, которые содержат символы кириллицы, может дать неправильный результат. Универсальный способ сравнения строк — метод localeCompare().
    //Метод localeCompare() сравнивает две строки в соответствии с локалью (языком), учитывая правила сортировки этого языка, и возвращает целое число, которое указывает, какая строка должна быть отсортирована перед другой строкой.
    //Пример сортировки массива строк по алфавиту:
    const fruits = ['яблоко', 'банан', 'арбуз', 'груша'];
    fruits.sort((a, b) => a.localeCompare(b));
    console.log(fruits); // ["арбуз", "банан", "груша", "яблоко"]
    //Добавим строки со «сложными» символами в массив:
    const fruits = ['яблоко', 'банан', 'арбуз', 'груша', 'ёжик', 'йогурт'];
    fruits.sort((a, b) => a.localeCompare(b));
    console.log(fruits); // ['арбуз', 'банан', 'груша', 'ёжик', 'йогурт', 'яблоко']
    fruits.sort((a, b) => a > b ? 1 : -1);
    console.log(fruits); // ['арбуз', 'банан', 'груша', 'йогурт', 'яблоко', 'ёжик']

//Операторы нулевого слияния и присваивания: '??', '??='
  //Оператор нулевого слияния (??)
  //Результат выражения a ?? b будет следующим:
    //если a определено, то a (т.е. оператор ?? возвращает первый аргумент, если он не null и undefined)
    //если a не определено, то b (т.е. иначе второй)
    let res = a ?? b //= (a !== null && a !== undefined) ? a : b;

  let user;
  alert(user ?? "Аноним"); // Аноним (user не существует)
  let user2 = "Иван";
  alert(user2 ?? "Аноним"); // Иван (user существует)

  //Важное различие между ними заключается в том, что:
    // || возвращает первое истинное значение.
    // ?? возвращает первое определённое значение.
    let height = 0;
    alert(height || 100); // 100
    alert(height ?? 100); // 0

  //Оператор нулевого присваивания (??=)
  //проверить, равна ли переменная null или undefined, и если это так — присвоить этой переменной какое-либо другое значение
  x ??= y //Оператор ??= присвоит x значение y только в том случае, если x не определено (null/undefined).


//Условия if else
  //блоки if else нельзя использовать в JSX-выражениях в фигурных скобках.
  const a = 5, b = 10;
  let max;
  if (a > b) {
    max = a;
  } else {
    max = b;
  }

//Методы поиска в строке
  //Поиск по строке. Метод indexOf. Метод indexOf ищет символ в строке и возвращает его индекс
  //indexOf чувствителен к регистру
  'Яндекс.Практикум'.indexOf('Я'); // 0
  'эспрессо'.indexOf('c'); // 1. Если таких символов в строке несколько, метод вернёт индекс первого из них
  'эспрессо'.indexOf('к'); // -1. Если символа в строке нет, indexOf вернёт -1
  //indexOf может найти и комбинацию символов. При этом вернётся индекс первого символа из последовательности
  const blok = 'Ночь, улица, фонарь, аптека';
  blok.indexOf('фонарь'); // 13.

//Поиск в начале и конце строки. Методы startsWith и endsWith
  //Метод startsWith сравнивает начало строки с переданной ему подстрокой
  'Вендетта'.startsWith('В'); // true
  'Родина'.startsWith('Картинка в букваре'); // false

  //Метод endsWith делает всё то же самое, только с концом строки
  const theRealEnd = 'Это ещё не конец';
  theRealEnd.endsWith('конец'); // true

//Управление регистром. Методы toLowerCase и toUpperCase
  'Включите Caps Lock'.toLowerCase(); // "включите caps lock"
  'Выключите Caps Lock'.toUpperCase(); // "ВЫКЛЮЧИТЕ CAPS LOCK"

//Превращение строки в массив. Метод split
  //Метод split принимает на вход один аргумент — разделитель. Он показывает, где заканчивается один элемент массива и начинается следующий
  //метод String.split ожидает, что какой-то элемент должен быть и до, и после разделителя
  //Поэтому если ваша строка начинается с разделителя или заканчивается разделителем, в полученном массиве первым или последним элементом будет пустая строка
  'Пришёл. Увидел. Победил.'.split(' '); // ["Пришёл.", "Увидел.", "Победил."]
  'Пришёл. Увидел. Победил.'.split('. '); // ["Пришёл", "Увидел", "Победил"]

//Извлечение части строки. Метод slice
  //Метод slice возвращает часть строки. На вход он принимает два аргумента — с какого индекса начинать отсчёт и на каком закончить
  //Второй аргумент необязательный: если его не указать, slice() вернёт все символы от заданного в первом аргументе до конца строки
  'Не прислоняться'.slice(6, 10); // "слон"
  'Яндекс.Практикум'.slice(7); // "Практикум"

//Объект Math и его методы
  // округляет переданное число «вниз»
  Math.floor(9.99); // 9
  // округляет «вверх»
  Math.ceil(9.01); // 10
  // округляет до ближайшего целого
  Math.round(9.51); // 10
  // возвращает наибольшее из переданных чисел
  Math.max(1, 2, 3, 4, 5); // 5
  // возвращает наименьшее из переданных чисел
  Math.min(1, 2, 3, 4, 5); // 1
  // возвращает случайное число от 0 включительно до 1 не включительно
  Math.random(); // 0.31764219954126016

//Работа с дробной частью. Функция parseInt
  //Функция parseInt приводит переданный аргумент к целому числу.
  //Она читает аргумент слева направо, если встречает не цифру, останавливается и возвращает всё, что прочитала до этого
  //Если первый символ передаваемой строки не цифра, parseInt вернёт NaN:
  parseInt('37 лет, 8 месяцев и 10 дней'); //37
  parseInt('38 попугаев'); //38
  //Второй аргумент parseInt — система счисления, в которой число передаётся функции
  parseInt('100', 10); // 100. Чаще всего вам нужна десятичная система. Явно указывайте её, чтобы избежать неожиданных результатов.
  parseInt('100', 2); // 4 (100 в двоичной системе)

//Функция parseFloat
  //Функция parseFloat работает аналогично parseInt, только выделяет не целое число, а число с плавающей точкой
  parseFloat('36.6'); // 36.6
  parseFloat('36.6 нормальная температура человека '); // 36.6

//Проверка на принадлежность к целым числам. Метод Number.isInteger
  //Метод Number.isInteger принимает число как аргумент и проверяет, целое оно или дробное
  const eightAndAHalf = 8.5;
  Number.isInteger(eightAndAHalf); // false



//!Массивы. В JavaScript нет типа «массив» (потому что в JavaScript нет типа array),
  //но есть метод, который поможет это проверить, — Array.isArray()
  //в массиве можно хранить любые данные: строки, булевы значения, числа и даже другие массивы
  //если в массиве нет элемента под тем номером, под которым мы записываем, то этот элемент будет создан
  //Массив — это объект со специальными методами (например, push и map) и свойством length.
  //Числовые индексы — это ключи, а соответствующие им элементы — значения этих ключей
  //Поскольку массивы — это объекты, они передаются и сравниваются по ссылке.
  let phrases = []; //пустой массив
  let numbers = [1, 2, 3, 4, 5];
  numbers[numbers.length] = 7; //добавить новый элемент в конец массива
  console.log(numbers); //[ 1, 2, 3, 4, 5, 7 ]

  //Свойство four не является частью массива, оно просто добавлено в объект.
  //numbers.length по-прежнему равен 6
  numbers.four = 4;
  console.log(numbers); // [ 1, 2, 3, 4, 5, 7, four: 4 ]

  //Проверка на массив Array.isArray
  const arr = [1, 2, 3];
  const obj = {};
  console.log(Array.isArray(arr)); // true
  console.log(Array.isArray(obj)); // false

  //Копирование массива
  const boringTale = [
    'У попа была собака, он её любил,'
  ];
  const boringTale2 = Object.assign([], boringTale); //в boringTale2 скопировалось boringTale
  //метод slice, не передавая тому никаких аргументов
  const boringTale2 = boringTale.slice();

  let aliExpress = [1, 2, 3].length //длина массиыв = 3 элемента

  let guest = "Jane";
  let admin = "Pete";
  [guest, admin] = [admin, guest]; //мы создаём временный массив из двух переменных и немедленно деструктурируем его в порядке замены
  alert(`${guest} ${admin}`); //Pete Jane

  const results = new Array(size); //size - размер массива. У этого массива задана длина, но он не будет заполнен элементами. Для элементов создаются «ячейки» — слоты
    const results = new Array(size).fill(value); //fill - для заполнения слотов пустого массива

  const count = 5;
    const results = Array.from({length: count}, (_,i) => i * 2); //Где size — это желаемый размер массива, i — значение, которое мы добавляем в массив.
      //Метод from создаёт массив из любого объекта, похожего на массив. Здесь мы создаём новый массив с помощью метода Array.from()
    console.log(results)

  const count = 5;
    const results = [...Array(count)].map((_, i) => i * 2); //Ещё один способ заполнить «разреженный» массив — создать его копию spread-оператором
    console.log(results)

  /*Шпаргалка по методам массивов
  1 indexOf Метод indexOf ищет символ в строке и возвращает его индекс
  1 findIndex нахождения индекса объекта в массиве
  1	concat()	Объединяет массивы и элементы
  2 join()  Преобразование массива в строку
  2	push()	Добавляет элементы в конец массива
  3	pop()	Удаляет последний элемент массива и возвращает его значение
  4	unshift()	Добавляет элементы в начало массива
  5	shift()	Удаляет первый элемент массива и возвращает его значение
  6	slice()	Копирует часть массива и создаёт из неё новый массив
  7	splice()	Удаляет часть элементов, а на их место ставит новые
  8	forEach()	Перебирает элементы, выполняя для каждого какой-то код
  9	map()	Создаёт новый массив, получая каждый элемент из уже имеющегося массива
  10 flatMap()
  10 includes
  10	filter()	Создаёт новый массив, выкидывая из исходного элементы по заданным правилам
  11	some()	Проверяет, есть ли в массиве хоть один элемент, соответствующий заданному правилу
  12	every()	Проверяет, все ли элементы массива соответствуют заданному правилу
  13	find()	Проверяет, есть ли в массиве определённый элемент
  14	reduce()	Сводит массив к какому-то одному значению
  15	sort()	Сортирует
  15 for...in работа с полями объекта */

  //findIndex() - нахождения индекса объекта в массиве, Этот метод работает аналогично indexOf
  //Если элемент в массиве найден, findIndex вернёт его индекс, в противном случае метод вернёт значение -1.

  //Добавление элементов. Метод concat
  //Метод concat не меняет структуру начального массива, а возвращает новый
  const toDoList = ['Посадить', 'Построить'];
  const toDoListUpdated = toDoList.concat('Вырастить', 'Прибраться');
  console.log(toDoListUpdated);  //["Посадить", "Построить", "Вырастить", "Прибраться"];
  //Как аргумент можно передать и другой массив — его элементы будут скопированы и добавлены в новый массив
  const moscowAttractions = ['Кремль', 'Третьяковская галерея'];
  const spbAttractions = ['Эрмитаж', 'Мариинский театр'];
  const russiaAttractions = moscowAttractions.concat(spbAttractions); //['Кремль', 'Третьяковская галерея', 'Эрмитаж', 'Мариинский театр']

  //Преобразование массива в строку. Метод join
  //с исходным массивом ничего не произошло
  //Если не передать join аргумент, элементы в строке будут перечислены через запятую
  const bremenMusicians = ['Кот', 'Пёс', 'Трубадур', 'Осёл', 'Петух'];
  console.log(`Представляем музыкантов: ${bremenMusicians.join(', ')}`); // "Представляем музыкантов: Кот, Пёс, Трубадур, Осёл, Петух"

  //Добавление элемента: метод push
  //Метод push добавляет переданные ему аргументы в конец массива
  const emeraldCityHeroes = ['Лев'];
  emeraldCityHeroes.push('Элли');
  console.log(emeraldCityHeroes); // ["Лев", "Элли"]

  //Удаление элемента: метод pop
  //Метод pop удаляет последний элемент массива. Если массив пуст, pop вернёт undefined
  const insects = ['Бабочка', 'Комар'];
  console.log(insects.pop()); // "Комар". Метод возвращает значение удалённого элемента
  console.log(insects); // ["Бабочка"]

  //Удаление первого элемента: метод shift
  const italyCities = ['Помпеи', 'Рим', 'Неаполь'];
  const volcanoEruption = italyCities.shift(); // метод shift() возвращает удалённый элемент
  console.log(volcanoEruption); // "Помпеи"

  //Добавление элемента в начало массива: метод unshift
  //Метод unshift добавляет элементы в начало массива. Их передают через запятую
  const queue = ['Рабочие'];
  queue.unshift('Пенсионеры');
  console.log(queue);  //["Пенсионеры", "Рабочие"]
  //Метод unshift изменит исходный массив и напишет, сколько элементов в новом массиве
  const queue = ["Пенсионеры", "Инвалиды", "Рабочие", "Школьники", "Студенты"];
  console.log(queue.length); // 5
  console.log(queue.unshift('Мне только спросить')); // 6

  //Получение части массива: метод slice. Исходный массив при этом не изменяется
  //Метод slice копирует часть массива и делает из неё новый массив. Он принимает на вход два аргумента:
    //индекс элемента, с которого нужно начать копирование (включительно);
    //индекс элемента, на котором нужно остановиться (не включительно)
  //Второй аргумент можно не указывать. Тогда скопированы будут все элементы до конца
  const months = ['Январь', 'Февраль', 'Март', 'Апрель', 'Май', 'Июнь', 'Июль', 'Август', 'Сентябрь', 'Октябрь', 'Ноябрь', 'Декабрь'];
  const spring = months.slice(2, 5); //начиная с индекса 2 ("Март") и до, но не включая индекс 5 ("Июнь")
  console.log(spring); // ["Март", "Апрель", "Май"]
  //Можно передавать как аргумент и отрицательные числа. Тогда индекс будет считаться с конца массива
  //начиная с четвёртого элемента с конца и до первого с конца (не включительно)
  const autumn = months.slice(-4, -1);
  console.log(autumn); // ["Сентябрь", "Октябрь", "Ноябрь"]
  //Можно вызывать slice вообще без аргументов. Получится новый массив, состоящий из всех элементов исходного
  const months2 = months.slice();
  console.log(months2); //['Январь', 'Февраль', 'Март', 'Апрель', 'Май', 'Июнь', 'Июль', 'Август', 'Сентябрь', 'Октябрь', 'Ноябрь', 'Декабрь'];

  //Замена части элементов массива: метод splice
  const week = ['Понедельник', 'Вторник', 'Среда', 'Четверг', 'Пятница', 'Суббота', 'Воскресенье'];
  const removedItems = week.splice(0, 5, 'Воскресенье', 'Суббота', 'Воскресенье', 'Суббота', 'Воскресенье');
  // начиная с индекса 0 удалим пять элементов и вставим на их место другие пять
  console.log(removedItems); // ["Понедельник", "Вторник", "Среда", "Четверг", "Пятница"]
  console.log(week); // ["Воскресенье", "Суббота", "Воскресенье", "Суббота", "Воскресенье", "Суббота", "Воскресенье"]
  //Новые значения добавлять необязательно — можно удалить существующие
  week.splice(2, 1); // ["Среда"]
  console.log(week); //['Понедельник', 'Вторник', 'Четверг', 'Пятница', 'Суббота', 'Воскресенье'];
  //И наоборот. Можно ничего не удалять — только добавить новые элементы
  week.splice(2, 0, "Земля"); // ["Среда"] 0
  console.log(week); // ['Понедельник', 'Вторник', 'Земля', 'Среда', 'Четверг', 'Пятница', 'Суббота', 'Воскресенье'];

  //Array.from. создаёт массив из «массивоподобного» объекта
  const posts = content.querySelectorAll('.post');
  const postsArray = Array.from(posts); // такой вызов вернёт полноценный массив

  //Обход массива: метод forEach
  //В качестве аргумента forEach принимает функцию. Она будет вызвана на каждом элементе массива поочерёдно
  //Но с forEach нельзя использовать директивы continue и break
  //Метод forEach нужен, когда мы хотим просто пройтись по массиву и для каждого элемента что-то сделать
  const how = ['быстрее', 'выше', 'сильнее'];
  how.forEach(function (item) {
    console.log(item + '.'); // быстрее.выше.сильнее
  });
  //пример с NodeList
  const elements = document.querySelectorAll('.text');
  elements.forEach((item) => {
    item.classList.add('text_is-active');
  });
  //если ключами в объекте оказались строки, которые можно привести к числам, большинство JS-движков упорядочит их сразу у себя

  //Создание одного массива из другого: метод map
  //Метод map создаёт новый массив на основе существующего
  //В качестве аргумента map, как и forEach, принимает функцию
  //Эта функция должна вернуть значение, которое станет элементом нового массива
  //Метод map нужен, когда мы хотим создать новый массив из старого и преобразовать его элементы
  const firstArr = [0, 1, 2, 3, 4];
  const secondArr = firstArr.map(({ item }) => { // Берём каждый элемент массива
    item * item; //функция должна вернуть значение, которое станет элементом нового массива (пример, возводим каждый элемент в квадрат)
  });
  console.log(secondArr); //[0, 1, 4, 9, 16]
  //Метод map нельзя применить к массивоподобным объектам, но можно создать новый (Array.from) и на нем сделать map
  const elements = document.querySelectorAll('.text');
  const elementsArr = Array.from(elements);
  const newArr = elementsArr.map(({ item }) => {
    item.classList.add('text_is-active');
  });
  //пример 2
    const numbers = [1, 2, 3, 4, 5];
    const results = numbers.map(number => number * 2);
    console.log(results); // [2, 4, 6, 8, 10]
  //пример 3. вывод элементов массива (feature) в шаблоне { featuresList }
    const features = [
        '2 каюты',
        '4 спальных места',
    ];
    const featuresList = features.map((feature) => (
      <li>{feature}</li>
    ));
      <ul>{featuresList}</ul>

  //пример 4
  const firstArr2 = [0, 1, 2, 3, 4];
  const secondArr2 = firstArr2.map(function (item, index) {
    return (item * item) * index;
  });

  //пример 5. Преобразовать один массив в другой
  export interface OrganizationServiceInfoModel //organizationServiceInfo
  {
    subdivisionId: string;
    subdivisionName: string;
    serviceStartAt: any;
    serviceEndAt?: any;
  }
  export interface ExtendedSvkDirectionInfoModel //directories
  {
    id: string;
    startDate: any;
    endDate?: any;
  }
  const directories = organizationDataModel.organizationServiceInfo.map(item => ({
    id: item.subdivisionId,
    startDate: item.serviceStartAt,
    endDate: item.serviceEndAt,
  }));

  //flatMap
  //Метод flatMap() позволяет сформировать массив, применяя функцию к каждому элементу, затем уменьшает вложенность, делая этот массив плоским, и возвращает его.

  //Поиск по строке. Метод includes. Метод используется для проверки наличия элемента в строке / массиве.
  //Если элемент найден, возвращает true, если нет — false
  //Пример 1 с массивом
    const fruits = ["apple", "banana", "orange", "mango"];
    console.log(fruits.includes("banana")); // true
    console.log(fruits.includes("kiwi")); // false
      //Эту же операцию можно записать методом indexOf, который вернёт индекс нужного элемента в массиве, и сравнить его с -1.
    //Пример 2 с массивом
      root.render(<App words={words} selectedItems={selectedItems}/>);
      const selectedItems = ['3', '4'];
      const words = [ { id: '1', word: 'Сasa' };
      function App({words = [], selectedItems = []}) {
          const cards = words.map((item) => (
            <Card isSelected={selectedItems.includes(item.id)} /> //https://up.htmlacademy.ru/fe-react/1/demos/10321#19
          ));
          return (
                <ul> {cards} </ul>
          );}
    //Пример со строкой
      'Гарри Поттер и узник Азкабана'.includes('Гарри Поттер'); // true

  //Отбор элементов массива: метод filter
  //Метод filter создаёт новый массив из элементов, для которых функция-фильтр вернула true. При этом исходный массив не меняется.
  //Колбэк метода filter — те же три параметра, что и у map и forEach. Текущий элемент, его индекс и исходный массив:
  const persons = [
    { name: 'Пётр', age: 16 },
    { name: 'Максим', age: 18 },
  ];
  const fullAgePersons = persons.filter(person => person.age >= 18); //На вход filter передадим другую функцию, которая возвращает true, если поле age больше либо равно 18.
  console.log(fullAgePersons); //[{ name: 'Максим', age: 18 }]

  const fruits = ['apple', 'banana', 'orange', 'grape'];
  const itemToRemove = 'orange';
  const filteredFruits = fruits.filter((item) => item !== itemToRemove); //filter можно использовать и для удаления элемента из массива
  console.log(filteredFruits); //['apple', 'banana', 'grape'];

  //Поиск элемента в массиве. Метод find
  //find возвращает значение элемента, на котором он завершил проверку
  const birds = [
    'Ворона',
    'Чёрно-белая ворона',
    'Белая ворона',
    'Ворона обыкновенная'
  ];
  const crow = birds.find(function (bird) {
    return bird.includes('ворона');
  });
  console.log(crow); // "Чёрно-белая ворона"
  //find - используется для поиска первого элемента в массиве, который удовлетворяет заданному условию в виде колбэк-функции
    const numbers = [1, 2, 3, 4, 5, 6, 7];
    const result = numbers.find((item) => item > 3);
    console.log(result); // 4. Метод find находит первый элемент массива, удовлетворяющий условию (= true), и возвращает его.
      // В нашем случае это элемент 4. Иначе вернет undefined
    //пример с объектами
      const persons = [
        { id: 1, name: 'Alice' },
        { id: 2, name: 'Bob' },
      ];
      const resultByName = persons.find((item) => item.name === 'Bob'); //Метод find можно использовать для поиска объекта в массиве по значению одного из его полей.
      console.log(resultByName); // { id: 2, name: 'Bob' }

  //Проверка элементов массива. Метод some
  //Метод some проверяет, есть ли в массиве хотя бы один элемент, который соответствует определённому правилу.
  //Колбэк с этим правилом проверяет каждый элемент и возвращает true или false
  //Колбэк метода some — те же три параметра, что и у map и forEach. Текущий элемент, его индекс и исходный массив:
  const oceanResidents = ['Флаундер', 'Немо', 'Губка Боб', 'Аквамен'];
  const nemo = oceanResidents.some(function (resident) {
    return resident === 'Немо';
  });
  console.log(nemo); // true

  //Проверка элементов массива. Метод every
  //Метод every проверяет все элементы массива и возвращает true, только если все элементы прошли проверку.
  //Колбэк — единственный аргумент метода. Он содержит логику проверки каждого элемента и возвращает true или false
  const jokes = [
    'смешная шутка и доля правды',
    'не очень смешной анекдот + доля правды',
    'доля правды в дурацкой шутке, услышав которую, все улыбнулись из вежливости'
  ];
  const allJokesWithTruth = jokes.every(function (joke) {
    return joke.indexOf('доля правды') > -1;
  });
  console.log(allJokesWithTruth); // true

  //Сведение массива. Метод reduce
  //аргументы: промежуточное значение (На каждой итерации этот аргумент равен тому, что в прошлый раз вернул колбэк), текущий элемент, его индекс и исходный массив
  //На первой итерации значение previousValue — первый элемент массива, item — второй
  const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];
  const sum = arr.reduce(function (previousValue, item) {
    return previousValue + item; //означает: «прибавь текущий элемент массива к тому, что получилось на предыдущей итерации»
  });
  console.log(sum);
  //previousValue можно задать самостоятельно
  const winsAndLoses = [10, 20];
  const total = winsAndLoses.reduce(function (previousValue, item) {
    return previousValue + item;
  }, 100); // Начальное значение (100) передаём методу reduce как второй аргумент.
  console.log(total); // 130

  //пример2, объединение массивов
  function concat<T>(...arr: T[][]): T[] | undefined {
    if (arr.length === 0) {
      return [];
    }
    return arr.reduce((acc, curr) => acc.concat(curr), []);
  }
  console.log(concat()); // []
  console.log(concat(['qwerty'], ['asd'])); // ['qwerty', 'asd']
  console.log(concat([1, 2, 3], [4, 5], [6, 7, 8])); // [1, 2, 3, 4, 5, 6, 7, 8]

  //Сортировка массива sort
  //Может вызываться без функции обратного вызова (колбэка)
  const myNumbers = [0, 3, 2, 1];
  myNumbers.sort(); //если не передавать ему аргументы, пытается сортировать элементы массива по возрастанию Unicode кодов
  console.log(myNumbers); //[ 0, 1, 2, 3 ]
  //Вызов с аргументами (колбэком)
  //если вы хотите отсортировать массив по возрастанию, колбэк должен возвращать a - b, по убыванию — b - a.
  const myNumbers = [0, 3, 2, 1];
  myNumbers.sort(function (a, b) {
    return a - b; //отсортировать по возрастанию
    /* Если a меньше b, вернётся отрицательное число.
    Это значит, что a должно расположиться в итоговом массиве
    раньше, b — позже. Например:
      a = 0, b = 3.14
      a - b = -3.14
    Получили отрицательное число, значит a стоит раньше b */
  });
  console.log(myNumbers); //[ 0, 1, 2, 3 ]
  //Сортиорвка строк
  const chessChampions = ['Вильгельм', 'Эммануил', 'Александр' ];
  chessChampions.sort(function (a, b) {
    a = a.toLowerCase();
    b = b.toLowerCase();
    if (a < b) return -1; // a расположится раньше b
    return 0;
  });
  console.log(chessChampions); //'Александр', 'Вильгельм', 'Эммануил'



//!Объекты. Объекты состоят из пар «ключ — значение». Пары «ключ — значение» часто называют полями.
  //Значение — это данные, которые мы хотим записать.
  //Значением может быть строка, число, булево значение, массив, другой объект - такую пару называют свойством
  //Значением может быть функция - такую пару называют методом
  //Ключ — это уникальное имя этого значения. По ключу мы можем обратиться к значению
  //Пары «ключ — значение» делятся на два типа: свойства и методы.
  let user0 = {};  // синтаксис "литерал объекта", let user = new Object(); // синтаксис "конструктор объекта"

  let user = {
      nickname: 'Мария',
      getGreeting: function() {
          return 'nickname';
      },
      getGreeting2: function() {
          return this.nickname; //вернуть значение ключа этого же объекта
      },
      "likes birds": true  //имя свойства из нескольких слов должно быть в кавычках. Обращение через [] скобки - user["likes birds"] = true;
  };
  console.log(user.nickname); //Мария
  console.log(user['nickname']); //Мария. Квадратные скобки также позволяют обратиться к свойству, имя которого может быть результатом выражения
  console.log(user.getGreeting()); //Мария
  console.log(user.getGreeting2()); //Мария

  //Операторы: delete, in
  let user = {
    nickname: 'Мария'
  };
  delete user.nickname; //удаление свойства
  console.log(user.nickname); //undefined
  console.log(user); //{}. удалится и сам ключ

  let admin = user; //копируется ссылка на user, но не сам объект

  //Запись новых свойств
  const obj = {
    one: 1,
  };
  obj.two = 2;
  console.log(obj.two); //2

  //Если при записи нового свойства мы передаём значение ключа, которое не является строкой, оно автоматически преобразуется в строку
  const obj = {};
  obj[1] = 'единица';
  obj[true] = 'истина';
  console.log(obj['1']); // "единица"
  console.log(obj['true']); // "истина"
  //при доступе к свойству в квадратных скобках указать значение, не являющееся строкой, оно преобразуется в строку
  console.log(obj[1]); // "единица"
  console.log(obj[true]); // "истина"

  //обращение к свойству объекта по ключу
  console.log(obj['1']); // "единица"

  //Запись (записать) в свойство - объект
  const phonebook = {
    'Тёма': {
      mobile: '+79995164420',
    }
  };
  function addPhoneNumber(name, numberType, number) {
    if (!phonebook[name]) { //если свойства нет
      phonebook[name] = {}; //записать в свойство пустой объект
    }
    phonebook: phonebook[name][numberType] = number; //в объект phonebook добавить объект Анастасия = { mobile: '+79111545616' }
  }
  addPhoneNumber('Анастасия', 'mobile', '+79111545616');

  //Записать в свойство объекта значение переменной или функцию
  function getCartoonName() {
    return 'Трое из Простоквашино';
  }
  const cartoon = {
    getCartoonName: getCartoonName //можно просто getCartoonName без дублирования
  };
  console.log(cartoon); //getCartoonName: f getCartoonName()

  //Сравнение объектов
  //Если в переменные записаны ссылки на объекты, движок проверяет, на один ли объект ведут ссылки.
  //Если на один — возвращает true, если на разные — false.
  const time = {};
  const money = time;
  console.log(time === money); // true. Ведь time и money — это две ссылки на один и тот же объект.

  //Объект, объявленный через const, может быть изменён. объявление const защищает от изменений только саму переменную obj, а не её содержимое
  const obj = {
    firstName: 'John',
    lastName: 'Doe',
    'как хочу, так и называю': true,
    '123anarchy!!!': true,
    one: 1, //one это переменная
    red: "#f00",
    'добро пожаловать': 'или посторонним вход воспрещён', //имя ключа неизвестно на момент написания кода
    birthday  : {
      month: 'февраль',
      day: 12
    }
  };
  const propertyName = 'firstName';
    console.log(obj[propertyName]); // Выведет 'John'
  obj['как хочу, так и называю']; // true
    obj['123anarchy!!!']; // true
  const key = 'one'; //one это переменная использованная потом
    console.log(obj[key]); // 1
  const key = prompt('red, green или blue?');
    console.log(obj[key]); // "#f00"
  const key = prompt('red, green или blue?');
    console.log(obj.key); //undefined. мы попытались обратиться к свойству 'key', которого в объекте нет.
  const part1 = 'добро'; //имя ключа неизвестно на момент написания кода
    const part2 = 'пожаловать';
    const key = `${part1} ${part2}`;
    console.log(obj[key]); // "или посторонним вход воспрещён"
  obj.birthday.month = 'февраль'; //эквивалентна birthday['anya']['month'].
    obj['birthday']['month'] = 'февраль';

  //Задание динамических свойств объектов
  const propertyName = 'firstName';
  const obj = {
    [propertyName]: 'John',
    lastName: 'Doe',
  };
  console.log(obj.firstName); // Выведет 'John'

  //Квадратные скобки также позволяют обратиться к свойству, имя которого может быть результатом выражения
  let user = {
    name: "John",
  };
  let key = prompt("Что вы хотите узнать о пользователе?", "name");
  //доступ к свойству через переменную
  alert(user[key]); // John (если ввели "name"). Через alert( user.key ); //undefined

  //Вычисляемые свойства
  let fruit = prompt("Какой фрукт купить?", "apple");
  let bag = {
    [fruit]: 5, // имя свойства будет взято из переменной fruit
  };
  alert(bag.apple); // 5, если fruit="apple"

  //Свойство из переменной
  function makeUser(name, age) {
    return {
      name, // то же самое, что и name: name (параметр функции)
      age   // то же самое, что и age: age (параметр функции)
    };
  }

  //Проверка существования свойства, оператор in
  let user = { name: "John", age: 30 };
  alert("age" in user); // true, user.age существует
  alert("blabla" in user ); // false, user.blabla не существует

  if ('name' in user) {
    console.log(user.name); //John
  } else ('age' in user) {
    console.log(user.age); //30
  }

  //Цикл for...in
  let user = { name: "John", age: 30 };
  for (let key in user) {
    alert( key );  // ключи // name, age
    alert( user[key] ); // значения ключей // John, 30
  }

  //Object.keys
  let cat = { name: "Алан", surname: 'Кей' };
  Object.keys({ name: 'Алан', surname: 'Кей' }); // ["name", "surname"]
  Object.keys(cat).forEach(function (a) { //в "a" записываются ключи
    console.log(a); //name surname
  });

  //Object.values
  //Метод Object.values возвращает значения всех свойств и методов объекта
  let cat = { name: "Алан", surname: 'Кей' };
  console.log( Object.values(cat) ); //[ 'Алан', 'Кей' ]
  console.log( Object.values(cat)[0] ); //[ 'Алан' ]

  //Object.entries
  //Метод Object.entries возвращает все пары «ключ-значение».
  console.log( Object.entries(paulMcCartney) ); // [["yesterday", "all my troubles seemed so far away"]]

  //Копирование объекта Object.assign. Создать поверхностную копию объекта
  //Первый аргумент dest — целевой объект.
  //Остальные аргументы src1, ..., srcN являются исходными объектами
  //Если есть свойства с одинаковым именем — они будут перезаписаны.
  Object.assign(dest, [src1, src1, src3])
  Object.assign(dest, src1, src1, src3);

  let user = { name: "John" };
  let permissions1 = { canView: true };
  let permissions2 = { canEdit: true };
  Object.assign(user, permissions1, permissions2); // копируем все свойства (первой вложенности, родительской, основной) из permissions1 и permissions2 в user
    //теперь user = { name: "John", canView: true, canEdit: true }

  //использовать Object.assign для замены цикла for..in для простого клонирования
  let user = {
    name: "John",
    age: 30
  };
  let clone = Object.assign({}, user); //Он копирует все свойства user в пустой объект и возвращает его.

  //клонирование с использованием оператора расширения spread
  let clone = {...user};

  //Методы объекта
  //Функцию, которая является свойством объекта, называют методом этого объекта.
  let user = {
    name: "John"
  };
  user.sayHi = function() {
    alert("Привет!");
  };
  user.sayHi(); // Привет!
  //Сокращённая запись метода
  user = {
    sayHi: function() {
      alert("Привет");
    }
  };
  //или так
  user = {
    sayHi() { // то же самое, что и "sayHi: function(){...}"
      alert("Привет");
    }
  };

//Контекст
  //Глобальный контекст
  //На верхнем уровне (вне каких-либо функций) контекстом является глобальный объект
  //В браузере глобальным объектом является window, а в Node.JS — global.

  //this в объектах
  //this ссылается на контекст выполнения. Контекст — это объект окружения, в котором выполняется код
  let user = {
    name: "John",
    sayHi: function() {
      //тут this - контекст метода, т.е. сам объект (точнее ссылка на объект user)
      console.log(this.name);
    }
  };
  //контекст метода — это объект (пример, user), который находится слева от точки при вызове (sayHi())
  user.sayHi(); //John

  //если объект вложен в другой
  //Контекст — это объект до точки
  let user = {
    name: "John",
    greeting: {
      sayHi: function() {
        console.log(this.name);
      }
    }
  };
  //Контекст — это объект до точки, т.е. user.greeting, в котором нет name, поэтому undefined
  user.greeting.sayHi(); //undefined

  //Контекст у стрелочных функций
  //у стрелочных функций нет своего контекста
  const grandma = {
    name: 'Бабушка Люба',
    cookPancakes: () => {
      //Ключевое слово this в стрелочной функции ссылается на контекст функции-родителя, в которой она была определена
      //cookPancakes определена вне каких-либо других функций, а значит,
      //контекстом в этом месте будет window, поэтому this = undefined
      console.log(this.name, 'напекла блинов — все за стол!', '😋');
    }
  }
  grandma.cookPancakes(); // undefined напекла блинов — все за стол! 😋
  //а так правильно
  function cookPancakes() {
    setTimeout(() => {
      // Контекст будет таким же, как и у cookPancakes
      console.log(this.name, 'напекла блинов — все за стол!', '😋');
    }, 1000);
  }
  const grandma = {
    name: 'Бабушка Люба',
    cookPancakes,
  }
  grandma.cookPancakes(); //(спустя секунду) Бабушка Люба напекла блинов — все за стол! 😋

  //Контекст в функции-конструкторе
  //bind - с его помощью можно явно указать конкретный контекст выполнения
  //bind - создаёт новую функцию-обёртку. При вызове этой обёртки запустится исходная функция, но с заданным объектом контекста
  //пример1
  function celebrateBirthday(...invited) {
    console.log(this.name, 'сегодня отмечает день рождения!', '🥳');
    if (invited.length) {
      console.log('На праздник приглашены:', invited.join(', '));
    }
  }
  const grandma = {
    name: 'Бабушка Люба'
  }
  const celebrateGrandmaBirthday = celebrateBirthday.bind(grandma);
  celebrateGrandmaBirthday('папа', 'мама', 'я', 'сестра');
    // Бабушка Люба сегодня отмечает день рождения! 🥳
    // На праздник приглашены: папа, мама, я, сестра

  //пример2
  const release = {
    commits: ['353657d', '3cc2170', '4002893', '6fb5e5f', '14a37bd', 'c2176ed'],
    start() {
      console.log('Релиз готов! В него попали такие коммиты:');
      for (let hash of this.commits) {
        console.log(hash);
      }
    }
  }
  setTimeout(release.start.bind(release), 1000);

  //bind позволяет так же указать часть аргументов или все аргументы функции
  //для примера1
  const celebrateGrandmaBirthday2 = celebrateBirthday.bind(grandma, 'папа', 'мама');
  celebrateGrandmaBirthday2('я', 'сестра');
    // Бабушка Люба сегодня отмечает день рождения! 🥳
    // На праздник приглашены: папа, мама, я, сестра

  //apply метод делает то же самое, но аргументы функции нужно указать массивом
  celebrateBirthday.apply(grandma, ['папа', 'мама', 'я', 'сестра']);
  // Бабушка Люба сегодня отмечает день рождения! 🥳
  // На праздник приглашены: папа, мама, я, сестра

  //apply - перенять контекст
  //пример 2
  const wardrobe = {
    width: 3000,
    depth: 600,
    square() {
      return this.width * this.depth / 1_000_000;
    }
  }
  console.log('Площадь шкафа:', wardrobe.square(), 'м2');
  const fridge = {
    width: 900,
    depth: 600,
  }
  console.log('Площадь холодильника:', wardrobe.square.apply(fridge), 'м2');

//Свойство [[Prototype]] (прототип) - является скрытым
  //У любого объекта в JavaScript есть прототип — что-то вроде родительского объекта.
  //Если в объекте нет нужного свойства, JavaScript автоматически пойдёт искать его в прототипе этого объекта.
  //Если свойства не оказалось и в прототипе, поиск продолжится в прототипе прототипа и так далее.
  //Последним в цепочке будет Object.prototype.
  //Ссылка на прототип объекта содержится в специальном свойстве [[Prototype]].
  //Это свойство является скрытым, но его можно увидеть, например, в консоли браузера
  const tv = {
    chanel: 1,
  };
  tv.toString(); //[object Object]
    //toString - метод находятся в объекте Object.prototype, который является последним прототипом в цепочке
  tv.hasOwnProperty('chanel'); //true
    //hasOwnProperty - метод находятся в объекте Object.prototype, который является последним прототипом в цепочке

  //получить прототип объекта Object.getPrototypeOf()
  Object.getPrototypeOf(tv); //{ ... }
  Object.getPrototypeOf(tv) === Object.prototype; //true

  //переопределить прототип Object.setPrototypeOf()
  Object.setPrototypeOf(tv, newPrototype);
  Object.getPrototypeOf(tv); //newPrototype

  //__proto__ - у любого объекта есть свойство __proto__, с помощью которого также можно прочитать или изменить прототип
  tv.__proto__ = newPrototype;
  Object.getPrototypeOf(tv); //newPrototype

  //Указание прототипа при создании Object.create()
  const hashTable = Object.create(null); //Объект с нулевым прототипом

//Функция-конструктор
  //Имя функции-конструктора должно начинаться с заглавной буквы
  //Функцию-конструктор вызывают только вместе с оператором new
  function User1(login) {
    // Неявно, «под капотом», создаётся пустой объект и присваивается this:
    // this = {};
    // Выполняется тело функции, которое добавляет в this новые свойства:
    this.login = login;
    this.isAdmin = function () {
      return this.login.startsWith('admin');
    }
    // В конце функция (неявно) возвращает получившийся объект this:
    // return this;
  }
  const egor = new User1('admin_egor');

  //callable-объект или функция с состоянием
  //Однако TypeScript такое не одобрит: функция-конструктор не должна явно ничего возвращать
  function User2(login) {
    this.login = login;

    return () => {
      console.log(this.login);
    };
  }
  const user = new User2('petr123');
  user(); // petr123

  //new.target
  //А ещё в теле функции можно проверить, вызвана она с помощью оператора new или без него
  //свойство new.target — оно будет ссылкой на саму функцию-конструктор, или undefined, если вызов был без new
  function User3(login) {
    if (!new.target) {
      return new User3(login); // Добавляем **new**, если вызов был без него
    }
    this.login = login;
    this.isAdmin = function () {
      return this.login.startsWith('admin');
    }
  }
  const user3 = new User3('user1'); // Всё нормально
  const user4 = User3('user2'); // Теперь и так тоже можно!

  //Задать нужный прототип при создании объекта
  function User(login) {
  }
  User.prototype = {
    database: 'main'
  };
  const ivan = newUser('ivan_from_yerevan');
  console.log(ivan.database); // main

  //for..in - Перечисление свойств объекта, включая те, которые содержатся в прототипе
  //Цикл for..in перебирает все перечисляемые свойства объекта, включая всю цепочку прототипов.
  const flat = {
    wallpaper: 'ocean',
    rent: () => {},

    __proto__: {
      walls: 'strong',

      __proto__: {
        sale: () => {}
      }
    }
  }
  for (const key in flat) {
    console.log(key); //wallpaper rent walls sale
  }

  //Object.keys()
  //Она вернёт массив с собственными свойствами объекта, игнорируя свойства прототипа
  const barsik = {
    name: 'Барсик',
    meow: () => { console.log('Meow!') },
  }
  const sadBarsik = {
    mood: 'sad',
    __proto__: barsik,
  }
  Object.keys(sadBarsik); // ['mood']

  //Object.values()
  //Есть похожая конструкция Object.values(), только она возвращает не названия свойств объекта, а их значения
  Object.values(sadBarsik); // ['sad']

  //Object.hasOwn()
  //Чтобы проверить, является ли свойство собственностью объекта или содержится в прототипе, можно воспользоваться методом Object.hasOwn(),
  Object.hasOwn(sadBarsik, 'mood') // true
  Object.hasOwn(sadBarsik, 'name') // false
  //а весь прототип получить с помощью Object.getPrototypeOf()
  Object.getPrototypeOf(sadBarsik) // barsik

  //Object.getOwnPropertyDescriptor() - посмотреть флаги свойства
  //у каждого свойства есть набор атрибутов (флагов)
  //Метод вернёт дескриптор указанного свойства — объект, содержащий значение свойства и его флаги
  //У дескриптора обычного свойства есть поля value, writable, enumerable и configurable.
  const obj = { weather: 'warm' }
  Object.getOwnPropertyDescriptor(obj, 'weather');
    //{
    //value: 'warm',
    //enumerable: true, //флаг делает свойство перечисляемым в циклах
      //Свойство toString, которое мы рассматривали выше, содержит флаг enumerable = false — кажется, теперь понятно, почему цикл for..in его проигнорировал
    //configurable: true, //флаг разрешает удалять свойство и менять его атрибуты
      //Если задать свойству флаг configurable = false, то нельзя будет удалить свойство, поменять его атрибуты, снова сделать свойство конфигурируемым, — это билет в один конец
      //Однако поменять значение свойства можно, пока ему не задан флаг writable = false
    //writable: true //флаг разрешает менять значение свойства.
    //}

  //Object.defineProperty() поменять флаги
  //Если в объекте свойство уже существует, метод Object.defineProperty() обновит его флаги, в ином случае — создаст новое
  //Если не указать один из дескрипторов, то его значением по умолчанию будет false
  Object.defineProperty(obj, 'mood', {
    value: 'cool',
    enumerable: true,
    configurable: true
  });
  //obj.mood =
  // {
  //   value: 'cool',
  //   enumerable: true,
  //   configurable: true,
  //   writable: false
  // }

  //Object.defineProperties() - позволяет задавать сразу несколько свойств
  Object.defineProperties(obj, {
    prop1: { ... },
    prop2: { ... },
    ...
  });

  //Object.getOwnPropertyDescriptors() - возвращает дескрипторы всех собственных свойств объекта

  //Клонирование свойств и флагов
  const obj1 = Object.defineProperties({}, Object.getOwnPropertyDescriptors(obj2));

  //Заморозка объекта
  Object.preventExtensions(obj) //запрещает добавлять свойства в объект.
    //Можно удалять, изменять флаги, изменять значение
  Object.seal(obj) //запрещает добавлять и удалять свойства, делает все свойства неконфигурируемыми.
    //Можно изменять значение
  Object.freeze(obj) //запрещает добавлять, удалять и изменять свойства.

//Словари
  let users = {
      'favorite food': 'Сметана',
      fullname: 'Иванова'
  };
  console.log(users['favorite food']); //Сметана
  console.log(user['fullname']); //Иванова

//Тернарный оператор. тернарный оператор возвращает значение, а условная конструкция — нет
  //условие ? значение1 : значение2;
  const a = 5, b = 10;
  const max = (a > b) ? a : b;
  //пример 2
  const someStorage = localStorage.getItem(LocalStorageKeys.SidebarMenuItemActive);
  const someVariable = someStorage ? JSON.parse(someStorage) : true; //Если значение переменной someStorage истинно (не равно null, undefined, false, 0, '' или другим "ложным" значениям), то это выражение принимает значение true.
  //тернарный оператор в реакте
  <div>{ condition ? <Component1 /> : <Component2 />; }</div>

//!циклы
  //for
    for (let i = 0; i <= 4; i = i + 1) {
        console.log(aliExpress[i]);
      continue; //Директива continue не прерывает весь цикл, а только пропускает текущую итерацию.
      break; //Директива break нужна, когда дальнейшее выполнение цикла бессмысленно или может привести к неправильным результатам
    }
  //for of
  //Метод обеспечивает удобный способ перебора значений, а не ключей или индексов
  //for...of не работает со свойствами объектов, так как они не являются итерируемыми.
  const arr = [1, 2, 3];
  for (let value of arr) {
    console.log(value); //1 2 3
  }
  //for in
  //for...in используется для перебора свойств объекта.
  //Он проходит по всем перечисляемым свойствам объекта и его прототипу.
  const obj = { a: 1, b: 2, c: 3 };
  for (let key in obj) {
    console.log(key); //a b c
  }

  //while
  let a = 1; let b = 0;
  while (a >= b) {
    console.log("do");
    a +=1;
  }

  //do while. тело цикла выполнится хотя бы один раз
  do {
    console.log("do");
  } while (a >= b);

  //Конструкция switch-case
    let day = 'Monday';
    switch (day) {
      case 'Monday':
        alert('Сегодня понедельник');
        break;
      case 'Tuesday':
        document.body.style.backgroundColor = 'blue';
        break;
      default:
        alert('Сегодня неизвестный день недели');
        break;
    }

  //пример 2. Можно сознательно пропустить break, чтобы прописать логику сразу нескольких случаев
  let catName;
  const cartoon = 'Зима в Простоквашино';
  switch (cartoon) {
    case 'Зима в Простоквашино':
    case 'Весна в Простоквашино':
      catName = 'Матроскин';
      break;
    case 'Лето кота Леопольда':
      catName = 'Леопольд';
  }
  console.log(catName); // "Матроскин"

//Функции. При объявлении функции описывают её параметры. При вызове — передают аргументы.
  //функции в JavaScript — это объекты с дополнительными методами. В них тоже можно добавлять свойства
  //Объявление функции Function Declaration — объявление именованной функции
  //Объявленную функцию можно вызвать до объявления, функциональное выражение — нельзя
  function makeHelloWorld() { //makeHelloWorld - Объявление функции
    function helloWorld() { //helloWorld - Объявление функции
      return console.log("Hello world!");
    }
    return helloWorld; //тут мы не вызываем функцию
  }
  const helloWorld = makeHelloWorld(); //в helloWorld запишется ссылка на simpleFunction
  console.log(helloWorld); //[Function: helloWorld]
  helloWorld(); //"Hello world!"

  //Самовызываемая функция IIFE
  //Функция создаётся и сразу же вызывается
  (function helloWorld(name) {
    return console.log();
  })("Hello world!")

  //Функциональные выражения Function Expression — объявление анонимной функции внутри переменной:
  //Объявленную функцию можно вызвать до объявления, функциональное выражение — нельзя
  const functionName = function (userName, bookName) { //Передавать аргументы надо в том же порядке, в котором объявлены параметры функции. Потому что порядок аргументов соответствует порядку параметров в функции. У нас параметры записаны в таком порядке: userName, bookName.
      console.log('Меня зовут ' + userName + '. Моя любимая книга: ' + bookName);
      let name = userName + bookName;
      return name;
  };
  function sayHello(name) {
      return 'Привет, ' + name;
  }

  //Стрелочные функции
  //В стрелочных функциях нельзя использовать this, т.к. у них нет своего контекста
  const consoleWombat = (wombat) => {
    console.log(wombat);
  };
  //Короткий return в стрелочных функциях
  const singleAnecdote = (anecdote) => {
    return `я знаю только один анекдот: ${anecdote}`;
  };
  const shorterSingleAnecdote = (anecdote) => `я знаю только один анекдот: ${anecdote}`; //можно без return и фигурных скобок
  //Если возвращаемое значение — объект, его нужно заключить в круглые скобки. Иначе то, что в фигурных скобках, движок воспримет как тело функции
  const colorHex = () => ({ white: '#FFF' }); //вот так правильно
  const colorHexWhite = () => { white: '#FFF' }; //вот так не правильно
  //Короткая запись параметров
  //Если у стрелочной функции один параметр, можно не заключать его в скобки:
  const boatArrival = survivor => {
    console.log(`до другого берега доберётся только ${survivor}`);
  };
  //Стрелочные функции как колбэки
  const array = [1, 2, 3, 4];
  array.forEach(() => {
    console.log('Кнопка нажата!');
  });
  //Стрелочные функции как колбэки и внутри нее вызов функции колбека
  createCard(removeCard); //вызов функции createCard с колбеком removeCard как аргумент
  function createCard(removeCard) { //инициализация createCard, параметр removeCard - колбек
    button.addEventListener('click', () => { //в колбеке (стрелочная функция) есть колбек который мы вызываем, но вызовется он, когда будет 'click'
      removeCard(name) //передача в колбек removeCard параметров
    });
  }
  const removeCard = (name) => {
    console.log('name')
  };
  //Если единственное, что делает колбэк — это возвращает значение (через return), то можно использовать короткий return
  const array = [1, 2, 3, 4];
  const newArray = array.map(elem => elem * 2);

  //Анонимные функции
    element.addEventListener('click', function () { //function (){...} - анонимная функция
      console.log('Клик');
    });

  //Функция-конструктор
  //Имя функции-конструктора должно начинаться с большой буквы
  //Функция-конструктор должна выполняться только с помощью оператора new
  function User(name) {
    this.name = name;
  }
  let user = new User("Jack");
  alert(user.name); // Jack

  //можно вызывать без скобок
  let user = new Users();
  let user = new Users;

  //Создание методов в конструкторе
  function User(name) {
    this.name = name;
    this.sayHi = function() {
      alert( "Меня зовут: " + this.name );
    };
  }
  let john = new User("John");
  john.sayHi(); // Меня зовут: John

  //return
  //return без значения просто говорит функции «хватит». Если передать такой функции пустую строку, она прекратит работу. Функция при этом вернёт специальное значение undefined
  function sayHello(name) {
    if (name === '') {
      return; // если имя — пустая строка, выйдем из функции
    }
    let greeting = 'Привет, ' + name;
    return greeting;
  }
  //Аргументы по умолчанию
  //Параметр по умолчанию может принимать любое значение: число, строку, объект, функцию
  function generateName(firstName, lastName, middleName = '') {
    return `${firstName} ${middleName} ${lastName}`;
  }
  //Значением одного параметра функции даже может быть другой её параметр:
  function generateName(firstName, lastName = firstName) {
    return `${firstName} ${lastName}`;
  }
  //spread в функциях
  //При вызове функции — разбивает массив
  const nums = [4, 8, 15, 16, 23, 42];
  Math.max(...nums); // 42
  //rest в функциях
  //При объявлении функции — собирает аргументы в массив
  //rest-параметр всегда стоит в конце
  function consoleDogs(firstDog, ...otherDogs) {
    console.log(`Первый: ${firstDog}`);
    console.log(`Остальные: ${otherDogs}`);
  }
  consoleDogs('Спаниель', 'Овчарка', 'Борзая', 'Метис'); //"Первый: Спаниель" и "Остальные: ['Овчарка', 'Борзая', 'Метис']"
  //Старый код. Переменная arguments
  //В старом коде, до появления оператора spread, можно встретить другой способ работы с такими функциями — переменную arguments.
  function gimmeSomeArguments() {
    console.log(arguments);
  }
  gimmeSomeArguments(1, 2); // [1, 2]

  //prompt. позволяет получить ответ от пользователя.
  //Функция выводит диалоговое окно с текстовым полем. Если пользователь введёт что-то и нажмёт кнопку "ОК", в переменной password сохранится введённый текст.
  //Если пользователь не настроен на диалог и нажмёт «Отмена», в переменную попадёт null.
  password = prompt('Введите пароль:');

  //alert
  alert("Hello"); //Она показывает сообщение и ждёт, пока пользователь нажмёт кнопку «ОК».

  //confirm
  let res = confirm(question); //Функция confirm отображает модальное окно с текстом вопроса question и двумя кнопками: OK и Отмена

  //Присвоение функции свойства
  function multiply(a, b) {
    return a * b;
  }
  multiply.someValue = 4; //Если обратиться к свойству функции с ключом someValue, вернётся 4

  //Проверка на функцию
  function multiply(a, b) {
    return a * b;
  }
  console.log(typeof multiply); // "function"

  //Передача по ссылке
  function multiply(a, b) {
    return a * b;
  }
  let multiplyRef = multiply;
  console.log(multiply === multiplyRef); // true

  //Колбэк
  //Синхронные. каждый блок кода здесь выполняется за другим и последовательность заранее определена
  function handleError(tweet) {
    const newTweetContainer = document.createElement('div');
    newTweetContainer.textContent = tweet;
    document.body.append(newTweetContainer);
  }
  function insertTweet(tweet, containerSelector, callback) {
    const tweetContainer = document.querySelector(containerSelector);
    if (!tweetContainer) {
      callback(tweet);
      return;
    }
    tweetContainer.textContent = tweet;
  }
  insertTweet('Твит, адресованный Илону Маску', '.tweets', handleError);
  //Асинхронные
  function imageLoadCallback(evt) { // колбэк, который нужно выполнить после того как изображение загрузится
    document.body.append(evt.target);
  }
  function loadImage(imageUrl, loadCallback) {
    const img = document.createElement('img');
    img.src = imageUrl;
    img.onload = loadCallback;
  }
  loadImage('https://yastatic.net/q/logoaas/v1/Практикум.svg', imageLoadCallback); // Теперь картинка появится в разметке только после загрузки

//js функции
  Math.ceil(number); //принимает на вход число и округляет его до целого в большую сторону
  Math.floor(number); //делает то же самое, только округляет в меньшую сторону
  Math.round(number); //округляет число до ближайшего целого значения
  Math.random(); //Она возвращает случайное число между 0 и 0.99999999999, включая 0:
  Math.max(a, b, c); //Math.min(a, b, c...); - возвращает наибольшее или наименьшее число из перечисленных аргументов.
  Math.round(arg); //округляет аргумент до ближайшего целого.
  Math.ceil(arg); //округляет аргумент в большую сторону.
  throwDice(min, max); //генерирует случайные числа в заданном промежутке, включая минимальное и максимальное значение.
  Math.floor(Math.random() * array.length); //floor - Мы можем округлить наше число от 0 включительно до array.length в меньшую сторону, «отбрасывая» дробную часть случайного числа
  price.toLocaleString(); //1500 -> 1 500 //преобразует число в строку и возвращает значение, используя указанный языковой стандарт.
    //Если метод используется без параметров, то он использует язык по-умолчанию.
    //const formatPrice = (price) => `${price.toLocaleString()} ₽`; //1 500 ₽

  //У img есть свойства onload и onerror
  //onload сработает, когда изображение загружено,
  //onerror сработает если произошла ошибка

//Интерполяция шаблонной строки
  const formattedPrice = `Значение = ${price.toLocaleString()} ₽/час`; // = price.toLocaleString() + " ₽/час"
    const formattedPrice = `cards ${!isShownByGrid ? 'list' : ''}`; // "cards list" или "cards"
    className="{'button button-${firstSelectedOption}'}";

  const className1 = `card ${ isSelected ? 'selected' : ''} ${ isFinished ? 'disabled' : '' }`; //card selected disabled или card или другие вариации

//Опциональная цепочка ?. (value?.prop)
  //(value?.prop) работает как value.prop, если значение value существует,
  //в противном случае (когда value равно undefined/null) он возвращает undefined
  let user = {}; // пользователь без адреса. Также ?. работает и при let user = null
  alert( user?.address?.street ); // undefined (без ошибки)
  //пример с document.querySelector
  let html = document.querySelector('.elem')?.innerHTML; //будет undefined, если элемента нет

  //Другие варианты применения: ?.(), ?.[]
  //?.() используется для вызова функции, которая может не существовать.
  let userAdmin = {
    admin() {
      alert("Я админ");
    }
  };
  let userGuest = {};
  userAdmin.admin?.(); // Я админ
  userGuest.admin?.(); // ничего не произойдет (такого метода нет)

  //?.[] синтаксис также работает, если мы хотим использовать скобки [] для доступа к свойствам вместо точки "."
  let user1 = {
    firstName: "John"
  };
  let user2 = null;
  alert( user1?.['firstName'] ); // John
  alert( user2?.['firstName'] ); // undefined

//Деструктуризация
  const x = 5;
      const obj = {x}; //или const obj = {x: x}; //создать объект со свойством x, равный значению этой переменной х = «возьми значение из переменной x и помести его в свойство объекта с таким же именем».
      const arr = [x]; //также для массивов
  //Деструктуризация массива
  let arr = ["Ilya", "Kantor"];
  let [firstName, surname] = arr; //firstName = arr[0] и surname = arr[1]
  alert(firstName); //Ilya
  alert(surname);  //Kantor
  //Пропускайте элементы, используя запятые
  let [firstName, , title] = ["Julius", "Caesar", "Consul", "of the Roman Republic"];
  alert( title ); //Consul, оставшиеся элементы массива также пропускаются (так как для них нет переменных).
  //Трюк обмена переменных
  let guest = "Jane";
  let admin = "Pete";
  [guest, admin] = [admin, guest]; //Здесь мы создаём временный массив из двух переменных и немедленно деструктурируем его в порядке замены

  //Spread (распыление)
  const arr1 = [1, 2, 3];
  const arr2 = [4, 5, 6];
  const combinedArray = [...arr1, ...arr2];
  console.log(combinedArray); // [1, 2, 3, 4, 5, 6]

  //Rest (остаток). Переменная rest является массивом из оставшихся элементов
  const [first, second, ...restOfArray] = [1, 2, 3, 4, 5];
  console.log(first); // 1
  console.log(restOfArray); // [3, 4, 5]
  //Значения по умолчанию
  let [name = "Guest", surname = "Anonymous"] = ["Julius"];
  alert(name);    //Julius (из массива справа)
  alert(surname); //Anonymous (значение по умолчанию)
  //Rest (остаток) объекта
  let options = {
    title: "Menu",
    height: 200,
    width: 100
  };
  let {title, ...rest} = options;   // сейчас title="Menu", rest={height: 200, width: 100}
  alert(rest.height);  // 200
  alert(rest.width);   // 100

  //Деструктуризация объекта
  let options = {
    title: "Menu",
    width: 100,
    height: 200
  };
  let {title, width, height} = options; //Порядок слева не имеет значения, "let {height, width, title}" - так – тоже работает
  alert(title);  // Menu
  alert(width);  // 100
  alert(height); // 200
  //Если мы хотим присвоить свойство объекта переменной с другим названием, например, свойство options.width присвоить переменной w, то мы можем использовать двоеточие
  //Двоеточие показывает «что : куда идёт»
  let {width: w, height: h, title} = options;
  alert(title);  // Menu
  alert(w);      // 100
  alert(h);      // 200
  let {width = 100, height = 200, title} = options; //Для потенциально отсутствующих свойств мы можем установить значения по умолчанию
  let {width: w = 100, height: h = 200, title} = options; //Мы также можем совмещать : и =
  let { title } = options; //Если у нас есть большой объект с множеством свойств, можно взять только то, что нужно
  let {title, ...rest} = options; //пример с Rest

  //Вложенная деструктуризация
  let options = {
    size: {
      width: 100,
    },
    items: ["Cake", "Donut"],
  };
  let {
    size: { // положим size сюда
      width,
    },
    items: [item1, item2], // добавим элементы к items
  } = options;
  alert(width);  // 100
  alert(item1);  // Cake
  alert(item2);  // Donut

  //Умные параметры функций. Мы можем передать параметры как объект, и функция немедленно деструктурирует его в переменные
  let options = {
    title: "My menu",
    items: ["Item1", "Item2"]
  };
  function showMenu({title = "Untitled", items = []}) {
    alert( `${title}` ); //My Menu. title – взято из options
    alert( items ); //Item1, Item2. items – взято из options
  }
  showMenu(options);
  showMenu({}); //все значения будут по умолчанию.
  //Мы можем исправить это, сделав {} значением по умолчанию для всего объекта параметров
  //Весь объект аргументов по умолчанию равен {}, поэтому всегда есть что-то, что можно деструктурировать
  function showMenu({ title = "Menu", width = 100, height = 200 } = {}) {
    alert( `${title} ${width} ${height}` );
  }
  showMenu(); // Menu 100 200

//Таймеры setTimeout, setInterval. Таймеры - это макрозадача
  //setTimeout - принимает: функцию колбэк, которую нужно запустить, время в миллисекундах, через которое эта функция должна быть вызвана, аргументы, которые нужно передать колбэку на вход.
  //для установки в таймер отложенного выполнения кода нужно передать функцию, а не вызывать её.
  function tellMeLater(name) {
    console.log(name);
  }
  setTimeout(tellMeLater, 1000, "Petr");
  //clearTimeout - отменяет таймер, созданный функцией setTimeout
  function logOut() {}
  let timer = setTimeout(logOut, 300000);   // через 300 секунд выкинем пользователя
  // если пользователь кликнул куда-то, сбросим таймер и будем ждать заново
  window.addEventListener('click', function () {
    clearTimeout(timer); //сбросим таймер
    timer = setTimeout(logOut, 300000); //будем ждать заново
  });
  //setInterval - устанавливает циклический таймер. Он позволяет вызывать колбэк много раз, через заданные промежутки времени
  setInterval(tellMeLater, 1000); //команда tellMeLater будет повторяться каждые 1000 миллисекунд
  //clearInterval - отменяет таймер, созданный функцией setInterval
  let interval = setInterval(checkEmail, 10000);
  window.addEventListener('blur', function () {   // Если пользователь переключил вкладку,
    clearInterval(interval); // удаляем таймер.
  })
  // Если пользователь вернулся на вкладку,
  window.addEventListener('focus', function() {
    interval = setInterval(checkEmail, 10000); // снова запускаем таймер.
  })

//Promise часть отдельного API, специально сделанного для работы с асинхронным кодом. Промис - это микрозадача
  //Промисы позволяют добавлять задачи в асинхронную очередь.
  //Для этого нужно дописать в коде ещё один then или catch.
  //Первые then и catch на странице получат те значения, которые мы передавали на вход функциям resolve и reject.
  //Все последующие — то, что возвращали предыдущие методы then и catch.
  const newPromise = new Promise(function (resolve, reject) {
      //newPromise - кастомный промис
      //можно и без reject
    const rand = Math.random() > 0.5 ? true : false;
    if (rand) {
      resolve('Запрос обработан успешно'); //метод resolve вернет все, что мы укажем в resolve, например, "Запрос обработан успешно"
      //resolve(data); //вернет объект data (например, промис) если data это результатом выполнения fetch
    } else {
      reject('Запрос отклонён'); //метод reject вернет все, что мы укажем в reject, например, "Запрос отклонён"
    }
  });
  newPromise
    .then(function (value) { // Если промис был обработан. (Первые then и catch)
      /* Параметр value хранит значение, переданное методу resolve при создании промиса, то есть просто строку "Запрос обработан успешно" */
      console.log(value);
    })
    .catch(function (value) { // Если промис был отклонён. (Первые then и catch)
      /* Здесь параметр value будет хранить то значение, которое было передано методу reject, то есть просто строку "Запрос отклонён" */
      console.log(value + ', нам жаль :(');
    })
    .finally(function () { // В любом случае
      console.log('Как бы там ни было — запрос мы в глаза видели');
    });
  //Все последующие — то, что возвращали предыдущие методы then и catch.
  //then(thirdAction) = then(secondAction) = then(firstAction)
  newPromise.then(firstAction).then(secondAction).then(thirdAction);
  //Если вы сразу хотите создать исполненный или отклонённый промис
  Promise.resolve('Этот промис исполнен')
    .then(function (value) {
      console.log(value); // "Этот промис исполнен"
    });
  Promise.reject('Этот промис отклонён')
    .catch(function (value) {
      console.log(value); // "Этот промис отклонён"
    });


//Валидация ValidityState и слущатель input
  //свойство validity — объект из 11 свойств с булевыми значениями:
  //valueMissing — принимает true, когда обязательное поле пустое;
  //typeMismatch — принимает true, когда ввели неправильные значения данных для атрибута type. Это круто работает в связке с type="email" и type="url";
  //tooLong — всегда false, потому что в современных браузерах невозможно ввести больше символов, чем указано в maxlength;
  //tooShort — принимает true, когда количество символов не превышает значение атрибута minlength.
  //patternMismatch - отвечает за проверку ввода регулярным выражением.
    //Если поле равно true, значит, введённый текст не прошёл проверку
  //valid - В нём находится итоговое решение проверки данных. Если во всех других 10 свойствах значения корректны, поле ввода валидно и свойство valid приобретает значение true
  const formElement = document.querySelector('.form');
  const formInput = formElement.querySelector('.form__input');
  formInput.addEventListener('input', function (evt) { // Слушатель события input - «Живая» проверка данных происходит одновременно с тем, как пользователь вводит в поле данные
    console.log(evt.target.validity.valid); //Выведем в консоль значение свойства validity.valid поля ввода,
    // на котором слушаем событие input
  });

  //Изменение сообщения об ошибке validationMessage
  //Чтобы показывать разный текст для разных ошибок валидации. Для этого нужно свойство validationMessage.
  //Свойство validationMessage есть у всех полей ввода. В нём записан стандартный текст сообщения об ошибке
  //Браузер показывает его по умолчанию, когда вводят некорректные данные
  const formElement = document.querySelector('.form');
  const formInput = formElement.querySelector('.form__input');
  const formError = formElement.querySelector(`.${formInput.id}-error`);
  const showInputError = (element, errorMessage) => { // Передадим текст ошибки вторым параметром
    element.classList.add('form__input_type_error'); //стили для класса невалидного input
    formError.textContent = errorMessage; // Заменим содержимое span с ошибкой на переданный параметр
    formError.classList.add('form__input-error_active');
  };
  const hideInputError = (element) => {
    element.classList.remove('form__input_type_error');
    formError.classList.remove('form__input-error_active');
    formError.textContent = ''; // Очистим ошибку
  };
  const isValid = () => {
    if (!formInput.validity.valid) {
      showInputError(formInput, formInput.validationMessage); // Передадим сообщение об ошибке вторым аргументом
    } else {
      hideInputError(formInput);
    }
  };
  formInput.addEventListener('input', isValid);

//Запросы
  //Метод fetch
  //Первый — обязательный — URL запрашиваемого ресурса
  //Второй аргумент — необязательный. Это объект options: method, headers и body — они отвечают за метод запроса, его заголовки и тело
  fetch('https://example.com')   //по умолчанию это GET
    .then((res) => { //в then пишем колбэк, т.е. функцию: () => {}
      console.log(res); // если всё хорошо, получили ответ
    })
    .catch((err) => { //в catch пишем колбэк
      console.log('Ошибка. Запрос не выполнен'); //либо console.error
    });

  //POST с options
  fetch('https://example.com/users', { //options {}
    method: 'POST',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      username: 'ivan'
    })
  });

  //Promise.all
  //Все запросы должны успешно выполнится
  //принимает на вход массив с промисами и выполняет записанный в then код, только когда все промисы вернулись со статусом «исполнен»
  const promiseA = fetch('https://example.com/users');
  const promiseB = fetch('https://example.com/users');
  Promise.all([promiseA, promiseB])
    .then(([resultA, resultB]) => console.log(resultA, resultB))
    .catch(console.error);

  //пример 2
  const promises = [firstPromise, secondPromise] //Создаём массив с промисами
  Promise.all(promises) //Передаём массив с промисами методу Promise.all
    .then((results) => {
      console.log(results); // ["Первый промис", "Второй промис"]
    });

  //Как передать данные на сервер
    //1. В теле запроса
    //2. В параметрах запроса
    //Их перечисляют прямо в URL после вопросительного знака
    //Имя параметра и его значение указывают друг за другом через знак равенства: name=value. Такие пары имя атрибута=значение разделяют амперсандами &:
    fetch('https://example.com/images/random?type=portrait&name=DorianGrey', {
      method: 'GET'
    });
    //3. Прямо в URL
    //Например, если картинке присвоен идентификатор, можно запросить его в URL и получить картинку
    fetch('https://example.com/images/ewfh23d832jnf2903', { // ewfh23d832jnf2903 — идентификатор картинки
      method: 'GET'
    });

//Методы JSON.stringify
  //делает из объекта строку JSON
  const songs = [
    {
      title: 'Вектора',
      artist: 'OZORA'
    }
  ];
  const songsJSON = JSON.stringify(songs);
  console.log(songsJSON);
  console.log(typeof songsJSON); // "string"

  //Метод JSON.parse
  //Преобразовывает JSON-строку (Строка должна быть JSON-совместимой) в объект JavaScript
  const songs = [
    {
      title: 'Вектора',
      artist: 'OZORA'
    }
  ];
  const songsJSON = JSON.stringify(songs);
  const songsObject = JSON.parse(songsJSON);
  console.log(typeof songsObject); // "object"
  console.log(songsObject[0].title); // "Вектора"

  //Метод res.json — асинхронный метод, тоже промис как и fetch
  //Метод json читает ответ от сервера в формате json и возвращает промис
  fetch('https://praktikum.yandex.ru')
    .then((res) => {
      return res.json(); // возвращаем результат работы метода и идём в следующий then
    })
    .then((data) => {
      console.log(data); // если мы попали в этот then, data — это объект
    })
    .catch((err) => {
      console.log('Ошибка. Запрос не выполнен');
    });

  //Ответ на запрос
  //2 — значит, запрос прошёл успешно; 200 OK;
  //3 — запрос был перенаправлен;
  //4 — с запросом что-то не так: ресурс не найден или у вас нет к нему доступа; 401 Unauthorized; 403 Forbidden; 404 Not Found;
  //5 — на сервере произошла какая-то ошибка. 500 Internal Server Error.

  //res.status - статус
  //res.statusText - сообщение статуса
  fetch('https://api.kanye.rest')
    .then(res => {
      console.log(res.status, res.statusText); // 200 OK
    });

  //res.ok
  //хранит в себе true, если ответ успешный (начинается с 2), и false — в любом другом случае
  fetch('https://api.kanye.rest')
    .then(res => {
      console.log(res.ok); // true
    });
  //пример 2
  const quoteElement = document.querySelector('div.quote');
  fetch('https://api.kanye.rest')
    .then((res) => {
      if (res.ok) {
        return res.json(); //или Promise.resolve()
      }
      return Promise.reject(`Что-то пошло не так: ${res.status}`); //отклоняем промис, чтобы перейти в блок catch, если сервер вернул ошибку
      //или Promise.reject()
    })
    .then((data) => {
      quoteElement.textContent = data.quote;
    })
    .catch((err) => {
      console.log(err); // "Что-то пошло не так: ..."
    });

  //Заголовки ответа, headers.get
  fetch('https://api.kanye.rest')
    .then((res) => {
      if (res.headers.get('Content-Type').contains('application/json')) {
        return res.json();
      }
    });

  //Тело ответа
  // res.json — разбирает JSON в объект, этот метод вы уже знаете;
  // res.text — разбирает тело как текст;
  // res.blob — разбирает тело ответа как бинарные данные: это нужно при получении файлов (изображений, видео, pdf-документов).
  fetch('https://api.kanye.rest')
    .then(res => res.text())
    .then((result) => {
      console.log(result);
    });





















//Регулярные выражения
  const userList = 'Маша, Петя, Катя, Лёша, Лера, Иннокентий, Влад';
  const innokentiy = /Иннокентий/g; // /.../ - литерал регулярного выражения
  userList.match(innokentiy);  //[ "Иннокентий" ]

  //Методы строк String.match
  //Нужен для поиска совпадений: им вы можете проверить, есть ли слово в тексте, и посчитать, сколько раз оно встречается
  //Если найти строку удалось, String.match вернёт массив с тем, что нашёл
  //Если символ найти не удалось, String.match вернёт null
  //Метод String.match можно настроить: например, заставить его считать все совпадения в тексте, а не только первое. Для такой настройки и нужны флаги
  const regex = /л/;
  const word = 'солнце';
  word.match(regex); // [ "л" ] — метод нашёл символ в строке
  //Если передать методу String.match регулярное выражение без флага g, полученному массиву будут определены дополнительные свойства
  const str = 'тро-ло-ло';
  const result = str.match(/ло/);
  result[0]; // "ло"
  result.index; // 4. индекс первого совпадения в строке
  result.input; // "тро-ло-ло". input содержит исходную строку

  //Методы регулярных выражений RegExp.test
  //Если совпадение найти удалось, RegExp.test вернёт true, иначе false
  const regex = /т/;
  const word = 'лестница';
  regex.test(word); // true — метод подтвердил, что в строке есть совпадение
  //Если установить флаг g, метод вернёт первое совпадение, а затем — запишет в свойство lastIndex регулярного выражения номер символа в тексте, на котором это совпадение произошло
  //Если запустить метод RegExp.test снова, он будет искать не с начала строки, а с того символа, на котором остановился в прошлый раз. То есть с записанного в свойство lastIndex:
  //RegExp.test обновляет свойство lastIndex после каждого вызова.
  const regex = /\w+@\w+\.\w+/g;
  const str = 'Stas Basov: stas-basov@yandex.ru, Telegramm: basov-stas';
  regex.test(str); // true
  regex.lastIndex; // 32 - номер символа, где было найдено совпадение
  // Вызовем метод RegExp.test ещё раз:
  regex.test(str); // false - поиск начался с 32 символа, поэтому совпадения найдены не были
  regex.lastIndex; // 0. предыдущий поиск не дал результатов, поэтому свойство lastIndex было сброшено до нуля

  //String.replace
  //Метод ищет в тексте совпадение с регуляркой, составляет какую-то новую строку из полученной и возвращает её нам
  const strObj = 'Пробел всегда нужно ставить после запятой ,а не до неё.';
  const regex = /\s,/g;
  strObj.replace(regex, ', '); // "Пробел всегда нужно ставить после запятой, а не до неё."

  //String.split
  const regex = /\n/im;
  `Мой дядя самых честных правил,
  И лучше выдумать не мог.`.split(regex);  //"Мой дядя самых честных правил,", "И лучше выдумать не мог."

  //Флаги (только для JS, в HTML не надо писать)
  //Флаг — символ, который стоит в регулярном выражении в самом конце (после слеша) и задаёт настройки поиска.
  //Всего их шесть: g, i, m, u, y, s.
  //В регулярном выражении флагов может быть несколько, и они могут идти в любом порядке.
    //Флаг g
    //Если установить флаг g, мы будем искать все совпадения, а не только первое
    const regex = /с/;
    const regexGlobal = /с/g;
    const word = 'искусство';
    word.match(regex); // [ "с" ]
    word.match(regexGlobal); // [ "с", "с", "с" ];

    //Флаг i
    //Если поставить флаг i, поиск не будет различать строчных и прописных букв
    const str = 'Вильгельм Конрад Рентген стал лауреатом Нобелевской премии в 1901 году.'
    const regex = /рентген/;
    const regexIgnore = /рентген/i;
    str.match(regex); // null
    str.match(regexIgnore); //[ "Рентген" ]

    //Флаг m
    //движок будет считать каждый перенос концом одной строки и началом другой
    const str = `Эта личность мне знакома! Знак допроса вместо тела.
    Многоточие шинели. Вместо мозга — запятая.`;
    const regex = /[А-Я]*\.$/gim;
    str.match(regex); // [ "тела.", "запятая." ]
    //Это работает и с шаблонными строками, и с обычными: в них движок будет считать началом и концом строки комбинации \n
    const regex = /^I got/gm;
    const str = 'I got, I got, I got, I got\n' +
      'I got power, poison, pain and joy\n' +
      'I got hustle, though, ambition, flow\n' +
    str.match(regex); // [ "I got", "I got", "I got" ]

  //Точка в выражении. В шаблоне регулярного выражения точка заменяет любой символ
  //Но у точки есть одна слабость: она не найдёт перенос строки.
  const str = `
    Не помню, как именно его зовут:
    то ли Сортини, то ли Сордини.
    Быть может, и Сардини, через «а».`;
  const regex = /С.р.ини/g; // Точки в регулярном выражении заменяют любой символ.
  str.match(regex); // [ "Сортини", "Сордини", "Сардини" ]

  //Спецсимволы https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/RegExp
  const str1 = 'yandex.ru/maps/';
  const regex1 = /\.ru/; // экранировали точку, движок будет искать только точки, а не любые символы
  const regex2 = /\/maps/; // экранировали слеш перед словом maps
  str1.match(regex1); // [ ".ru" ]
  str1.match(regex2); // [ "/maps" ]
  const str2 = 'C:\\'; // Чтобы найти обратный слеш, его тоже нужно экранировать
  const regex3 = /\\/; // экранировали слеш
  str2.match(regex3); // [ "\" ]

  //Спецсимвол \w
  //спецсимвол говорит движку искать любую цифру, латинскую букву или нижнее подчёркивание
  const str = 'Простите, я отправил старую версию файла диплом_финал_2_копия_3.docx. Не смотрите не неё. Высылаю вам актуальную диплом_финал_2_копия_4.docx';
  const regex = /диплом\wфинал\w\w\wкопия\w\w.docx/g;
  str.match(regex); // [ "диплом_финал_2_копия_3.docx", "диплом_финал_2_копия_4.docx" ]
  //Обратный класс: \W
  //\W - ищет всё что угодно: знаки вопроса, пробелы, слеши, кириллические символы, — но только не цифры, буквы базовой латиницы и нижние подчёркивания
  const str = `
    Даты основания некоторых IT-компаний:
    Yandex: 23.09.1997
    Apple: 01/04/1976
    IBM: 16-06-1911`;
  const regex = /\w\w\W\w\w\W\w\w\w\w/g; /* цифры в дате мы обозначили строчной \w, а разделители —
    заглавной \W. Разделитель это НЕ цифра, НЕ латинская буква и НЕ нижнее подчёркивание. */
  str.match(regex); // [ "23.09.1997", "01/04/1976", "16-06-1911" ]

  //Спецсимвол \d
  //Спецсимвол \d совпадает с любой цифрой
  const str = 'Владивосток 2000';
  const regex = /\d\d\d\d/g;
  str.match(regex); // [ "2000" ]
  //Обратный класс: \D
  //\D - ищет все не-цифры: буквы, пробелы, спецсимволы
  const someSimbol = /\D/g;
  const string = 'I was born in 1987';
  string.match(someSimbol);   // ["I", " ", "w", "a", "s", " ", "b", "o", "r", "n", " ", "i", "n", " "]

  //Спецсимвол \s
  //Спецсимвол \s ищет «пустоты» в тексте: пробелы, в том числе неразрывные, переносы строк и табуляции
  const str = 'Сдают паспорта,\n' +
    '              и я' +
    '                сдаю';
  const regex = /\s/g;
  str.match(regex).length; // 32 — Маяковский любил пробелы
  //Обратный класс: \S
  //ищет любые символы, только не пробелы, табуляции и переносы
  const str = 'Сдают паспорта,\n' +
    '              и я' +
    '                сдаю';
  const regex = /\S/g;
  str.match(regex).length; // 22 (буквы с запятыми)

  //Спецсимвол \b
  //Возвращаемся к спецсимволам. \b означает границу слова. Движок считает границей слова:
    // начало строки;
    // конец строки;
    // любой символ, кроме цифр, латинских букв и нижнего подчёркивания
  const string = 'sadness';
  string.match(/\bs/).index; // 0 — это первая буква s. спецсимвол указал границу левее неё, т. е. начало
  string.match(/s\b/).index; // 6 - а это последняя. спецсимвол указал границу правее неё, т. е. конец
  //Обратите внимание: любая нелатинская буква прочитывается движком как отдельное слово. Поэтому с кириллицей спецсимвол \b не работает.
  'A333HP99'.match(/\d\d\b/); //["99", index: 6, input: "A333HP99", groups: undefined]
  //Обратный класс: \S
  //ищет не конец слова: цифру, латинскую букву или нижнее подчёркивание. Таким образом, \B делает то же самое, что \w

  //Начало строки ^
  const regex = /^\d+/g;
  const newReg = /\d+/g;
  const str = '2001 год: Космическая одиссея, вышел в 1968 году';
  str.match(regex); // [ "2001" ];
  str.match(newReg); // [ "2001", "1968" ];
  //Конец строки $
  const regex = /\d+$/;
  const str = 'https://praktikum.yandex.ru/trainer/frontend-developer/lesson/45';
  str.match(regex); // ( ["45"] )
  //Перенос строки \n
  const str2 = 'Это утро, радость эта,\nЭта мощь и дня и света,'

  //Наборы
  //Чтобы создать набор, нужно перечислить подходящие символы в квадратных скобках
  //ищем все символы «а» и «б»:
  'барабан'.match(/[аб]/g); // [ "б", "а", "а", "б", "а" ]
  //шаблон ищет все дни весны
  const str = '14/03/2018';
  const regex = /\d\d\W0[345]\W2018/g; // этот шаблон ищет все дни весны
  str.match(regex);

  //Диапазоны
  //Диапазон — часть набора. Это два символа, разделённых дефисом
  const regex = /[м-р]/gi;
  'Марсианин'.match(regex); // [ "М", "р", "н", "н" ]
  //шаблон ищет все дни первого полугодия
  const str = '20/04/2019';
  const regex = /\d\d\W0[1-6]\W2019/g;
  str.match(regex); // [ "20/04/2019" ]

  //Наборы + Диапазоны
  const regex = /[a-z0-9\-]/gi; // все латинские буквы, все цифры и дефис
  const str = 'В Берлин я летал на boeing 737-800';
  str.match(regex).join(''); // "boeing737-800"

  //Кириллица
  //Ищем всю латиницу и всю кириллицу, а от знаков препинания избавляемся
  //в таблице символов "ё" стоит обособленно от других кириллических букв. Поэтому, чтобы не терять «ё», дописывайте её в набор:
  const regex = /[\wа-я\sё]/gi;
  const str = 'Yandex 2020. Ещё не вечер!';
  str.match(regex).join(''); // "Yandex 2020 Ещё не вечер"

  //Исключающие наборы и диапазоны
  //Чтобы сделать набор или диапазон исключающим, перед ним нужно поставить «шляпку» ^ (карет)
  const str = 'Оценки за четверть: 2 3 3 5 2 4 2 3 5';
  const regex = /[^1-3]/g;
  str.match(regex).join(''); // "Оценки за четверть:    5  4   5"
  //пусть шаблон выловит любые символы, кроме нижнего подчёркивания и заглавных латинских букв
  const cardholder = 'VASSiliy_PUPK1N';
  const forbidden = /[^A-Z\_]/g
  console.log(cardholder.match(forbidden));

  //Квантификаторы
  //От одного до бесконечности повторений — квантификатор +
  const str = 'Правильно писать «свиной», с одной «н»';
  const regex = /свин+ой/; // такое регулярное выражение найдёт оба варианта: и с «н», и с «нн»
  str.match(regex); // [ "свиной" ]

  //От нуля до бесконечности повторений — квантификатор *
  const exc = 'экскаватор';
  const esc = 'эскалатор';
  const regex = /эк*ска[вл]атор/; // буква "к" может встречаться, а может и не встречаться
  exc.match(regex); // [ "экскаватор" ]
  esc.match(regex); // [ "эскалатор" ]

  //Необязательный символ — квантификатор ?
  const regex = /favou?rite/g; // делает букву "u" необязательной и будет искать оба варинта написания favourite и favorite
  const str = 'favourite for favorite';
  str.match(regex); // ["favourite", "favorite"]

  //Контроль повторов — квантификатор {}
  const regionCode = /\d{3}/;
  const phoneNumber = 'Мой номер телефона: +7(999)123-12-21';
  phoneNumber.match(regionCode); // [ "999" ]
  //Можно также указывать не точное количество повторений, а диапазон
  const str = 'столько, стооолько и вот стооооооооолько';
  const regex = /сто{2,5}лько/;
  str.match(regex); // [ "стооолько" ]. в слове "стооооооооолько" повторов "о" больше 5
  //Верхнюю границу числа повторений можно не указывать
  const someSymbol = /a{1,}/g;
  const    str = 'alohaa';
  console.log(str.match(someSymbol)); // ["a", "aa"]

//Drag and Drop
  //https://practicum.yandex.ru/learn/frontend-developer/courses/bd56befd-d26d-4628-ab73-87f417e66764/sprints/178919/topics/55ccaeb2-1bb0-4412-b8f8-7044b848fb21/lessons/1807853d-4e56-471c-9240-e71fd8a3d97a/

//WebSockets
  //https://practicum.yandex.ru/learn/frontend-developer/courses/bd56befd-d26d-4628-ab73-87f417e66764/sprints/178919/topics/55ccaeb2-1bb0-4412-b8f8-7044b848fb21/lessons/2bd72165-0724-4eea-ba18-40a48498c66b/

//Состояние на всех уровнях
  //Распределённое состояние, потому что стейт распределён по всему приложению, а не хранится где-то в глобальном объекте
  const Counter = () => {
    const [state, setState] = useState<number>(0);
    const increment = () => {
      setState(prevState => prevState + 1);
    };
    return <div>
      <p>Ваше значение: {state}</p>
      <button onClick={increment}>Увеличить</button>
    </div>
  };
  export default function App() {
    return <div>
      <Counter /> //у каждого Counter свой state
      <Counter />
    </div>
  }

  //React Context
  //Создает глобальный контекст
  //Этот способ хранения стейта подразумевает его создание и последующую передачу наследникам, но не привычным способом, то есть не через пропсы.
  //Созданный стейт на уровне всего приложения при изменении будет запускать перерендер всего приложения. То есть при изменении стейта в родительском компоненте запускается перерендер всех дочерних.


  //Библиотека Redux
  //В Redux удобно хранить данные, которые часто изменяются, потому что он не вызывает перерендер всего дерева элементов.
  //Данные хранятся в стейтах в слайсах

  //Кэширование запросов
  //библиотека @tanstack/react-query.
  import {QueryClient} from '@tanstack/react-query'
  import axios from 'axios';
  const queryClient = new QueryClient()
  export default function App() {
    return (
      <QueryClientProvider client={queryClient}>
        <Example />
      </QueryClientProvider>
    )
  }

  //хук useQuery и три состояния из него:
    // isPending — состояние загрузки запроса.
    // error — объект ошибки, если запрос ответил ошибкой.
    // data — результат нашего запроса.
    //queryFn — функцию запроса для получения данных
    //queryKey — список параметров запроса
  function Example() {
    const { isPending, error, data } = useQuery({
      queryKey: ['todos', id], //(имя сущности, todos и id сущности)
        //Так @tanstack/react-query поймёт, что:
        //Если id новый — необходимо сделать запрос.
        //Если id старый — нужно искать запрос в кэше.
      queryFn: () =>
        fetch(`https://api.github.com/repos/todos/${id}`).then((res) =>
          res.json(),
        ),
    })
    if (isPending) return 'Loading...'
    if (error) return 'An error has occurred: ' + error.message
    return (
      <div>
        <h1>{data.name}</h1>
        <p>{data.description}</p>
        <strong>👀 {data.subscribers_count}</strong>{' '}
        <strong>✨ {data.stargazers_count}</strong>{' '}
        <strong>🍴 {data.forks_count}</strong>
      </div>
    )
  }

  //Мутации и инвалидация
  //хук useMutation
  useMutation({
    mutationFn: addTodo,
    onError: (error, variables, context) => { // Будет запущен при ошибке промиса
    },
    onSuccess: (data, variables, context) => { // Будет запущен при успехе промиса
    },
    onSettled: (data, error, variables, context) => { // Будет запущен при ошибке или успехе промиса
    },
  })
  //пример
  function App() {
    const mutation = useMutation({
      mutationFn: (newTodo) => { //функция, которая должна сделать мутацию, то есть изменить наши данные
        return axios.post('/todos', newTodo)
      },
    })
    //Хук useMutation возвращает нам объект с полями:
    // isPending — состояние загрузки запроса;
    // isError — состояние ошибки;
    // isSuccess — состояние успеха;
    // mutate — функция мутации, которая под капотом запустит mutationFn из параметров хука и сделает еще несколько важных действий.
    return (
      <div>
        {mutation.isPending ? (
          'Добавление задачи...'
        ) : (
          <>
            {mutation.isError ? (
              <div>Ошибка: {mutation.error.message}</div>
            ) : null}
            {mutation.isSuccess ? <div>Задание добавлено!</div> : null}
            <button
              onClick={() => {
                mutation.mutate({ id: new Date(), title: 'Сделать дело' })
              }}
            >
              Создать дело
            </button>
          </>
        )}
      </div>
    )
  }

  //Процесс, когда мы явно указываем, что наш кэш стал неактуален, называется инвалидацией.
    //метод invalidateQueries, который делает какие-то комбинации queryKey инвалидными, тем самым заставляет клиент ходить за данными на сервер, а не тянуть их из кэша
    //У invalidateQueries есть параметр queryKey. На вход он принимает список параметров, с которых должен начинаться queryKey инвалидированных запросов.
  queryClient.invalidateQueries({
    queryKey: ['todos', { type: 'done' }],
  })
  // Запрос будет инвалидирован
  const todoListQuery = useQuery({
    queryKey: ['todos', { type: 'done' }],
    queryFn: fetchTodoList,
  })
  // Запрос НЕ будет инвалидирован, потому что в нем нет { type: 'done' }
  const todoListQuery = useQuery({
    queryKey: ['todos'],
    queryFn: fetchTodoList,
  })

  //Чтобы применить invalidateQueries на практике, нужно совместить этот метод с хуком useMutation, как это показано ниже:
  const queryClient = useQueryClient()

  const mutation = useMutation({
    mutationFn: addTodo,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['todos'] })
    },
  })

//Продвинутая навигация
  //Loader
  const fakeGetSong = () => {
    return new Promise((resolve) => {
      setTimeout(() => resolve({ title: "Home title" }), 30000);
    });
  };

  const router = createBrowserRouter([
    {
      path: "/",
      element: <Home />,
      loader: ({ params }) => {
        return fakeGetSong(params.homeId);
      },
    },
  ]);
  //хук useLoaderData
  //компонент Await
