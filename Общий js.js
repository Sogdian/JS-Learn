/*Ванильный js ------------------------------
Типы данных:
  примитивы (элементарные типы), у которых есть только значение:
    number — числа: целые и с точкой
    string — строки
    boolean — логические, или булевы, значения: true — «истина» и false — «ложь»
    undefined — undefined; - Значение не определено
    массивы - для хранения однородных элементов, хранит последовательность значений, и порядок этих значений важен. сложные, или составные, типы данных
    функции -
    null - Значения нет
  объекты, имеющие свойства пары: «ключ + значение»:
    объекты - состоит из множества пар «ключ-значение», порядок этих пар не важен; сложные, или составные, типы данных
Составные типы содержат не одно, а несколько значений

Операция сложения — бинарная, так как в ней два операнда.
    Существуют и унарные операции, с одним операндом, и тернарные операции, с тремя операндами.
    Приоритет операторов https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Operator_Precedence

Конкатенацией - сложение строк (“catenate” — «связывать в одну цепь».)
Зарезервированные слова https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Lexical_grammar#%D0%9A%D0%BB%D1%8E%D1%87%D0%B5%D0%B2%D1%8B%D0%B5_%D1%81%D0%BB%D0%BE%D0%B2%D0%B0
*/

//Переменные
  let user = 'John', age = 25, message = 'Hello'; //в одной строке

console.log(21 + "2"); //"212"
  console.log(2 ** 3); // возведение в степень. выведет в консоль 8
  console.log((2 + 2) / 2);
  console.log(4 * 3 ** 2); // = 4 * 3 в степени 2
  console.log(document.querySelector('.page'));
  console.log('вино' + 'град'); //Конкатенация
  console.log('Время, мин: ' + 50); // = 'Время, мин: 50'. Плюс может быть знаком сложения или конкатенации, но так как один из операндов — строка, то сложение не подходит. Поэтому число 50 приводится к строке '50' и склеивается со строкой 'Время, мин: '.
  console.log('2' * 50); // = 100. Звёздочка — это знак умножения, со строками она не используется. Поэтому JavaScript пытается превратить строку '2' в число, и ему это удаётся. Затем числа 2 и 50 перемножаются, и получается 100.
  console.log("Республика Кот-д'Ивуар");
  console.log('Никогда не говори "никогда" — можешь ошибиться.');
  console.log(`Это - шаблонная строка,
  несколько строк`); //Шаблонные строки, ограничиваются с обеих сторон обратными кавычками ``
  console.log(`${2 + 5} раз отмерь - ${value} отрежь`); // "7 раз отмерь - 1 отрежь"
  let merry = true;
    console.log(!merry); // false

//Символы Symbol. Фактически их можно воспринимать как гарантированно уникальное значение, предоставляемое JavaScript.
  //Для его создания нужно явно обратиться к типу по имени Symbol и в качестве аргумента передать подпись
  let id = Symbol('id');
  console.log(id); //Выведет Symbol(id)

//Строки
  console.log('эспрессо'[0]); // "э". получить символ из строки по его индексу

//Числа
  //После объявления эти числа можно использовать в вычислениях наряду с десятичными, но при выводе они будут автоматически сконвертированы в десятичную систему
  let hex = 0xFF; //255
  let binary = 0b011110; //30
  let num = 1234; //это десятичное число

/* Мат операции
  Остаток от деления %
    1 % 3: 1. Поскольку 1 не делится на 3 нацело, остаток равен самому числу, то есть 1. Поэтому результат равен 1.
    2 % 5: 2. Поскольку 2 не делится на 5 нацело, остаток также равен самому числу, то есть 2. Поэтому результат равен 2.
    3 % 3: 0. В данном случае 3 делится на 3 нацело (1 раз), поэтому остаток равен 0. Поэтому результат равен 0. */

//Неявное преобразование типов
  //Приведение к строке
  console.log(100 + '500'); // "100500"
  console.log(1 + ''); // "1"
  console.log(undefined + ''); // "undefined"

  //Приведение к числу
  console.log(null >= 1); // false
  console.log('451' < 452); // true
  //Унарные операторы приводят нечисловые значения после «+, -, /, *» к численному типу. Так +'33' вернёт число 33, +'-77' вернет число -77.
  //Если операторы сложения и унарный плюс стоят рядом, они не помешают друг другу
  console.log(67 + +'33'); // 100
  console.log('3' - 1); // 2
  console.log('4' / 4); // 1
  console.log('2' * 2); // 4
  //Но сложения со строкой — будет воспринято как конкатенация
  console.log('4' + 4); // 44 - здесь выполнится конкатенация

  //Приведение к булевым значениям
  //В круглых скобках условия if любые данные всегда приводятся к логическому типу
  //Если элемента с классом username на странице нет, в переменную usernameElement запишется null.
  //В круглых скобках условной конструкции null приводится к логическому типу и становится false. Поэтому тело условия if выполнено не будет
  const usernameElement = document.querySelector('.username');
  if (usernameElement) {
    console.log('Привет, ' + usernameElement.textContent);  }

//Явное преобразование типов
  //Приведение к строке
  const numberToString = String(2); // "2"
  const nanToString = String(NaN); // "NaN"
  const undefinedToString = String(undefined); // "undefined"
  const nullToString = String(null); // "null"
  const booleanToString = String(true); // "true"
  num.toString(1); // Выведет строку: 1 (String)
  num.toString(16); //4d2 это уже шестнадцатеричное число
  num.toString(2); //10011010010 а вот так двоичное

  //Приведение к числу
  const stringToNumber = Number('2'); // 2
  const nullToNumber = Number(null); // 0
  const anotherStringToNumber = Number('счастье не за горами'); // NaN
  const undefinedToNumber = Number(undefined); // NaN
  num.parseInt('17');   // Вернёт 17.
  num.parseInt('10001', 2); // Вернёт 17. вторым аргументом в parseInt мы передаём именно систему исчисления, из которой мы преобразуем исходное число.
  num.parseInt('11', 16);   // Вернёт 17

  //Приведение к булевым значениям
  Boolean(2) // true
  Boolean(0) // false
  Boolean('') // false
  Boolean(NaN); Boolean(null); Boolean(undefined) // false
  Boolean('Непустая строка'); // true
  Boolean({}); // true
  Boolean([]); //true

//Определение типа данных. Оператор typeof
  typeof 10; // "number"
  typeof 'Hello World!'; // "string"
  typeof true; // "boolean"
  typeof undefined; // "undefined" - Значение не определено
  typeof (10 + 5) // "number". Скобки ставят, когда нужно определить тип целого выражения
  typeof NaN; // "number". "Not a Number" имеет тип данных "number"
  typeof null; // "object"
  typeof function () {} // "function". Хоть такого типа и нет.

  console.log(typeof(input.value));

//Date
  //Если параметры метода не указаны, то он использует настройки браузера для локализации даты.
  //getDay() - выяснить день недели для указанной даты в виде целого числа от 0 до 6.
    //У метода есть одна особенность началом недели он считает воскресенье, то есть число 0 соответствует воскресенью, 1 — это понедельник, 2 — вторник, 6 — суббота
  const date = new Date('2023-03-05');
  const options = { day: "numeric", month: "short" }; //вывести день числом, а месяц в сокращённом формате
    const options2 = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' }; //В консоли отобразится "воскресенье, 5 марта 2023 г."
    //Для форматирования даты на русском языке используется локаль «ru».
  new Date(date).toLocaleDateString('ru-RU', options); //date - объект класса Date

  const formatDate = (date) => new Date(date).toLocaleDateString("ru", {
    day: "numeric",
    month: "short",
  }); //Функция formatDate вернёт дату в виде 5 мар.
  const getWeekday = (date) => new Date(date).toLocaleDateString("ru", {
    weekday: "short"
  }); //Функция getWeekday вернёт дату в виде первых двух букв для недели — вс.

//Формат JSON, метод toJSON
  //JSON.stringify - для преобразования объектов в JSON
  let student = {
    name: 'John',
    age: 30,
    courses: ['html', 'css', 'js'],
  };
  let json = JSON.stringify(student);
  alert(json); //выведет объект в формате JSON

  //JSON поддерживает следующие типы данных
  alert( JSON.stringify(1) ) // 1. // число в JSON остаётся числом
  alert( JSON.stringify('test') ) // "test".   // строка в JSON по-прежнему остаётся строкой, но в двойных кавычках
  alert( JSON.stringify(true) ); // true
  alert( JSON.stringify([1, 2, 3]) ); // [1,2,3]

  //JSON.parse - для преобразования JSON обратно в объект


//Логические операторы
  //Оператор логическое НЕ (!)
  //Если поставить ! перед небулевым значением, движок JS сначала приведёт тип к булю, а затем изменит значение на противоположное
  !false; // true
  !'Непустая строка' // false
  !!true; // true

  //Оператор логическое ИЛИ (||)
  //true || true - возвращает true, если хотя бы один из операндов равен true.
  //оператор || не различает false, 0, пустую строку "" и null/undefined. Для него они все одинаковы, т.е. являются ложными значениями.
  let condition =  0 || NaN || 'строка' || false;  // Значение переменной condition: 'строка'

  //Оператор логическое И (&&)
  //true && true - возвращает значение true, если оба операнда равны true.
  //сокращенное вычисление логического выражения в реакте
  <div> { isFinished && <Modal /> } </div> //если isFinished = true, то вызовется <Modal />, Если же isFinished равно false, то выражение вернёт false и <Modal /> не вызовется
  //Если поставить && между правдивыми условиями, оператор вернёт последнее из них:
  console.log(2 * 2 === 4 && 5 < 6 && 'Каждый может стать'); // 'Каждый может стать'
  //Если среди условий есть ложные, && вернёт из них первое ложное:
  console.log(2 * 2 === 4 && undefined && 'Каждый может стать'); // undefined

  //Оператор строгого равенства, тут нет приведения типов. https://htmlacademy.ru/courses/209/run/5
  'a' === 'a'; // Результат: true
  'a' !== 'a'; // Результат: false
  //оператор нестрогого равенства, тут есть приведение типов
  'a' == 'a'; // Результат: true
  //оператор нестрогого неравенства
  'a' != 'a';

  //Приоритетность операторов https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence#table
  //сначала выполняется логическое НЕ, потом И, а затем — ИЛИ
  //Операции в скобках выполняются первыми
  const optimism = !'Жить' && !'Быть' || 'Жить и быть';
  //Сначала !'Жить' → false, потом !'Быть' → false, затем false && false → false и наконец false || 'Жить и быть' → 'Жить и быть'.
  console.log(optimism); // "Жить и быть". сначала выполняется !, потом &&, затем ||

  //Пример
    function checkTheCar (distance, ownersNumber, crushed) {
      if (distance <= 100000) { // проверяем пробег
        if (ownersNumber === 1) { // 1 владелец по ПТС?
          if (crushed === false) { // не битая?
            return true;
          }
          else return false;
        }
        else if (ownersNumber === 2) { // Владелец не 1? Тогда может 2?
          if (crushed === false) { // не битая?
            return true;;
          } else return false
        } else return false;
      } else return false;
    }

  //Сравнение чисел - сравнивает два объекта по полю economy.
  //Если значение поля economy у объекта a меньше, чем у объекта b, то функция возвращает отрицательное число (-1) и т.д.
  function compareTicketsByEconomyPrice(ticket1, ticket2) {
    if (ticket1.economy < ticket2.economy) {
      return -1;
    } else if (ticket1.economy > ticket2.economy) {
      return 1;
    } else {
      return 0;
    }
  }
  //Или тоже самое в более лаконичной форме:
    [...tickets].sort((a, b) => a.date > b.date ? 1 : -1); //Отсортируйте данные по возрастанию даты. Перед тем как сортировать данные, нужно создать их копию через [...tickets]

  //Сравнение строк - сравнение будет производиться в соответствии с лексикографическим порядком символов (сравниваются символьные коды)
  function compareStrings(a, b) {
    const stringA = a.toLowerCase();
    const stringB = b.toLowerCase();
    if (stringA < stringB) {
      return -1;
    }
    if (stringA > stringB) {
      return 1;
    }
    return 0;
  }
    //Прямое сравнение для строк, которые содержат символы кириллицы, может дать неправильный результат. Универсальный способ сравнения строк — метод localeCompare(). Метод localeCompare() сравнивает две строки в соответствии с локалью (языком), учитывая правила сортировки этого языка, и возвращает целое число, которое указывает, какая строка должна быть отсортирована перед другой строкой. Пример сортировки массива строк по алфавиту:
    const fruits = ['яблоко', 'банан', 'арбуз', 'груша'];
    fruits.sort((a, b) => a.localeCompare(b));
    console.log(fruits); // ["арбуз", "банан", "груша", "яблоко"]
    //Добавим строки со «сложными» символами в массив:
    const fruits = ['яблоко', 'банан', 'арбуз', 'груша', 'ёжик', 'йогурт'];
    fruits.sort((a, b) => a.localeCompare(b));
    console.log(fruits); // ['арбуз', 'банан', 'груша', 'ёжик', 'йогурт', 'яблоко']
    fruits.sort((a, b) => a > b ? 1 : -1);
    console.log(fruits); // ['арбуз', 'банан', 'груша', 'йогурт', 'яблоко', 'ёжик']

//Операторы нулевого слияния и присваивания: '??', '??='
  //Оператор нулевого слияния (??)
  //Результат выражения a ?? b будет следующим:
    //если a определено, то a (т.е. оператор ?? возвращает первый аргумент, если он не null/undefined)
    //если a не определено, то b (т.е. иначе второй)
    let res = a ?? b //= (a !== null && a !== undefined) ? a : b;

  let user;
  alert(user ?? "Аноним"); // Аноним (user не существует)
  let user = "Иван";
  alert(user ?? "Аноним"); // Иван (user существует)

  //Важное различие между ними заключается в том, что:
    // || возвращает первое истинное значение.
    // ?? возвращает первое определённое значение.
    let height = 0;
    alert(height || 100); // 100
    alert(height ?? 100); // 0

  //Оператор нулевого присваивания (??=)
  //проверить, равна ли переменная null или undefined, и если это так — присвоить этой переменной какое-либо другое значение
  x ??= y //Оператор ??= присвоит x значение y только в том случае, если x не определено (null/undefined).


//Условия if else
  //блоки if else нельзя использовать в JSX-выражениях в фигурных скобках.
  const a = 5, b = 10;
  let max;
  if (a > b) {
    max = a;
  } else {
    max = b;
  }

//Методы поиска в строке
  //Поиск по строке. Метод indexOf. Метод indexOf ищет символ в строке и возвращает его индекс
  //indexOf чувствителен к регистру
  'Яндекс.Практикум'.indexOf('Я'); // 0
  'эспрессо'.indexOf('c'); // 1. Если таких символов в строке несколько, метод вернёт индекс первого из них
  'эспрессо'.indexOf('к'); // -1. Если символа в строке нет, indexOf вернёт -1
  //indexOf может найти и комбинацию символов. При этом вернётся индекс первого символа из последовательности
  const blok = 'Ночь, улица, фонарь, аптека';
  blok.indexOf('фонарь'); // 13.

//Поиск в начале и конце строки. Методы startsWith и endsWith
  //Метод startsWith сравнивает начало строки с переданной ему подстрокой
  'Вендетта'.startsWith('В'); // true
  'Родина'.startsWith('Картинка в букваре'); // false

  //Метод endsWith делает всё то же самое, только с концом строки
  const theRealEnd = 'Это ещё не конец';
  theRealEnd.endsWith('конец'); // true

//Управление регистром. Методы toLowerCase и toUpperCase
  'Включите Caps Lock'.toLowerCase(); // "включите caps lock"
  'Выключите Caps Lock'.toUpperCase(); // "ВЫКЛЮЧИТЕ CAPS LOCK"

//Превращение строки в массив. Метод split
  //Метод split принимает на вход один аргумент — разделитель. Он показывает, где заканчивается один элемент массива и начинается следующий
  'Пришёл. Увидел. Победил.'.split(' '); // ["Пришёл.", "Увидел.", "Победил."]
  'Пришёл. Увидел. Победил.'.split('. '); // ["Пришёл", "Увидел", "Победил."]

//Извлечение части строки. Метод slice
  //Метод slice возвращает часть строки. На вход он принимает два аргумента — с какого индекса начинать отсчёт и на каком закончить
  //Второй аргумент необязательный: если его не указать, slice() вернёт все символы от заданного в первом аргументе до конца строки
  'Не прислоняться'.slice(6, 10); // "слон"
  'Яндекс.Практикум'.slice(7); // "Практикум"

//Объект Math и его методы
  // округляет переданное число «вниз»
  Math.floor(9.99); // 9
  // округляет «вверх»
  Math.ceil(9.01); // 10
  // округляет до ближайшего целого
  Math.round(9.51); // 10
  // возвращает наибольшее из переданных чисел
  Math.max(1, 2, 3, 4, 5); // 5
  // возвращает наименьшее из переданных чисел
  Math.min(1, 2, 3, 4, 5); // 1
  // возвращает случайное число от 0 включительно до 1 не включительно
  Math.random(); // 0.31764219954126016

//Работа с дробной частью. Функция parseInt
  //Функция parseInt приводит переданный аргумент к целому числу.
  //Она читает аргумент слева направо, если встречает не цифру, останавливается и возвращает всё, что прочитала до этого
  //Если первый символ передаваемой строки не цифра, parseInt вернёт NaN:
  parseInt('37 лет, 8 месяцев и 10 дней'); //37
  parseInt('38 попугаев'); //38
  //Второй аргумент parseInt — система счисления, в которой число передаётся функции
  parseInt('100', 10); // 100. Чаще всего вам нужна десятичная система. Явно указывайте её, чтобы избежать неожиданных результатов.
  parseInt('100', 2); // 4 (100 в двоичной системе)

//Функция parseFloat
  //Функция parseFloat работает аналогично parseInt, только выделяет не целое число, а число с плавающей точкой
  parseFloat('36.6'); // 36.6
  parseFloat('36.6 нормальная температура человека '); // 36.6

//Проверка на принадлежность к целым числам. Метод Number.isInteger
  //Метод Number.isInteger принимает число как аргумент и проверяет, целое оно или дробное
  const eightAndAHalf = 8.5;
  Number.isInteger(eightAndAHalf); // false



/* Массивы
  в массиве можно хранить любые данные: строки, булевы значения, числа и даже другие массивы.
  если в массиве нет элемента под тем номером, под которым мы записываем, то этот элемент будет создан */
  let phrases = []; //пустой массив
  let numbers = [1, 2, 3, 4, 5];
      numbers[numbers.length] = 7; //добавить новый элемент в конец массива
  let aliExpress = [1, 2, 3].length //длина массиыв = 3 элемента

  let guest = "Jane";
  let admin = "Pete";
  [guest, admin] = [admin, guest]; //мы создаём временный массив из двух переменных и немедленно деструктурируем его в порядке замены
  alert(`${guest} ${admin}`); //Pete Jane

  const results = new Array(size); //size - размер массива. У этого массива задана длина, но он не будет заполнен элементами. Для элементов создаются «ячейки» — слоты
    const results = new Array(size).fill(value); //fill - для заполнения слотов пустого массива

  const count = 5;
    const results = Array.from({length: count}, (_,i) => i * 2); //Где size — это желаемый размер массива, i — значение, которое мы добавляем в массив.
      //Метод from создаёт массив из любого объекта, похожего на массив. Здесь мы создаём новый массив с помощью метода Array.from()
    console.log(results)

  const count = 5;
    const results = [...Array(count)].map((_, i) => i * 2); //Ещё один способ заполнить «разреженный» массив — создать его копию spread-оператором
    console.log(results)

  /*Шпаргалка по методам массивов
  1	concat()	Объединяет массивы и элементы
  2	push()	Добавляет элементы в конец массива
  3	pop()	Удаляет последний элемент массива и возвращает его значение
  4	unshift()	Добавляет элементы в начало массива
  5	shift()	Удаляет первый элемент массива и возвращает его значение
  6	slice()	Копирует часть массива и создаёт из неё новый массив
  7	splice()	Удаляет часть элементов, а на их место ставит новые
  8	forEach()	Перебирает элементы, выполняя для каждого какой-то код
  9	map()	Создаёт новый массив, получая каждый элемент из уже имеющегося массива
  10	filter()	Создаёт новый массив, выкидывая из исходного элементы по заданным правилам
  11	some()	Проверяет, есть ли в массиве хоть один элемент, соответствующий заданному правилу
  12	every()	Проверяет, все ли элементы массива соответствуют заданному правилу
  13	find()	Проверяет, есть ли в массиве определённый элемент
  14	reduce()	Сводит массив к какому-то одному значению
  15	sort()	Сортирует  */

  //Добавление элементов. Метод concat
  //Метод concat не меняет структуру начального массива, а возвращает новый
  const toDoList = ['Посадить', 'Построить'];
  const toDoListUpdated = toDoList.concat('Вырастить', 'Прибраться');
  console.log(toDoListUpdated);  //["Посадить", "Построить", "Вырастить", "Прибраться"];
  //Как аргумент можно передать и другой массив — его элементы будут скопированы и добавлены в новый массив
  const moscowAttractions = ['Кремль', 'Третьяковская галерея'];
  const spbAttractions = ['Эрмитаж', 'Мариинский театр'];
  const russiaAttractions = moscowAttractions.concat(spbAttractions);

  //Преобразование массива в строку. Метод join
  //с исходным массивом ничего не произошло
  //Если не передать join аргумент, элементы в строке будут перечислены через запятую
  const bremenMusicians = ['Кот', 'Пёс', 'Трубадур', 'Осёл', 'Петух'];
  console.log(`Представляем музыкантов: ${bremenMusicians.join(', ')}`); // "Представляем музыкантов: Кот, Пёс, Трубадур, Осёл, Петух"

  //Добавление элемента: метод push
  //Метод push добавляет переданные ему аргументы в конец массива
  const emeraldCityHeroes = ['Лев'];
  emeraldCityHeroes.push('Элли');
  console.log(emeraldCityHeroes); // ["Лев", "Элли"]

  //Удаление элемента: метод pop
  //Метод pop удаляет последний элемент массива. Если массив пуст, pop вернёт undefined
  const insects = ['Бабочка', 'Комар'];
  console.log(insects.pop()); // "Комар". Метод возвращает значение удалённого элемента
  console.log(insects); // ["Бабочка"]

  //Удаление первого элемента: метод shift
  const italyCities = ['Помпеи', 'Рим', 'Неаполь'];
  const volcanoEruption = italyCities.shift(); // метод shift() возвращает удалённый элемент
  console.log(volcanoEruption); // "Помпеи"

  //Добавление элемента в начало массива: метод unshift
  //Метод unshift добавляет элементы в начало массива. Их передают через запятую
  const queue = ['Рабочие'];
  queue.unshift('Пенсионеры');
  console.log(queue);  //["Пенсионеры", "Рабочие"]
  //Метод unshift изменит исходный массив и напишет, сколько элементов в новом массиве
  const queue = ["Пенсионеры", "Инвалиды", "Рабочие", "Школьники", "Студенты"];
  console.log(queue.length); // 5
  console.log(queue.unshift('Мне только спросить')); // 6

  //Получение части массива: метод slice. Исходный массив при этом не изменяется
  //Метод slice копирует часть массива и делает из неё новый массив. Он принимает на вход два аргумента:
    //индекс элемента, с которого нужно начать копирование (включительно);
    //индекс элемента, на котором нужно остановиться (не включительно)
  //Второй аргумент можно не указывать. Тогда скопированы будут все элементы до конца
  const months = ['Январь', 'Февраль', 'Март', 'Апрель', 'Май', 'Июнь', 'Июль', 'Август', 'Сентябрь', 'Октябрь', 'Ноябрь', 'Декабрь'];
  const spring = months.slice(2, 5); //начиная с индекса 2 ("Март") и до, но не включая индекс 5 ("Июнь")
  console.log(spring); // ["Март", "Апрель", "Май"]
  //Можно передавать как аргумент и отрицательные числа. Тогда индекс будет считаться с конца массива
  //начиная с четвёртого элемента с конца и до первого с конца (не включительно)
  const autumn = months.slice(-4, -1);
  console.log(autumn); // ["Сентябрь", "Октябрь", "Ноябрь"]
  //Можно вызывать slice вообще без аргументов. Получится новый массив, состоящий из всех элементов исходного
  const months2 = months.slice();
  console.log(months2); //['Январь', 'Февраль', 'Март', 'Апрель', 'Май', 'Июнь', 'Июль', 'Август', 'Сентябрь', 'Октябрь', 'Ноябрь', 'Декабрь'];

  //Замена части элементов массива: метод splice
  const week = ['Понедельник', 'Вторник', 'Среда', 'Четверг', 'Пятница', 'Суббота', 'Воскресенье'];
  const removedItems = week.splice(0, 5, 'Воскресенье', 'Суббота', 'Воскресенье', 'Суббота', 'Воскресенье'); // начиная с индекса 0 удалим пять элементов и вставим на их место другие пять
  console.log(removedItems); // ["Понедельник", "Вторник", "Среда", "Четверг", "Пятница"]
  console.log(week); // ["Воскресенье", "Суббота", "Воскресенье", "Суббота", "Воскресенье", "Суббота", "Воскресенье"]
  //Новые значения добавлять необязательно — можно удалить существующие
  week.splice(2, 1); // ["Среда"]
  console.log(week); //['Понедельник', 'Вторник', 'Четверг', 'Пятница', 'Суббота', 'Воскресенье'];
  //И наоборот. Можно ничего не удалять — только добавить новые элементы
  week.splice(2, 0, "Земля"); // []
  console.log(week); // ['Понедельник', 'Вторник', 'Земля', 'Среда', 'Четверг', 'Пятница', 'Суббота', 'Воскресенье'];

  //Array.from. создаёт массив из «массивоподобного» объекта
  const posts = content.querySelectorAll('.post');
  const postsArray = Array.from(posts); // такой вызов вернёт полноценный массив

  //Обход массива: метод forEach
  //В качестве аргумента forEach принимает функцию. Она будет вызвана на каждом элементе массива поочерёдно
  //Но с forEach нельзя использовать директивы continue и break
  //Метод forEach нужен, когда мы хотим просто пройтись по массиву и для каждого элемента что-то сделать
  const how = ['быстрее', 'выше', 'сильнее'];
  how.forEach(function (item) {
    console.log(item + '.'); // быстрее выше сильнее
  });
  //пример с NodeList
  const elements = document.querySelectorAll('.text');
  elements.forEach((item) => {
    item.classList.add('text_is-active');
  });

  //Создание одного массива из другого: метод map
  //Метод map создаёт новый массив на основе существующего.
  //В качестве аргумента map, как и forEach, принимает функцию.
  //Эта функция должна вернуть значение, которое станет элементом нового массива
  //Метод map нужен, когда мы хотим создать новый массив из старого и преобразовать его элементы
  const firstArr = [0, 1, 2, 3, 4];
  const secondArr = firstArr.map(function (item) { // Берём каждый элемент массива
    return item * item; //функция должна вернуть значение, которое станет элементом нового массива (пример, возводим каждый элемент в квадрат)
  });
  console.log(secondArr); //[0, 1, 4, 9, 16]
  //Метод map нельзя применить к массивоподобным объектам, но можно создать новый (Array.from) и на нем сделать map
  const elements = document.querySelectorAll('.text');
  const elementsArr = Array.from(elements);
  const newArr = elementsArr.map((item) => {
    item.classList.add('text_is-active');
  });
  //пример 2
    const numbers = [1, 2, 3, 4, 5];
    const results = numbers.map(number => number * 2);
    console.log(results); // [2, 4, 6, 8, 10]
  //пример 3. вывод элементов массива (feature) в шаблоне { featuresList }
    const features = [
        '2 каюты',
        '4 спальных места',
    ];
    const featuresList = features.map((feature) => (
      <li>{feature}</li>
    ));
      <ul>{featuresList}</ul>

  //Поиск по строке. Метод includes. Метод используется для проверки наличия элемента в строке / массиве.
  //Если элемент найден, возвращает true, если нет — false
  //Пример 1 с массивом
    const fruits = ["apple", "banana", "orange", "mango"];
    console.log(fruits.includes("banana")); // true
    console.log(fruits.includes("kiwi")); // false
      //Эту же операцию можно записать методом indexOf, который вернёт индекс нужного элемента в массиве, и сравнить его с -1.
    //Пример 2 с массивом
      root.render(<App words={words} selectedItems={selectedItems}/>);
      const selectedItems = ['3', '4'];
      const words = [ { id: '1', word: 'Сasa' };
      function App({words = [], selectedItems = []}) {
          const cards = words.map((item) => (
            <Card isSelected={selectedItems.includes(item.id)} /> //https://up.htmlacademy.ru/fe-react/1/demos/10321#19
          ));
          return (
                <ul> {cards} </ul>
          );}
    //Пример со строкой
      'Гарри Поттер и узник Азкабана'.includes('Гарри Поттер'); // true

  //Отбор элементов массива: метод filter
  //Метод filter создаёт новый массив из элементов, для которых функция-фильтр вернула true. При этом исходный массив не меняется.
  //Колбэк метода filter — те же три параметра, что и у map и forEach. Текущий элемент, его индекс и исходный массив:
  const persons = [
    { name: 'Пётр', age: 16 },
    { name: 'Максим', age: 18 },
  ];
  const fullAgePersons = persons.filter(person => person.age >= 18); //На вход filter передадим другую функцию, которая возвращает true, если поле age больше либо равно 18.
  console.log(fullAgePersons); //[{ name: 'Максим', age: 18 }]

  const fruits = ['apple', 'banana', 'orange', 'grape'];
  const itemToRemove = 'orange';
  const filteredFruits = fruits.filter((item) => item !== itemToRemove); //filter можно использовать и для удаления элемента из массива
  console.log(filteredFruits); //['apple', 'banana', 'grape'];

  //find - используется для поиска первого элемента в массиве, который удовлетворяет заданному условию в виде колбэк-функции
    const numbers = [1, 2, 3, 4, 5, 6, 7];
    const result = numbers.find((item) => item > 3);
    console.log(result); // 4. Метод find находит первый элемент массива, удовлетворяющий условию, и возвращает его. В нашем случае это элемент 4.
    //пример с объектами
      const persons = [
        { id: 1, name: 'Alice' },
        { id: 2, name: 'Bob' },
      ];
      const resultByName = persons.find((item) => item.name === 'Bob'); //Метод find можно использовать для поиска объекта в массиве по значению одного из его полей.
      console.log(resultByName); // { id: 2, name: 'Bob' }

  //Проверка элементов массива. Метод some
  //Метод some проверяет, есть ли в массиве хотя бы один элемент, который соответствует определённому правилу.
  //Колбэк с этим правилом проверяет каждый элемент и возвращает true или false
  //Колбэк метода some — те же три параметра, что и у map и forEach. Текущий элемент, его индекс и исходный массив:
  const oceanResidents = ['Флаундер', 'Немо', 'Губка Боб', 'Аквамен'];
  const nemo = oceanResidents.some(function (resident) {
    return resident === 'Немо';
  });
  console.log(nemo); // true

  //Поиск элемента в массиве. Метод find
  //find возвращает значение элемента, на котором он завершил проверку
  const birds = [
    'Ворона',
    'Чёрно-белая ворона',
    'Белая ворона',
    'Ворона обыкновенная'
  ];
  const crow = birds.find(function (bird) {
    return bird.includes('ворона');
  });
  console.log(crow); // "Чёрно-белая ворона"

  //Проверка элементов массива. Метод every
  //Метод every проверяет все элементы массива и возвращает true, только если все элементы прошли проверку.
  //Колбэк — единственный аргумент метода. Он содержит логику проверки каждого элемента и возвращает true или false
  const jokes = [
    'смешная шутка и доля правды',
    'не очень смешной анекдот + доля правды',
    'доля правды в дурацкой шутке, услышав которую, все улыбнулись из вежливости'
  ];
  const allJokesWithTruth = jokes.every(function (joke) {
    return joke.indexOf('доля правды') > -1;
  });
  console.log(allJokesWithTruth); // true

  //Сведение массива. Метод reduce
  //аргументы: промежуточное значение (На каждой итерации этот аргумент равен тому, что в прошлый раз вернул колбэк), текущий элемент, его индекс и исходный массив
  //На первой итерации значение previousValue — первый элемент массива, item — второй
  const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];
  const sum = arr.reduce(function (previousValue, item) {
    return previousValue + item; //означает: «прибавь текущий элемент массива к тому, что получилось на предыдущей итерации»
  });
  console.log(sum);
  //previousValue можно задать самостоятельно
  const winsAndLoses = [10, 20];
  const total = winsAndLoses.reduce(function (previousValue, item) {
    return previousValue + item;
  }, 100); // Начальное значение (100) передаём методу reduce как второй аргумент.
  console.log(total); // 130

  //Сортировка массива sort
  //Может вызываться без функции обратного вызова (колбэка)
  const myNumbers = [0, 3.14, 2.718, 13];
  myNumbers.sort(); //если не передавать ему аргументы, пытается сортировать элементы массива по возрастанию Unicode кодов.
  myNumbers; // [0, 13, 2.718, 3.14]
  //Вызов с аргументами (колбэком)
  //если вы хотите отсортировать массив по возрастанию, колбэк должен возвращать a - b, по убыванию — b - a.
  const myNumbers = [0, 3.14, 2.718, 13];
  myNumbers.sort(function (a, b) {
    return a - b; //отсортировать по возрастанию
    /* Если a меньше b, вернётся отрицательное число.
    Это значит, что a должно расположиться в итоговом массиве
    раньше, b — позже. Например:
      a = 0, b = 3.14
      a - b = -3.14
    Получили отрицательное число, значит a стоит раньше b */
  });
  console.log(myNumbers); // [0, 2.718, 3.14, 13] — так и есть
  //Сортиорвка строк
  const chessChampions = ['Вильгельм', 'Эммануил', 'Александр' ];
  chessChampions.sort(function (a, b) {
    a = a.toLowerCase();
    b = b.toLowerCase();
    if (a < b) return -1; // a расположится раньше b
    return 0;
  });
  console.log(chessChampions); //'Александр', 'Вильгельм', 'Эммануил'

  //findIndex() - нахождения индекса объекта в массиве, Этот метод работает аналогично indexOf
  //Если элемент в массиве найден, findIndex вернёт его индекс, в противном случае метод вернёт значение -1.

//Объекты. Объекты состоят из пар «ключ — значение». Пары «ключ — значение» часто называют полями.
  //Значение — это данные, которые мы хотим записать.
  //Значением может быть строка, число, булево значение, массив, другой объект - такую пару называют свойством
  //Значением может быть функция - такую пару называют методом
  //Ключ — это уникальное имя этого значения. По ключу мы можем обратиться к значению
  //Пары «ключ — значение» делятся на два типа: свойства и методы.
  let user = {};  // синтаксис "литерал объекта", let user = new Object(); // синтаксис "конструктор объекта"
  delete user.age; //Для удаления свойства
  let user = {
      nickname: 'Мария',
      getGreeting: function() {
          return 'nickname';
      },
      getGreeting2: function() {
          return this.nickname; //вернуть значение ключа этого же объекта
      },
      "likes birds": true  // имя свойства из нескольких слов должно быть в кавычках. Обращение через [] скобки - user["likes birds"] = true;
  };
  console.log(user.nickname); //Мария
  console.log(user['nickname']); //Мария. Квадратные скобки также позволяют обратиться к свойству, имя которого может быть результатом выражения
  console.log(user.getGreeting()); //Мария
  console.log(user.getGreeting2()); //Мария

  let admin = user; // копируется ссылка на user, но не сам объект

  //obj[propertyName]
  //Объект, объявленный через const, может быть изменён. объявление const защищает от изменений только саму переменную obj, а не её содержимое
  const obj = {
    firstName: 'John',
    lastName: 'Doe',
  };
  const propertyName = 'firstName';
  console.log(obj[propertyName]); // Выведет 'John'

  //задания динамических свойств объектов
  const propertyName = 'firstName';
  const obj = {
    [propertyName]: 'John',
    lastName: 'Doe',
  };
  console.log(obj.firstName); // Выведет 'John'
  obj.newName = "newName"; //добавление нового свойства в объект

  //Квадратные скобки также позволяют обратиться к свойству, имя которого может быть результатом выражения
  let user = {
    name: "John",
  };
  let key = prompt("Что вы хотите узнать о пользователе?", "name");
  //доступ к свойству через переменную
  alert( user[key] ); // John (если ввели "name"). Через alert( user.key ); //undefined

  //Вычисляемые свойства
  let fruit = prompt("Какой фрукт купить?", "apple");
  let bag = {
    [fruit]: 5, // имя свойства будет взято из переменной fruit
  };
  alert( bag.apple ); // 5, если fruit="apple"

  //Свойство из переменной
  function makeUser(name, age) {
    return {
      name, // то же самое, что и name: name (параметр функции)
      age   // то же самое, что и age: age (параметр функции)
    };
  }

  //Проверка существования свойства, оператор «in»
  let user = { name: "John", age: 30 };
  alert( "age" in user ); // true, user.age существует
  alert( "blabla" in user ); // false, user.blabla не существует

  //Цикл "for..in"
  let user = { name: "John", age: 30 };
  for (let key in user) {
    alert( key );  // ключи // name, age
    alert( user[key] ); // значения ключей // John, 30
  }

  //Копирование объекта Object.assign
  //Первый аргумент dest — целевой объект.
  //Остальные аргументы src1, ..., srcN (может быть столько, сколько необходимо) являются исходными объектами
  Object.assign(dest, [src1, src2, src3...])

  let user = { name: "John" };
  let permissions1 = { canView: true };
  let permissions2 = { canEdit: true };
  Object.assign(user, permissions1, permissions2); // копируем все свойства из permissions1 и permissions2 в user
    //теперь user = { name: "John", canView: true, canEdit: true }

  //использовать Object.assign для замены цикла for..in для простого клонирования
  let user = {
    name: "John",
    age: 30
  };
  let clone = Object.assign({}, user); //Он копирует все свойства user в пустой объект и возвращает его.
  //клонирование с использованием оператора расширения
  let clone = {...user};

  //Методы объекта
  //Функцию, которая является свойством объекта, называют методом этого объекта.
  let user = {
    name: "John"
  };
  user.sayHi = function() {
    alert("Привет!");
  };
  user.sayHi(); // Привет!
  //Сокращённая запись метода
  user = {
    sayHi: function() {
      alert("Привет");
    }
  };
  //или так
  user = {
    sayHi() { // то же самое, что и "sayHi: function(){...}"
      alert("Привет");
    }
  };

  //this в объектах
  let user = {
    name: "John",
    sayHi() {
      alert(this.name); // this = объект user, точнее ссылка на объект user
    }
  };
  user.sayHi(); // John

//Словари
  let users = {
      'favorite food': 'Сметана',
      fullname: 'Иванова'
  };
  console.log(users['favorite food']); //Сметана
  console.log(user['fullname']); //Иванова

//Тернарный оператор. тернарный оператор возвращает значение, а условная конструкция — нет
  //условие ? значение1 : значение2;
  const a = 5, b = 10;
  const max = (a > b) ? a : b;
  //тернарный оператор в реакт
  <div>{ condition ? <Component1 /> : <Component2 />; }</div>

//циклы
  //for
    for (let i = 0; i <= 4; i = i + 1) {
        console.log(aliExpress[i]);
      continue; //Директива continue не прерывает весь цикл, а только пропускает текущую итерацию.
      break; //Директива break нужна, когда дальнейшее выполнение цикла бессмысленно или может привести к неправильным результатам
    }
  //for of
    for (let tooltipButton of tooltipButtons) { //элемент tooltipButton из коллекции tooltipButtons
        console.log(tooltipButton);
    }
  //for in
  for (let tooltipButton in tooltipButtons) {
    console.log(tooltipButton);
  }

  //while
    let a = 1; let b = 0;
    while (a >= b) {
      console.log("do");
      a +=1;
    }

  //do while. тело цикла выполнится хотя бы один раз
  do {
    console.log("do");
  } while (a >= b);

  //Конструкция switch-case
    let day = 'Monday';
    switch (day) {
      case 'Monday':
        alert('Сегодня понедельник');
        break;
      case 'Tuesday':
        document.body.style.backgroundColor = 'blue';
        break;
      default:
        alert('Сегодня неизвестный день недели');
        break;
    }

  //пример 2. Можно сознательно пропустить break, чтобы прописать логику сразу нескольких случаев
  let catName;
  const cartoon = 'Зима в Простоквашино';
  switch (cartoon) {
    case 'Зима в Простоквашино':
    case 'Весна в Простоквашино':
      catName = 'Матроскин';
      break;
    case 'Лето кота Леопольда':
      catName = 'Леопольд';
  }
  console.log(catName); // "Матроскин"

//Функции
  //При объявлении функции описывают её параметры. При вызове — передают аргументы.
  //Объявление функции
  //Объявленную функцию можно вызвать до объявления, функциональное выражение — нельзя
  function makeHelloWorld() { //makeHelloWorld - Объявление функции
    function helloWorld() { //helloWorld - Объявление функции
      return console.log("Hello world!");
    }
    return helloWorld; //тут мы не вызываем функцию
  }
  const helloWorld = makeHelloWorld(); //в helloWorld запишется ссылка на simpleFunction
  console.log(helloWorld); //[Function: helloWorld]
  helloWorld(); //"Hello world!"

  //Функциональные выражения
  //Объявленную функцию можно вызвать до объявления, функциональное выражение — нельзя
  let functionName = function (userName, bookName) { //Передавать аргументы надо в том же порядке, в котором объявлены параметры функции. Потому что порядок аргументов соответствует порядку параметров в функции. У нас параметры записаны в таком порядке: userName, bookName.
      console.log('Меня зовут ' + userName + '. Моя любимая книга: ' + bookName);
      let name = userName + bookName;
      return name;
  };
  function sayHello(name) {
      return 'Привет, ' + name;
  }

  //Стрелочные функции
  //В стрелочных функциях нельзя использовать this
  const consoleWombat = (wombat) => {
    console.log(wombat);
  };
  //Короткий return в стрелочных функциях
  const singleAnecdote = (anecdote) => {
    return `я знаю только один анекдот: ${anecdote}`;
  };
  const shorterSingleAnecdote = (anecdote) => `я знаю только один анекдот: ${anecdote}`; //можно без return и фигурных скобок
  //Если возвращаемое значение — объект, его нужно заключить в круглые скобки. Иначе то, что в фигурных скобках, движок воспримет как тело функции
  const colorHex = () => ({ white: '#FFF' }); //вот так правильно
  const colorHexWhite = () => { white: '#FFF' }; //вот так не правильно
  //Короткая запись параметров
  //Если у стрелочной функции один параметр, можно не заключать его в скобки:
  const boatArrival = survivor => {
    console.log(`до другого берега доберётся только ${survivor}`);
  };
  //Стрелочные функции как колбэки
  const array = [1, 2, 3, 4];
  array.forEach(() => {
    console.log('Кнопка нажата!');
  });
  //Если единственное, что делает колбэк — это возвращает значение (через return), то можно использовать короткий return
  const array = [1, 2, 3, 4];
  const newArray = array.map(elem => elem * 2);

  //Анонимные функции
    element.addEventListener('click', function () { //function (){...} - анонимная функция
      console.log('Клик');
    });

  //Функция-конструктор
  //Имя функции-конструктора должно начинаться с большой буквы
  //Функция-конструктор должна выполняться только с помощью оператора new
  function User(name) {
    this.name = name;
  }
  let user = new User("Jack");
  alert(user.name); // Jack

  //можно вызывать без скобок
  let user = new Users();
  let user = new Users;

  //Создание методов в конструкторе
  function User(name) {
    this.name = name;
    this.sayHi = function() {
      alert( "Меня зовут: " + this.name );
    };
  }
  let john = new User("John");
  john.sayHi(); // Меня зовут: John

  //return
  //return без значения просто говорит функции «хватит». Если передать такой функции пустую строку, она прекратит работу. Функция при этом вернёт специальное значение undefined
  function sayHello(name) {
    if (name === '') {
      return; // если имя — пустая строка, выйдем из функции
    }
    let greeting = 'Привет, ' + name;
    return greeting;
  }
  //Аргументы по умолчанию
  //Параметр по умолчанию может принимать любое значение: число, строку, объект, функцию
  function generateName(firstName, lastName, middleName = '') {
    return `${firstName} ${middleName} ${lastName}`;
  }
  //Значением одного параметра функции даже может быть другой её параметр:
  function generateName(firstName, lastName = firstName) {
    return `${firstName} ${lastName}`;
  }
  //spread в функциях
  //При вызове функции — разбивает массив
  const nums = [4, 8, 15, 16, 23, 42];
  Math.max(...nums); // 42
  //rest в функциях
  //При объявлении функции — собирает аргументы в массив
  //rest-параметр всегда стоит в конце
  function consoleDogs(firstDog, ...otherDogs) {
    console.log(`Первый: ${firstDog}`);
    console.log(`Остальные: ${otherDogs}`);
  }
  consoleDogs('Спаниель', 'Овчарка', 'Борзая', 'Метис'); //"Первый: Спаниель" и "Остальные: ['Овчарка', 'Борзая', 'Метис']"
  //Старый код. Переменная arguments
  //В старом коде, до появления оператора spread, можно встретить другой способ работы с такими функциями — переменную arguments.
  function gimmeSomeArguments() {
    console.log(arguments);
  }
  gimmeSomeArguments(1, 2); // [1, 2]

  //prompt. позволяет получить ответ от пользователя.
  //Функция выводит диалоговое окно с текстовым полем. Если пользователь введёт что-то и нажмёт кнопку "ОК", в переменной password сохранится введённый текст.
  //Если пользователь не настроен на диалог и нажмёт «Отмена», в переменную попадёт null.
  password = prompt('Введите пароль:');

  //alert
  alert("Hello"); //Она показывает сообщение и ждёт, пока пользователь нажмёт кнопку «ОК».

  //confirm
  let res = confirm(question); //Функция confirm отображает модальное окно с текстом вопроса question и двумя кнопками: OK и Отмена

//js функции
  Math.ceil(number); //принимает на вход число и округляет его до целого в большую сторону
  Math.floor(number) //делает то же самое, только округляет в меньшую сторону
  Math.round(number) //округляет число до ближайшего целого значения
  Math.random() ;//Она возвращает случайное число между 0 и 0.99999999999, включая 0:
  Math.max(a, b, c...); //Math.min(a, b, c...); - возвращает наибольшее или наименьшее число из перечисленных аргументов.
  Math.round(arg); //округляет аргумент до ближайшего целого.
  Math.ceil(arg); //округляет аргумент в большую сторону.
  throwDice(min, max); //генерирует случайные числа в заданном промежутке, включая минимальное и максимальное значение.
  Math.floor(Math.random() * array.length); //floor - Мы можем округлить наше число от 0 включительно до array.length в меньшую сторону, «отбрасывая» дробную часть случайного числа
  price.toLocaleString(); //1500 -> 1 500 //преобразует число в строку и возвращает значение, используя указанный языковой стандарт.
    //Если метод используется без параметров, то он использует язык по-умолчанию.
    //const formatPrice = (price) => `${price.toLocaleString()} ₽`; //1 500 ₽

//Интерполяция шаблонной строки
  const formattedPrice = `Значение = ${price.toLocaleString()} ₽/час`; // = price.toLocaleString() + " ₽/час"
    const formattedPrice = `cards ${!isShownByGrid ? 'list' : ''}`; // "cards list" или "cards"
    className="{'button button-${firstSelectedOption}'}";

//Опциональная цепочка ?. (value?.prop)
  //(value?.prop) работает как value.prop, если значение value существует,
  //в противном случае (когда value равно undefined/null) он возвращает undefined
  let user = {}; // пользователь без адреса. Также ?. работает и при let user = null
  alert( user?.address?.street ); // undefined (без ошибки)
  //пример с document.querySelector
  let html = document.querySelector('.elem')?.innerHTML; //будет undefined, если элемента нет

  //Другие варианты применения: ?.(), ?.[]
  //?.() используется для вызова функции, которая может не существовать.
  let userAdmin = {
    admin() {
      alert("Я админ");
    }
  };
  let userGuest = {};
  userAdmin.admin?.(); // Я админ
  userGuest.admin?.(); // ничего не произойдет (такого метода нет)

  //?.[] синтаксис также работает, если мы хотим использовать скобки [] для доступа к свойствам вместо точки "."
  let user1 = {
    firstName: "John"
  };
  let user2 = null;
  alert( user1?.['firstName'] ); // John
  alert( user2?.['firstName'] ); // undefined

//Деструктуризация
  const x = 5;
      const obj = {x}; //или const obj = {x: x}; //создать объект со свойством x, равный значению этой переменной х = «возьми значение из переменной x и помести его в свойство объекта с таким же именем».
      const arr = [x]; //также для массивов
  //Деструктуризация массива
  let arr = ["Ilya", "Kantor"];
  let [firstName, surname] = arr; //firstName = arr[0] и surname = arr[1]
  alert(firstName); //Ilya
  alert(surname);  //Kantor
  //Пропускайте элементы, используя запятые
  let [firstName, , title] = ["Julius", "Caesar", "Consul", "of the Roman Republic"];
  alert( title ); //Consul, оставшиеся элементы массива также пропускаются (так как для них нет переменных).
  //Трюк обмена переменных
  let guest = "Jane";
  let admin = "Pete";
  [guest, admin] = [admin, guest]; //Здесь мы создаём временный массив из двух переменных и немедленно деструктурируем его в порядке замены

  //Spread (распыление)
  const arr1 = [1, 2, 3];
  const arr2 = [4, 5, 6];
  const combinedArray = [...arr1, ...arr2];
  console.log(combinedArray); // [1, 2, 3, 4, 5, 6]

  //Rest (остаток). Переменная rest является массивом из оставшихся элементов.
  const [first, second, ...restOfArray] = [1, 2, 3, 4, 5];
  console.log(first); // 1
  console.log(restOfArray); // [3, 4, 5]
  //Значения по умолчанию
  let [name = "Guest", surname = "Anonymous"] = ["Julius"];
  alert(name);    //Julius (из массива справа)
  alert(surname); //Anonymous (значение по умолчанию)
  //Rest (остаток) объекта
  let options = {
    title: "Menu",
    height: 200,
    width: 100
  };
  let {title, ...rest} = options;   // сейчас title="Menu", rest={height: 200, width: 100}
  alert(rest.height);  // 200
  alert(rest.width);   // 100

  //Деструктуризация объекта
  let options = {
    title: "Menu",
    width: 100,
    height: 200
  };
  let {title, width, height} = options; //Порядок слева не имеет значения, "let {height, width, title}" - так – тоже работает
  alert(title);  // Menu
  alert(width);  // 100
  alert(height); // 200
  //Если мы хотим присвоить свойство объекта переменной с другим названием, например, свойство options.width присвоить переменной w, то мы можем использовать двоеточие
  //Двоеточие показывает «что : куда идёт»
  let {width: w, height: h, title} = options;
  alert(title);  // Menu
  alert(w);      // 100
  alert(h);      // 200
  let {width = 100, height = 200, title} = options; //Для потенциально отсутствующих свойств мы можем установить значения по умолчанию
  let {width: w = 100, height: h = 200, title} = options; //Мы также можем совмещать : и =
  let { title } = options; //Если у нас есть большой объект с множеством свойств, можно взять только то, что нужно
  let {title, ...rest} = options; //пример с Rest

  //Вложенная деструктуризация
  let options = {
    size: {
      width: 100,
    },
    items: ["Cake", "Donut"],
  };
  let {
    size: { // положим size сюда
      width,
    },
    items: [item1, item2], // добавим элементы к items
  } = options;
  alert(width);  // 100
  alert(item1);  // Cake
  alert(item2);  // Donut

  //Умные параметры функций. Мы можем передать параметры как объект, и функция немедленно деструктурирует его в переменные
  let options = {
    title: "My menu",
    items: ["Item1", "Item2"]
  };
  function showMenu({title = "Untitled", items = []}) {
    alert( `${title}` ); //My Menu. title – взято из options
    alert( items ); //Item1, Item2. items – взято из options
  }
  showMenu(options);
  showMenu({}); //все значения будут по умолчанию.
  //Мы можем исправить это, сделав {} значением по умолчанию для всего объекта параметров
  //Весь объект аргументов по умолчанию равен {}, поэтому всегда есть что-то, что можно деструктурировать
  function showMenu({ title = "Menu", width = 100, height = 200 } = {}) {
    alert( `${title} ${width} ${height}` );
  }
  showMenu(); // Menu 100 200

//Таймеры
//setTimeout - Она принимает два аргумента: функцию, которую нужно запустить, и время в миллисекундах, через которое эта функция должна быть вызвана
  //для установки в таймер отложенного выполнения кода нужно передать функцию, а не вызывать её.
  function tellMeLater() {
    console.log("Hello from timer!");
  }
  setTimeout(tellMeLater, 1000);
//clearTimeout - отменяет таймер, созданный функцией setTimeout.
  //На вход функциям подаётся таймер ID — идентификатор таймера. Его возвращают setTimeout и setInterval, которые создают этот таймер.
  //timerId
  const timerId = setTimeout(() => console.log({ timerId }), 1000);
  //пример, программа, которая будет выводить сообщение «Hello, world!» в консоль каждые две секунды. После 10 секунд выполнение программы должно завершиться
  function sayHello() {
    console.log('Hello, world!');
  }
  let timerId = setTimeout(function tick() {
    sayHello();
    timerId = setTimeout(tick, 2000);
  }, 2000); //каждые 2 секунды выводится sayHello()
  setTimeout(function() {
    clearTimeout(timerId);
    console.log('The program has stopped!');
  }, 10000); //После 10 секунд выполнение программы должно завершиться

//setInterval - функция запускается не один раз, а периодически через указанный интервал времени
  setInterval(tellMeLater, 1000); //команда tellMeLater будет повторяться каждые 1000 миллисекунд
//clearInterval - отменяет таймер, созданный функцией setInterval
