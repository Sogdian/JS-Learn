/*Типы данных:
    number — числа: целые и с точкой; простые типы данных
    string — строки; простые типы данных
    boolean — логические, или булевы, значения: true — «истина» и false — «ложь». простые типы данных
    undefined — undefined; простые типы данных
    массивы - для хранения однородных элементов, хранит последовательность значений, и порядок этих значений важен. сложные, или составные, типы данных
    функции - ;
    объекты - состоит из множества пар «ключ-значение», порядок этих пар не важен; сложные, или составные, типы данных
        {month: 'june', day: 15}
Составные типы содержат не одно, а несколько значений

Операция сложения — бинарная, так как в ней два операнда.
    Бинарные операции самые распространённые.
    Но существуют и унарные операции, с одним операндом, и тернарные операции, с тремя операндами.
    Приоритет операторов https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Operator_Precedence

Конкатенацией - сложение строк (“catenate” — «связывать в одну цепь».)
Зарезервированные слова https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Lexical_grammar#%D0%9A%D0%BB%D1%8E%D1%87%D0%B5%D0%B2%D1%8B%D0%B5_%D1%81%D0%BB%D0%BE%D0%B2%D0%B0

*/
console.log(21 + "2"); //"212"
    console.log(2 ** 3); // возведение в степень. выведет в консоль 8
    console.log((2 + 2) / 2);
    console.log(4 * 3 ** 2); // = 4 * 3 в степени 2
    console.log(document.querySelector('.page'));
    console.log('Время, мин: ' + 50); // = 'Время, мин: 50'. Плюс может быть знаком сложения или конкатенации, но так как один из операндов — строка, то сложение не подходит. Поэтому число 50 приводится к строке '50' и склеивается со строкой 'Время, мин: '.
    console.log('2' * 50); // = 100. Звёздочка — это знак умножения, со строками она не используется. Поэтому JavaScript пытается превратить строку '2' в число, и ему это удаётся. Затем числа 2 и 50 перемножаются, и получается 100.

//Приведение к типу
String(1); // Выведет строку: 1 (String)
    toString(1); // Выведет строку: 1 (String)
    Number('1'); // Выведет число: 1 (Number)
    parseInt('17');   // Вернёт 17
    parseInt('10001', 2); // Вернёт 17
    parseInt('11', 16);   // Вернёт 17
/*Приведение к логическому типу данных
    Значения, которые как бы ничего в себе не содержат (как 0, пустая строка '' или undefined), приводятся к false, а все остальные приводятся к true */

let pages = 0;
    pages++; //Увеличит число на 1. Значение переменной: 1
    pages--; //Уменьшит число на 1. Значение переменной: 0

//операторы
    //оператор строгого равенства, тут нет приведения типов. https://htmlacademy.ru/courses/209/run/5
    'a' === 'a'; // Результат: true
    'a' !== 'a'; // Результат: false
    //оператор нестрогого равенства, тут есть приведение типов
    'a' == 'a'; // Результат: true
    //оператор нестрогого неравенства
    'a' != 'a';
    //логическое И
    //true && true; Результат: true; true && false;  // Результат: false; false && true;  // Результат: false; false && false; // Результат: false
    //логическое ИЛИ
    //true || true;   // Результат: true; // true || false;  // Результат: true; // false || true;  // Результат: true; // false || false; // Результат: false

//массивы
    /* в массиве можно хранить любые данные: строки, булевы значения, числа и даже другие массивы.
    если в массиве нет элемента под тем номером, под которым мы записываем, то этот элемент будет создан */
let phrases = []; //пустой массив
let numbers = [1, 2, 3, 4, 5];
    numbers.push(6); //добавить новый элемент в конец
let aliExpress = ['Лазерная указка Xioamo', 'Гарнитура в виде телефонной трубки', 'Форма для льда «Титаник»'];
    aliExpress.length //длина массиыв = 3 элемента

//объекты
let user = {
    name: 'Мария',
    dotaLevel: 21, };
console.log(user.name);


//циклы
for (let i = 0; i <= 4; i = i + 1) {
    console.log(aliExpress[i]);
}
for (let tooltipButton of tooltipButtons) { //элемент tooltipButton из коллекции tooltipButtons
    console.log(tooltipButton);
}
while (a >= b) {
}

//функции
let functionName = function (userName, bookName) { //Передавать аргументы надо в том же порядке, в котором объявлены параметры функции. Потому что порядок аргументов соответствует порядку параметров в функции. У нас параметры записаны в таком порядке: userName, bookName.
    console.log('Меня зовут ' + userName + '. Моя любимая книга: ' + bookName);
    let name = userName + bookName;
    return name;
};
function sayHello(name) {
    return 'Привет, ' + name;
}

//js функции
//принимает на вход число и округляет его до целого в большую сторону
Math.ceil(number);
//делает то же самое, только округляет в меньшую сторону
Math.floor(number)
//округляет число до ближайшего целого значения
Math.round(number)
//Генерация случайного числа
Math.random() ;//Она возвращает случайное число между 0 и 0.99999999999, включая 0:
    Math.random() * 10; //если нужно случайное число от 0 до 10
//генерирует случайные числа в заданном промежутке, включая минимальное и максимальное значение.
throwDice(min, max)

//------------------------------
/*
aria-pressed - атрибут указывает, в каком состоянии находится кнопка-переключатель. Например, если лайк стоит, то значение у атрибута должно быть "true", а если лайка нет, то "false". Атрибут aria-pressed не влияет на внешний вид кнопки, но он помогает скринридерам правильно прочитать содержимое страницы. https://medium.com/web-standards/toggle-buttons-a41388e80974#2347
append - метод не копирует элементы, а перемещает. Если указать в скобках элемент, который уже есть в разметке, этот элемент исчезнет со своего прежнего места и появится там, куда его добавил метод append. Получить таким образом несколько элементов не выйдет.
data-name1-name2 - дата атрибут. Атрибуты, начинающиеся с data-, обычно используют, чтобы хранить вспомогательную информацию. https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes
output - тег используют, чтобы показать на странице результат вычислений, полученный с помощью JavaScript. https://htmlacademy.ru/courses/74/run/14
*/


element = document.querySelector('.class'); //Метод ищет по селектору, который указан в скобках. Словом document обозначается веб-страница, к которой подключили скрипт.
    elementBody = document.body;  //элемент body
    element2 = element.querySelector('class'); //искать черз querySelector внутри element, который ищем тоже через querySelector
    element.href; //вывести значение атрибута элемента
    element = document.querySelector('.slider-preview-item .active'); //поиск по селектору (двум классам)
element = document.querySelectorAll('.class'); //Метод ищет по всем селекторам и возвращает коллекцию
element.textContent = "123"; //textContent хранит в себе текстовое содержимое элемента
element.style.fontSize = '33px'; //менять размер шрифта
element.classList.remove('class'); //Метод убирает с элемента тот класс, который указан в скобках
element.classList.add('class'); //метод добавляет элементу класс (без точки), указанный в скобках.
button.addEventListener('click', function () { }); //addEventListener слушатели событий» //https://developer.mozilla.org/ru/docs/Web/API/EventTarget/addEventListener
    button.onclick = function() {}; //Свойство onclick означает «по клику» //function() - обработчик событий
    button.onclick = function(evt) {
        evt.preventDefault(); //отменить действие браузера по умолчанию (при наступлении события) - переход по ссылке
    };
element.classList.toggle('.class'); //добавление класса, когда этого класса нет и удаление класса (изначального), когда этот класс есть. Если класс у элемента есть, метод classList.toggle ведёт себя как classList.remove и класс у элемента убирает. А если указанного класса у элемента нет, то classList.toggle, как и classList.add, добавляет элементу этот класс.
element.classList.contains('.class'); //проверить, есть ли у элемента класс. вернёт true (истина), если класс у элемента есть, и false (ложь), если класса нет.
element.onsubmit = function() {}; //обработчик событий onsubmit добавляется на форму <form> (не на кнопку)
input = document.querySelector('input').value; //value - это значение поля ввода (input), значение вернется только после того, как форма была отправлена. textContent вернет пусто, т.к. для JavaScript поля формы не имеют текстового содержимого, их значения хранятся именно в value.
    element.oninput = function() {} //вернет value из формы в процессе ввода текста (сразу каждую букву)
parent.append(element); //Добавляем новый элемент в конец элемента-родителя. При этом содержимое элемента-родителя не затирается. Добавлять с помощью этого метода можно и элементы, и простые строки.
document.createElement('div'); //Создание элемента div в document
element.dataset.tooltipText; //dataset - получить значение дата атрибута data-tooltip-text (без data и без префикса, в camelCase)
button.disabled = true; //заблокировать кнопку
window.onscroll = function () {} //отслеживание скрола (мин на 1 px). window - окно (или вкладка) браузера. Обработчик событий onscroll можно добавлять не только окну браузера, но и отдельным элементам на странице. Чтобы обработчик сработал, у элемента должна быть своя полоса прокрутки. Управлять прокруткой элемента можно с помощью CSS свойства overflow https://www.w3.org/TR/css-overflow-3/#overflow-properties
window.pageYOffset //Вычисляет на какое кол-во пикселей была прокручена страница по Y
//Величина горизонтальной прокрутки хранится в свойстве pageXOffset.
window.scrollTo(100, 50); //Прокрутит страницу на 100px вправо и на 50px вниз. Если страница помещается в окно целиком и полосы прокрутки нет, то браузер проигнорирует эту инструкцию. По умолчанию автоматическая прокрутка в браузерах происходит очень быстро, скачком. Чтобы сделать её более плавной, мы использовали CSS свойство scroll-behavior со значением smooth. Подробнее об этом свойстве вы можете узнать из спецификации.
filter.onchange = function() {} //обработчик срабатывает, когда пользователь выбирает новое значение из выпадающего списка. Обработчик событий onchange можно использовать с разными элементами. Например, он срабатывает, когда пользователь переключает чекбокс или радиокнопки.
element.style.color = 'green'; //изменить цвет текста. Стили, заданные с помощью свойства style, они имеют больший приоритет, чем CSS-правила из файла со стилями.
window.getComputedStyle; //Получить стили, но только те стили, которые заданы в разметке в атрибуте style самого элемента. https://www.w3.org/TR/DOM-Level-2-Style/css.html#CSS-OverrideAndComputed-h3
input.type = 'text'; //сменить тип на 'text'
showPassword.checked; //свойство чекбокса true/false, включен ли он или выключен




/*
select - раскрывающийся список, фильтрация. Значение фильтра записывается в select.value

CSS	/ JаvaScript
font-size /	fontSize
background-color / backgroundColor
border-left-width /	borderLeftWidth

*/

/*
Проанализируем проделанную работу:
    при анализе задания поняли, какие элементы нужно изменять при переключении;
    нашли в стилях нужные классы, анализируя разметку;
    переключили раскладку вручную;
    записали действия по переключению в скрипте.
    Молодцы! Работа с компонентом закончена.
 */