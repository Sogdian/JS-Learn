/* Состояние компонента — это внутренние данные в компоненте, которые меняются в процессе выполнения программы.
  В отличие от параметров, которые передаются в компонент из его родителя и не могут быть изменены внутри компонента,
  состояние может измениться в любой момент.
  Состояние обычно используется для управления поведением компонента, а параметры — для настройки его внешнего вида. */

//Создаем элемненты
function HelloWorld(props) { //или HelloWorld({date})
    //Все данные, передаваемые в компонент, обязательно являются свойствами объекта props. Их нельзя делать отдельными параметрами функции
  const computedDate = props.date ? props.date : '29.05.2013'; //или const computedDate = {date} ? {date} : '29.05.2013';
    //const content = type === 'image' ? <img src="url" /> : <span>text</span>; //другой похожий пример
  return (<h1>Привет, Мир!!! Моё приложение создано: {computedDate}</h1>) //JSX синтаксис
}

function App({children}) {
  let dateTime = '30.05.2013'
  return (
    <section>
      <HelloWorld date={dateTime} /> //или date='30.05.2013'
      {children}
    </section> //<h1>Привет, Мир!!! Моё приложение создано: 30.05.2013</h1>
  )
}

function MyComponent () {
  return (
    <>
      <h1 className="title">Hello React!</h1>
    </>
  );
}

const child = React.createElement('span', { className: 'text-green' }, 'Hello React!');
const element = React.createElement('h1', { className: 'title', children: 'Hello world!' }); //Метод создаёт новый React-элемент
const element2 = React.createElement('h1', { className: 'title'}, child);

//вывод в родителе дочернего элемента
  function HelloWorld(props) {
    return (
      <h1>Привет, Мир!!! {props.children}</h1>
      <div style={{width: '33%'}}></div> //Первые внешние фигурные скобки означают, что внутри содержится JS-выражение. А вторые внутренние — объявление JS-объекта.
        //В HTML в атрибуте style записан набор CSS-правил. А style у DOM-элементов — это специальный объект, который содержит список всех свойств стилей для этого элемента.
    )
  }
  <HelloWorld>
    <span>Этот текст передан как дочерний элемент для HelloWorld</span> //children = <span>...</span>

    <h1>
      <span>Первый элемент</span> //когда children много, надо указать общий корневой элемент, пример, h1
      <span>Второй элемент</span>
    </h1>
  </HelloWorld>
  //в итоге выведется: <h1>Привет, Мир!!! <span>Этот текст передан как дочерний элемент для HelloWorld</span></h1>

//Выделение компонентов
  function Button (props) { //Button - общий компонент для Product() и Order()
    return <button class="button" type="button" onClick={props.onClick}>{props.name}</button> //props.onClick = addProduct
  }
  function Product (props) {
    function addProduct () {
      // некоторая сложная бизнес-логика добавления товара в корзину
    }
    return <section>
      //некоторая разметка карточки продукта
      <Button name={"Купить"} onClick={addProduct} />
    </section>
  }
  function Order (props) {
    function createOrder () {
      // некоторая сложная бизнес-логика добавления товара в корзину
    }
    return <section>
      // некоторая разметка страницы оформления
      <Button name={"Оформить заказ"} onClick={createOrder} />
    </section>
  }


//Вызываем функции библиотеки React
const containerElement = document.getElementById('root');
const root = ReactDOM.createRoot(containerElement); //создать коревой элемент
root.render(element); //Hello world! //Для отрисовки используем метод render у объекта ReactDOM
  root.render(element2); //Hello React!
  root.render(<HelloWorld date='13.02.23' />); //
  root.render(HelloWorld({date: '13.02.23'})); //<h1>Привет, Мир!!! Моё приложение создано: 13.02.23</h1>
  root.render(<App />); //<h1>Привет, Мир!!! Моё приложение создано: 13.02.23</h1>
    root.render(<App> <p>Это дочерний компонент</p> </App>); //<p>...</p> = children
  root.render(<h1>Hello world!</h1>); //Hello world!
  root.render('Hello world!'); //Hello world!
  root.render(<MyComponent />); //Hello React! //вызвать <React.Fragment>. Этот компонент вместо DOM-элемента создаёт «фрагмент» документа, который объединяет вложенные в него элементы.

const className = `card ${ isSelected ? 'selected' : ''} ${ isFinished ? 'disabled' : '' }`; //card selected disabled или card или другие вариации

//onClick - пропс React-элементов
  //пример 1
    function Button () {
      function print() {
        console.log('Вы нажали на кнопку')
      }
      return <button type="button"
                     onClick={print}
                     onClick="showMessage()"
                     onClick={() => alert('Hello world')}
                     onMouseOver={() => console.log('Mouse detected!')}
      >Нажми меня </button> //onClick, onMouseOver - обработка событий в DOM-элементах c React
    }
  //пример 2 с объектом события, чтобы обратиться к объекту события (например, чтобы получить больше информации о событии или обратиться к DOM-элементу, на котором произошло событие)
    //мы должны определить параметр (например, evt) в функции-обработчике события. В него будет подставлен объект события,
    //но это ненативный объект события, который устанавливается браузером. Вместо нативного объекта, React предоставляет экземпляр SyntheticEvent — синтетическое событие.+
    //В React обработчик события добавляется не напрямую к DOM-элементу, а к React-компоненту, который в свою очередь рендерит соответствующий элемент.
    //Когда происходит событие, React создает объект SyntheticEvent и передает его в обработчик события, который был задан в качестве пропса в компоненте.
    function App() {
      return (
        <button onClick={(evt) => console.log(evt)}>
          Нажми на меня
        </button>
      );
    }
  //пример 3. В этом примере мы рендерим список кнопок, каждая из которых выводит в консоль свой текст при клике.
    function ButtonList () {
      const buttons = ['Нажми меня', 'И меня', 'И меня']
      return (
        <div>
          {buttons.map((text, index) => {
            return <button type="button" key={index} onClick={() => console.log(index, text)}>{text}</button>
          })}
        </div>
      )
    }




/* Хуки. Хук — это функция. Её необходимо импортировать из пакета React, например, import {useState} from "react"
//1. хук useState - для работы с состоянием, позволяет использовать состояние в функциональных компонентах. Состояния позволяют делать интерактивные интерфейсы, которые реагируют на действия пользователя.
    Он принимает начальное состояние и возвращает массив. Первый элемент массива представляет собой текущее состояние, а второй элемент — функцию для изменения этого состояния.
    useState можно вызывать только внутри компонента, useState нельзя вызывать в инструкциях ветвления if, for и так далее.
    state не приходит извне, а является частью самого компонента и находится внутри него. Изменение состояния — это реакция на внешние действия: клики пользователя
    Для каждого экземпляра компонента будет создано своё собственное значение состояния [..., ...] = React.useState(..)
    Компоненты, которые расположенны на одном уровне, не могут влиять и не могут учитывать состояние друг друга.
      Чтобы пользователь мог открыть только одну статью одновременно, вы должны управлять этим состоянием в вышестоящем компоненте.
       Родительский компонент управляет состоянием, а потомки получают его в качестве параметра.

    В коде мы объявили переменную count и функцию setCount и использовали для этого деструктуризацию массива.
    Затем используем count для отображения количества нажатий кнопки и setCount (функция «сеттер», которая позволяет изменять состояние) для обновления состояния count.
    useState() — это функция, которая принимает один аргумент. В нём необходимо передать начальное состояние.
    Каждый раз при изменениях, React перерисовывает элементы так, чтобы они соответствовали новому состоянию компонента. */
  function Example() {
    const [count, setCount] = React.useState(0);
      //const [count, setCount] = React.useState(0) - это состояние
        //count - текущего значения состояния
        //setCount - функции для его изменения
        //0 - начальное состояние, может быть, а также: true, false, null, string, int
    setCount(prevCount => prevCount + 1); //prevCount => prevCount + 1 - это функция обновление, которая получает актуальное состояние как аргумент
      //prevCount = count
    setCount(count + 1); //или так, в сокращенной форме

    const [isOpen, setOpen] = React.useState(false);
    const handleClick = () => { //handleClick - функция обработчик. пользовательские события обрабатываются с помощью функций-обработчиков
      //Они вызываются, когда пользователь совершает определённое действие, например, кликает на элемент.
      //обработчик события используется для изменения состояния компонентов приложения (через setOpen / setCount)
      setOpen(!isOpen); //setOpen((state) => !state); - можно и через эту функцию обновления, state - универсальный параметр

      const Words = {
        german,
        italian
      };
      const getWords = (type) => [...Words[type]];
      const [words, setWords] = React.useState(() => getWords('german')); //функция будет возвращать нужный набор данных по его имени.
    };

  return (
    <div>
      <p>Вы нажали {count} раз</p> //разметка, которая зависит от состояния
      <button
        onClick={() => setCount(count + 1)}>
        Нажми меня
      </button>
      <button
        onClick={handleClick} className="more" type="button"
        onClick={() => setOpen(true)} //можно сразу так
      >
        {isOpen ? 'Закрыть' : 'Открыть'}
      </button>
    </div>
  );
}

  //типовые команды для работы с массивом в состоянии (state)
    //Добавление элемента в массив-состояние
      //setItems([...items, newItem]);
    //Удаление элемента из массива-состояния
      //setItems(items.filter(item => item.id !== id));
    //Обновление всех элементов массива-состояния
      //updateItem - функция-модификатор элементов массива
      //setItems(items.map(updateItem));
    //Сброс массива-состояния
      //setItems([]);

/* Хуки.
//2. хук useEffect - позволяет компоненту совершать какую-либо побочную операцию после отрисовки компонента. Это может быть запрос данных с сервера, обработка медиазапросов или управление таймерами.
  Хук useEffect не возвращает значения, как это делают другие хуки, такие как useState.
  Он используется для регистрации «эффекта», который будет вызван после рендеринга компонента, и может останавливаться при его удалении.
  useEffect принимает на вход два аргумента:
    Первый аргумент — функция, которая будет вызываться после рендеринга компонента. Она называется «эффект».
    Второй аргумент — массив зависимостей, которые указывают useEffect на то, когда нужно перезапустить эффект.
  useEffect вызывается каждый раз, когда компонент отрисовывается, и проверяет зависимости. Если зависимости изменились, эффект будет запущен заново */

  //пример реализации - таймеры, Хук useEffect может запустить таймер, будучи уверенным, что никакие параметры и состояния в этот момент не изменятся: рендеринг (отрисовка) уже закончился.
  //Если вам нужно использовать таймер в зависимости от состояния компонента, можете передать это состояние в качестве второго аргумента useEffect, чтобы убедиться, что таймер остановится и перезапустится при изменении этого состояния. Пустой массив зависимостей означает, что эффект будет запущен только один раз.
  //Эффект-функция может возвращать функцию очистки, которая вызывается, когда компонент размонтируется (уничтожается). Функция очистки нужна для отмены таймера или отписки от события.
  function MyComponent() {
    React.useEffect(() => {
      const timerID = setTimeout(() => { // Выполнится один раз после отрисовки компонента
        console.log('Hello from timer!');
      }, 1000);

      return () => clearTimeout(timerID); // Будет вызвана при уничтожении компонента
    }, []);

    return <div>Компонент с таймером</div>;
  }

//Паттерны
  //«Композиция» - один реакт компонент вызывает (содержит в себе) другой

  //«Подъем состояния»
    //Вынести состояние в родительский компонент и передавать его в качестве параметра для дочерних компонентов
    //При смене компонентов с Calendar на Tariff и обратно локальное состояние этих компонентов сбрасывается.
      //И если пользователь решит вернуться на предыдущую страницу, он не увидит выбранные им данные. Для этого из компонента Calendar и Tariff используем «подъем состояния» в компонент App
  //Derived state(или производное состояние) в React — это состояние, которое вычисляется на основе других состояний или свойств компонента.

  //Деструктуризация в React.js
    function UserCard({ name, email, phone, phone2 = ""  }) { //мы получаем объект props и обращаемся к его свойствам напрямую, используя имена свойств
      return (
        <div>
          <h2>{name}</h2> //используем фигурные скобки для извлечения свойств name, email и phone из объекта props
          <p>{email}</p>
          <p>{phone}</p>
        </div>
      );}
    //Еще пример деструктуризации
    const [firstCardData, secondCardData] = cards;




/* Особенности синтаксиса JSX:
  компонент может вернуть только один корневой элемент;
  в атрибутах используются названия свойств DOM-элементов;
  пользовательские компоненты обязательно должны начинаться с заглавной буквы;
  атрибуты пользовательских компонентов — это параметры функций;
  одиночные теги должны быть закрыты.
HTML to JSX:
  for = htmlFor
  class = className
  tabindex = tabIndex
  xlink:href = xlinkHref
  <img> = </img>

Значения false, null, undefined и true не рендерятся. Поэтому удобно использовать оператор && для условного рендеринга

//map для массива
<ul>
  {[
      'Первый элемент списка',
      'Тест2'
    ].map((item) => <li>{item}</li>) //Если метод вернёт JSX, то элементы будут отрендерены.
  }
</ul>
*/
